(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 2017 Julian Garnier
 Released under the MIT license
*/
var $jscomp$this=this;
(function(v,p){"function"===typeof define&&define.amd?define([],p):"object"===typeof module&&module.exports?module.exports=p():v.anime=p()})(this,function(){function v(a){if(!g.col(a))try{return document.querySelectorAll(a)}catch(b){}}function p(a){return a.reduce(function(a,d){return a.concat(g.arr(d)?p(d):d)},[])}function w(a){if(g.arr(a))return a;g.str(a)&&(a=v(a)||a);return a instanceof NodeList||a instanceof HTMLCollection?[].slice.call(a):[a]}function F(a,b){return a.some(function(a){return a===b})}
function A(a){var b={},d;for(d in a)b[d]=a[d];return b}function G(a,b){var d=A(a),c;for(c in a)d[c]=b.hasOwnProperty(c)?b[c]:a[c];return d}function B(a,b){var d=A(a),c;for(c in b)d[c]=g.und(a[c])?b[c]:a[c];return d}function S(a){a=a.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,function(a,b,d,h){return b+b+d+d+h+h});var b=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);a=parseInt(b[1],16);var d=parseInt(b[2],16),b=parseInt(b[3],16);return"rgb("+a+","+d+","+b+")"}function T(a){function b(a,b,c){0>
c&&(c+=1);1<c&&--c;return c<1/6?a+6*(b-a)*c:.5>c?b:c<2/3?a+(b-a)*(2/3-c)*6:a}var d=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(a);a=parseInt(d[1])/360;var c=parseInt(d[2])/100,d=parseInt(d[3])/100;if(0==c)c=d=a=d;else{var e=.5>d?d*(1+c):d+c-d*c,l=2*d-e,c=b(l,e,a+1/3),d=b(l,e,a);a=b(l,e,a-1/3)}return"rgb("+255*c+","+255*d+","+255*a+")"}function x(a){if(a=/([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|pc|vw|vh|deg|rad|turn)?/.exec(a))return a[2]}function U(a){if(-1<a.indexOf("translate"))return"px";
if(-1<a.indexOf("rotate")||-1<a.indexOf("skew"))return"deg"}function H(a,b){return g.fnc(a)?a(b.target,b.id,b.total):a}function C(a,b){if(b in a.style)return getComputedStyle(a).getPropertyValue(b.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase())||"0"}function I(a,b){if(g.dom(a)&&F(V,b))return"transform";if(g.dom(a)&&(a.getAttribute(b)||g.svg(a)&&a[b]))return"attribute";if(g.dom(a)&&"transform"!==b&&C(a,b))return"css";if(null!=a[b])return"object"}function W(a,b){var d=U(b),d=-1<b.indexOf("scale")?
1:0+d;a=a.style.transform;if(!a)return d;for(var c=[],e=[],l=[],h=/(\w+)\((.+?)\)/g;c=h.exec(a);)e.push(c[1]),l.push(c[2]);a=l.filter(function(a,c){return e[c]===b});return a.length?a[0]:d}function J(a,b){switch(I(a,b)){case "transform":return W(a,b);case "css":return C(a,b);case "attribute":return a.getAttribute(b)}return a[b]||0}function K(a,b){var d=/^(\*=|\+=|-=)/.exec(a);if(!d)return a;b=parseFloat(b);a=parseFloat(a.replace(d[0],""));switch(d[0][0]){case "+":return b+a;case "-":return b-a;case "*":return b*
a}}function D(a){return g.obj(a)&&a.hasOwnProperty("totalLength")}function X(a,b){function d(c){c=void 0===c?0:c;return a.el.getPointAtLength(1<=b+c?b+c:0)}var c=d(),e=d(-1),l=d(1);switch(a.property){case "x":return c.x;case "y":return c.y;case "angle":return 180*Math.atan2(l.y-e.y,l.x-e.x)/Math.PI}}function L(a,b){var d=/-?\d*\.?\d+/g;a=D(a)?a.totalLength:a;if(g.col(a))b=g.rgb(a)?a:g.hex(a)?S(a):g.hsl(a)?T(a):void 0;else{var c=x(a);a=c?a.substr(0,a.length-c.length):a;b=b?a+b:a}b+="";return{original:b,
numbers:b.match(d)?b.match(d).map(Number):[0],strings:b.split(d)}}function Y(a,b){return b.reduce(function(b,c,e){return b+a[e-1]+c})}function M(a){return(a?p(g.arr(a)?a.map(w):w(a)):[]).filter(function(a,d,c){return c.indexOf(a)===d})}function Z(a){var b=M(a);return b.map(function(a,c){return{target:a,id:c,total:b.length}})}function aa(a,b){var d=A(b);if(g.arr(a)){var c=a.length;2!==c||g.obj(a[0])?g.fnc(b.duration)||(d.duration=b.duration/c):a={value:a}}return w(a).map(function(a,c){c=c?0:b.delay;
a=g.obj(a)&&!D(a)?a:{value:a};g.und(a.delay)&&(a.delay=c);return a}).map(function(a){return B(a,d)})}function ba(a,b){var d={},c;for(c in a){var e=H(a[c],b);g.arr(e)&&(e=e.map(function(a){return H(a,b)}),1===e.length&&(e=e[0]));d[c]=e}d.duration=parseFloat(d.duration);d.delay=parseFloat(d.delay);return d}function ca(a){return g.arr(a)?y.apply(this,a):N[a]}function da(a,b){var d;return a.tweens.map(function(c){c=ba(c,b);var e=c.value,l=J(b.target,a.name),h=d?d.to.original:l,h=g.arr(e)?e[0]:h,m=K(g.arr(e)?
e[1]:e,h),l=x(m)||x(h)||x(l);c.isPath=D(e);c.from=L(h,l);c.to=L(m,l);c.start=d?d.end:a.offset;c.end=c.start+c.delay+c.duration;c.easing=ca(c.easing);c.elasticity=(1E3-Math.min(Math.max(c.elasticity,1),999))/1E3;g.col(c.from.original)&&(c.round=1);return d=c})}function ea(a,b){return p(a.map(function(a){return b.map(function(b){var c=I(a.target,b.name);if(c){var d=da(b,a);b={type:c,property:b.name,animatable:a,tweens:d,duration:d[d.length-1].end,delay:d[0].delay}}else b=void 0;return b})})).filter(function(a){return!g.und(a)})}
function O(a,b,d){var c="delay"===a?Math.min:Math.max;return b.length?c.apply(Math,b.map(function(b){return b[a]})):d[a]}function fa(a){var b=G(ga,a),d=G(ha,a),c=Z(a.targets),e=[],g=B(b,d),h;for(h in a)g.hasOwnProperty(h)||"targets"===h||e.push({name:h,offset:g.offset,tweens:aa(a[h],d)});a=ea(c,e);return B(b,{children:[],animatables:c,animations:a,duration:O("duration",a,d),delay:O("delay",a,d)})}function n(a){function b(){return window.Promise&&new Promise(function(a){return Q=a})}function d(a){return f.reversed?
f.duration-a:a}function c(a){for(var b=0,c={},d=f.animations,e={};b<d.length;){var g=d[b],h=g.animatable,m=g.tweens;e.tween=m.filter(function(b){return a<b.end})[0]||m[m.length-1];e.isPath$1=e.tween.isPath;e.round=e.tween.round;e.eased=e.tween.easing(Math.min(Math.max(a-e.tween.start-e.tween.delay,0),e.tween.duration)/e.tween.duration,e.tween.elasticity);m=Y(e.tween.to.numbers.map(function(a){return function(b,c){c=a.isPath$1?0:a.tween.from.numbers[c];b=c+a.eased*(b-c);a.isPath$1&&(b=X(a.tween.value,
b));a.round&&(b=Math.round(b*a.round)/a.round);return b}}(e)),e.tween.to.strings);ia[g.type](h.target,g.property,m,c,h.id);g.currentValue=m;b++;e={isPath$1:e.isPath$1,tween:e.tween,eased:e.eased,round:e.round}}if(c)for(var k in c)E||(E=C(document.body,"transform")?"transform":"-webkit-transform"),f.animatables[k].target.style[E]=c[k].join(" ");f.currentTime=a;f.progress=a/f.duration*100}function e(a){if(f[a])f[a](f)}function g(){f.remaining&&!0!==f.remaining&&f.remaining--}function h(a){var h=f.duration,
l=f.offset,n=f.delay,P=f.currentTime,q=f.reversed,r=d(a),r=Math.min(Math.max(r,0),h);if(f.children){var p=f.children;if(r>=f.currentTime)for(var u=0;u<p.length;u++)p[u].seek(r);else for(u=p.length;u--;)p[u].seek(r)}r>l&&r<h?(c(r),!f.began&&r>=n&&(f.began=!0,e("begin")),e("run")):(r<=l&&0!==P&&(c(0),q&&g()),r>=h&&P!==h&&(c(h),q||g()));a>=h&&(f.remaining?(t=m,"alternate"===f.direction&&(f.reversed=!f.reversed)):(f.pause(),"Promise"in window&&(Q(),R=b()),f.completed||(f.completed=!0,e("complete"))),
k=0);e("update")}a=void 0===a?{}:a;var m,t,k=0,Q=null,R=b(),f=fa(a);f.reset=function(){var a=f.direction,b=f.loop;f.currentTime=0;f.progress=0;f.paused=!0;f.began=!1;f.completed=!1;f.reversed="reverse"===a;f.remaining="alternate"===a&&1===b?2:b;for(a=f.children.length;a--;)b=f.children[a],b.seek(b.offset),b.reset()};f.tick=function(a){m=a;t||(t=m);h((k+m-t)*n.speed)};f.seek=function(a){h(d(a))};f.pause=function(){var a=q.indexOf(f);-1<a&&q.splice(a,1);f.paused=!0};f.play=function(){f.paused&&(f.paused=
!1,t=0,k=d(f.currentTime),q.push(f),z||ja())};f.reverse=function(){f.reversed=!f.reversed;t=0;k=d(f.currentTime)};f.restart=function(){f.pause();f.reset();f.play()};f.finished=R;f.reset();f.autoplay&&f.play();return f}var ga={update:void 0,begin:void 0,run:void 0,complete:void 0,loop:1,direction:"normal",autoplay:!0,offset:0},ha={duration:1E3,delay:0,easing:"easeOutElastic",elasticity:500,round:0},V="translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY".split(" "),
E,g={arr:function(a){return Array.isArray(a)},obj:function(a){return-1<Object.prototype.toString.call(a).indexOf("Object")},svg:function(a){return a instanceof SVGElement},dom:function(a){return a.nodeType||g.svg(a)},str:function(a){return"string"===typeof a},fnc:function(a){return"function"===typeof a},und:function(a){return"undefined"===typeof a},hex:function(a){return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a)},rgb:function(a){return/^rgb/.test(a)},hsl:function(a){return/^hsl/.test(a)},col:function(a){return g.hex(a)||
g.rgb(a)||g.hsl(a)}},y=function(){function a(a,d,c){return(((1-3*c+3*d)*a+(3*c-6*d))*a+3*d)*a}return function(b,d,c,e){if(0<=b&&1>=b&&0<=c&&1>=c){var g=new Float32Array(11);if(b!==d||c!==e)for(var h=0;11>h;++h)g[h]=a(.1*h,b,c);return function(h){if(b===d&&c===e)return h;if(0===h)return 0;if(1===h)return 1;for(var m=0,k=1;10!==k&&g[k]<=h;++k)m+=.1;--k;var k=m+(h-g[k])/(g[k+1]-g[k])*.1,l=3*(1-3*c+3*b)*k*k+2*(3*c-6*b)*k+3*b;if(.001<=l){for(m=0;4>m;++m){l=3*(1-3*c+3*b)*k*k+2*(3*c-6*b)*k+3*b;if(0===l)break;
var n=a(k,b,c)-h,k=k-n/l}h=k}else if(0===l)h=k;else{var k=m,m=m+.1,f=0;do n=k+(m-k)/2,l=a(n,b,c)-h,0<l?m=n:k=n;while(1e-7<Math.abs(l)&&10>++f);h=n}return a(h,d,e)}}}}(),N=function(){function a(a,b){return 0===a||1===a?a:-Math.pow(2,10*(a-1))*Math.sin(2*(a-1-b/(2*Math.PI)*Math.asin(1))*Math.PI/b)}var b="Quad Cubic Quart Quint Sine Expo Circ Back Elastic".split(" "),d={In:[[.55,.085,.68,.53],[.55,.055,.675,.19],[.895,.03,.685,.22],[.755,.05,.855,.06],[.47,0,.745,.715],[.95,.05,.795,.035],[.6,.04,.98,
.335],[.6,-.28,.735,.045],a],Out:[[.25,.46,.45,.94],[.215,.61,.355,1],[.165,.84,.44,1],[.23,1,.32,1],[.39,.575,.565,1],[.19,1,.22,1],[.075,.82,.165,1],[.175,.885,.32,1.275],function(b,c){return 1-a(1-b,c)}],InOut:[[.455,.03,.515,.955],[.645,.045,.355,1],[.77,0,.175,1],[.86,0,.07,1],[.445,.05,.55,.95],[1,0,0,1],[.785,.135,.15,.86],[.68,-.55,.265,1.55],function(b,c){return.5>b?a(2*b,c)/2:1-a(-2*b+2,c)/2}]},c={linear:y(.25,.25,.75,.75)},e={},l;for(l in d)e.type=l,d[e.type].forEach(function(a){return function(d,
e){c["ease"+a.type+b[e]]=g.fnc(d)?d:y.apply($jscomp$this,d)}}(e)),e={type:e.type};return c}(),ia={css:function(a,b,d){return a.style[b]=d},attribute:function(a,b,d){return a.setAttribute(b,d)},object:function(a,b,d){return a[b]=d},transform:function(a,b,d,c,e){c[e]||(c[e]=[]);c[e].push(b+"("+d+")")}},q=[],z=0,ja=function(){function a(){z=requestAnimationFrame(b)}function b(b){var c=q.length;if(c){for(var d=0;d<c;)q[d]&&q[d].tick(b),d++;a()}else cancelAnimationFrame(z),z=0}return a}();n.version="2.0.2";
n.speed=1;n.running=q;n.remove=function(a){a=M(a);for(var b=q.length;b--;)for(var d=q[b],c=d.animations,e=c.length;e--;)F(a,c[e].animatable.target)&&(c.splice(e,1),c.length||d.pause())};n.getValue=J;n.path=function(a,b){var d=g.str(a)?v(a)[0]:a,c=b||100;return function(a){return{el:d,property:a,totalLength:d.getTotalLength()*(c/100)}}};n.setDashoffset=function(a){var b=a.getTotalLength();a.setAttribute("stroke-dasharray",b);return b};n.bezier=y;n.easings=N;n.timeline=function(a){var b=n(a);b.pause();
b.duration=0;b.add=function(a){b.children.forEach(function(a){a.began=!0;a.completed=!0});w(a).forEach(function(a){var c=b.duration,d=a.offset;a.autoplay=!1;a.offset=g.und(d)?c:K(d,c);b.seek(a.offset);a=n(a);a.duration>c&&(b.duration=a.duration);a.began=!0;b.children.push(a)});b.reset();b.seek(0);b.autoplay&&b.restart();return b};return b};n.random=function(a,b){return Math.floor(Math.random()*(b-a+1))+a};return n});
},{}],2:[function(require,module,exports){
/* MIT license */
var cssKeywords = require('color-name');

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var v;

	if (max === 0) {
		s = 0;
	} else {
		s = (delta / max * 1000) / 10;
	}

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	v = ((max / 255) * 1000) / 10;

	return [h, s, v];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

},{"color-name":5}],3:[function(require,module,exports){
var conversions = require('./conversions');
var route = require('./route');

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;

},{"./conversions":2,"./route":4}],4:[function(require,module,exports){
var conversions = require('./conversions');

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

// https://jsperf.com/object-keys-vs-for-in-with-closure/3
var models = Object.keys(conversions);

function buildGraph() {
	var graph = {};

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};


},{"./conversions":2}],5:[function(require,module,exports){
module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};
},{}],6:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');
var swizzle = require('simple-swizzle');

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (colorNames.hasOwnProperty(name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = module.exports = {
	to: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorNames[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

},{"color-name":5,"simple-swizzle":229}],7:[function(require,module,exports){
'use strict';

var colorString = require('color-string');
var convert = require('color-convert');

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert).forEach(function (model) {
	hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (!obj) {
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert[this.model].channels;
		var labels = convert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	dark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	light: function () {
		return !this.dark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		var color1 = this.rgb();
		var color2 = mixinColor.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

module.exports = Color;

},{"color-convert":3,"color-string":6}],8:[function(require,module,exports){
/* Font Face Observer v2.0.13 - © Bram Stein. License: BSD-3-Clause */(function(){function l(a,b){document.addEventListener?a.addEventListener("scroll",b,!1):a.attachEvent("scroll",b)}function m(a){document.body?a():document.addEventListener?document.addEventListener("DOMContentLoaded",function c(){document.removeEventListener("DOMContentLoaded",c);a()}):document.attachEvent("onreadystatechange",function k(){if("interactive"==document.readyState||"complete"==document.readyState)document.detachEvent("onreadystatechange",k),a()})};function r(a){this.a=document.createElement("div");this.a.setAttribute("aria-hidden","true");this.a.appendChild(document.createTextNode(a));this.b=document.createElement("span");this.c=document.createElement("span");this.h=document.createElement("span");this.f=document.createElement("span");this.g=-1;this.b.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";this.c.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
this.f.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";this.h.style.cssText="display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;";this.b.appendChild(this.h);this.c.appendChild(this.f);this.a.appendChild(this.b);this.a.appendChild(this.c)}
function t(a,b){a.a.style.cssText="max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:"+b+";"}function y(a){var b=a.a.offsetWidth,c=b+100;a.f.style.width=c+"px";a.c.scrollLeft=c;a.b.scrollLeft=a.b.scrollWidth+100;return a.g!==b?(a.g=b,!0):!1}function z(a,b){function c(){var a=k;y(a)&&a.a.parentNode&&b(a.g)}var k=a;l(a.b,c);l(a.c,c);y(a)};function A(a,b){var c=b||{};this.family=a;this.style=c.style||"normal";this.weight=c.weight||"normal";this.stretch=c.stretch||"normal"}var B=null,C=null,E=null,F=null;function G(){if(null===C)if(J()&&/Apple/.test(window.navigator.vendor)){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent);C=!!a&&603>parseInt(a[1],10)}else C=!1;return C}function J(){null===F&&(F=!!document.fonts);return F}
function K(){if(null===E){var a=document.createElement("div");try{a.style.font="condensed 100px sans-serif"}catch(b){}E=""!==a.style.font}return E}function L(a,b){return[a.style,a.weight,K()?a.stretch:"","100px",b].join(" ")}
A.prototype.load=function(a,b){var c=this,k=a||"BESbswy",q=0,D=b||3E3,H=(new Date).getTime();return new Promise(function(a,b){if(J()&&!G()){var M=new Promise(function(a,b){function e(){(new Date).getTime()-H>=D?b():document.fonts.load(L(c,'"'+c.family+'"'),k).then(function(c){1<=c.length?a():setTimeout(e,25)},function(){b()})}e()}),N=new Promise(function(a,c){q=setTimeout(c,D)});Promise.race([N,M]).then(function(){clearTimeout(q);a(c)},function(){b(c)})}else m(function(){function u(){var b;if(b=-1!=
f&&-1!=g||-1!=f&&-1!=h||-1!=g&&-1!=h)(b=f!=g&&f!=h&&g!=h)||(null===B&&(b=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent),B=!!b&&(536>parseInt(b[1],10)||536===parseInt(b[1],10)&&11>=parseInt(b[2],10))),b=B&&(f==v&&g==v&&h==v||f==w&&g==w&&h==w||f==x&&g==x&&h==x)),b=!b;b&&(d.parentNode&&d.parentNode.removeChild(d),clearTimeout(q),a(c))}function I(){if((new Date).getTime()-H>=D)d.parentNode&&d.parentNode.removeChild(d),b(c);else{var a=document.hidden;if(!0===a||void 0===a)f=e.a.offsetWidth,
g=n.a.offsetWidth,h=p.a.offsetWidth,u();q=setTimeout(I,50)}}var e=new r(k),n=new r(k),p=new r(k),f=-1,g=-1,h=-1,v=-1,w=-1,x=-1,d=document.createElement("div");d.dir="ltr";t(e,L(c,"sans-serif"));t(n,L(c,"serif"));t(p,L(c,"monospace"));d.appendChild(e.a);d.appendChild(n.a);d.appendChild(p.a);document.body.appendChild(d);v=e.a.offsetWidth;w=n.a.offsetWidth;x=p.a.offsetWidth;I();z(e,function(a){f=a;u()});t(e,L(c,'"'+c.family+'",sans-serif'));z(n,function(a){g=a;u()});t(n,L(c,'"'+c.family+'",serif'));
z(p,function(a){h=a;u()});t(p,L(c,'"'+c.family+'",monospace'))})})};"object"===typeof module?module.exports=A:(window.FontFaceObserver=A,window.FontFaceObserver.prototype.load=A.prototype.load);}());

},{}],9:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":11}],10:[function(require,module,exports){
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

},{}],11:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],12:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":107,"./_root":152}],13:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":116,"./_hashDelete":117,"./_hashGet":118,"./_hashHas":119,"./_hashSet":120}],14:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":132,"./_listCacheDelete":133,"./_listCacheGet":134,"./_listCacheHas":135,"./_listCacheSet":136}],15:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":107,"./_root":152}],16:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":137,"./_mapCacheDelete":138,"./_mapCacheGet":139,"./_mapCacheHas":140,"./_mapCacheSet":141}],17:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":107,"./_root":152}],18:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":107,"./_root":152}],19:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":16,"./_setCacheAdd":153,"./_setCacheHas":154}],20:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":14,"./_stackClear":158,"./_stackDelete":159,"./_stackGet":160,"./_stackHas":161,"./_stackSet":162}],21:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":152}],22:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":152}],23:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":107,"./_root":152}],24:[function(require,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],25:[function(require,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],26:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],27:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],28:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],29:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":71,"./_isIndex":125,"./isArguments":192,"./isArray":193,"./isBuffer":196,"./isTypedArray":207}],30:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],31:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],32:[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],33:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],34:[function(require,module,exports){
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;

},{}],35:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":39,"./eq":177}],36:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":177}],37:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":88,"./keys":209}],38:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":88,"./keysIn":210}],39:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":98}],40:[function(require,module,exports){
/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

module.exports = baseClamp;

},{}],41:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isObject = require('./isObject'),
    keys = require('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":20,"./_arrayEach":27,"./_assignValue":35,"./_baseAssign":37,"./_baseAssignIn":38,"./_cloneBuffer":80,"./_copyArray":87,"./_copySymbols":89,"./_copySymbolsIn":90,"./_getAllKeys":103,"./_getAllKeysIn":104,"./_getTag":112,"./_initCloneArray":121,"./_initCloneByTag":122,"./_initCloneObject":123,"./isArray":193,"./isBuffer":196,"./isObject":202,"./keys":209}],42:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":202}],43:[function(require,module,exports){
var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":48,"./_createBaseEach":93}],44:[function(require,module,exports){
var baseEach = require('./_baseEach');

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;

},{"./_baseEach":43}],45:[function(require,module,exports){
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

},{}],46:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":31,"./_isFlattenable":124}],47:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":94}],48:[function(require,module,exports){
var baseFor = require('./_baseFor'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":47,"./keys":209}],49:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":77,"./_toKey":166}],50:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":31,"./isArray":193}],51:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":21,"./_getRawTag":109,"./_objectToString":149}],52:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],53:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":45,"./_baseIsNaN":58,"./_strictIndexOf":163}],54:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":51,"./isObjectLike":203}],55:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":56,"./isObjectLike":203}],56:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":20,"./_equalArrays":99,"./_equalByTag":100,"./_equalObjects":101,"./_getTag":112,"./isArray":193,"./isBuffer":196,"./isTypedArray":207}],57:[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":20,"./_baseIsEqual":55}],58:[function(require,module,exports){
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],59:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":129,"./_toSource":167,"./isFunction":199,"./isObject":202}],60:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":51,"./isLength":200,"./isObjectLike":203}],61:[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":64,"./_baseMatchesProperty":65,"./identity":189,"./isArray":193,"./property":214}],62:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":130,"./_nativeKeys":146}],63:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":130,"./_nativeKeysIn":147,"./isObject":202}],64:[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":57,"./_getMatchData":106,"./_matchesStrictComparable":143}],65:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":55,"./_isKey":127,"./_isStrictComparable":131,"./_matchesStrictComparable":143,"./_toKey":166,"./get":186,"./hasIn":187}],66:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],67:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":49}],68:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":151,"./_setToString":156,"./identity":189}],69:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":98,"./constant":172,"./identity":189}],70:[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],71:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],72:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":21,"./_arrayMap":30,"./isArray":193,"./isSymbol":206}],73:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],74:[function(require,module,exports){
var arrayMap = require('./_arrayMap');

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;

},{"./_arrayMap":30}],75:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],76:[function(require,module,exports){
var identity = require('./identity');

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

},{"./identity":189}],77:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":127,"./_stringToPath":165,"./isArray":193,"./toString":222}],78:[function(require,module,exports){
var baseSlice = require('./_baseSlice');

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;

},{"./_baseSlice":70}],79:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":22}],80:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":152}],81:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":79}],82:[function(require,module,exports){
var addMapEntry = require('./_addMapEntry'),
    arrayReduce = require('./_arrayReduce'),
    mapToArray = require('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":24,"./_arrayReduce":32,"./_mapToArray":142}],83:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],84:[function(require,module,exports){
var addSetEntry = require('./_addSetEntry'),
    arrayReduce = require('./_arrayReduce'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":25,"./_arrayReduce":32,"./_setToArray":155}],85:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":21}],86:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":79}],87:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],88:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":35,"./_baseAssignValue":39}],89:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":88,"./_getSymbols":110}],90:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":88,"./_getSymbolsIn":111}],91:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":152}],92:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":68,"./_isIterateeCall":126}],93:[function(require,module,exports){
var isArrayLike = require('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":194}],94:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],95:[function(require,module,exports){
var castSlice = require('./_castSlice'),
    hasUnicode = require('./_hasUnicode'),
    stringToArray = require('./_stringToArray'),
    toString = require('./toString');

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;

},{"./_castSlice":78,"./_hasUnicode":115,"./_stringToArray":164,"./toString":222}],96:[function(require,module,exports){
var baseIteratee = require('./_baseIteratee'),
    isArrayLike = require('./isArrayLike'),
    keys = require('./keys');

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;

},{"./_baseIteratee":61,"./isArrayLike":194,"./keys":209}],97:[function(require,module,exports){
var eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

module.exports = customDefaultsAssignIn;

},{"./eq":177}],98:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":107}],99:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":19,"./_arraySome":33,"./_cacheHas":75}],100:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":21,"./_Uint8Array":22,"./_equalArrays":99,"./_mapToArray":142,"./_setToArray":155,"./eq":177}],101:[function(require,module,exports){
var getAllKeys = require('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":103}],102:[function(require,module,exports){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

},{}],103:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":50,"./_getSymbols":110,"./keys":209}],104:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":50,"./_getSymbolsIn":111,"./keysIn":210}],105:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":128}],106:[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":131,"./keys":209}],107:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":59,"./_getValue":113}],108:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":150}],109:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":21}],110:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":28,"./stubArray":216}],111:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":31,"./_getPrototype":108,"./_getSymbols":110,"./stubArray":216}],112:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":12,"./_Map":15,"./_Promise":17,"./_Set":18,"./_WeakMap":23,"./_baseGetTag":51,"./_toSource":167}],113:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],114:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":77,"./_isIndex":125,"./_toKey":166,"./isArguments":192,"./isArray":193,"./isLength":200}],115:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;

},{}],116:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":145}],117:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],118:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":145}],119:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":145}],120:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":145}],121:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],122:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneMap = require('./_cloneMap'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSet = require('./_cloneSet'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":79,"./_cloneDataView":81,"./_cloneMap":82,"./_cloneRegExp":83,"./_cloneSet":84,"./_cloneSymbol":85,"./_cloneTypedArray":86}],123:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":42,"./_getPrototype":108,"./_isPrototype":130}],124:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

},{"./_Symbol":21,"./isArguments":192,"./isArray":193}],125:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],126:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":125,"./eq":177,"./isArrayLike":194,"./isObject":202}],127:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":193,"./isSymbol":206}],128:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],129:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":91}],130:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],131:[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":202}],132:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],133:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":36}],134:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":36}],135:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":36}],136:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":36}],137:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":13,"./_ListCache":14,"./_Map":15}],138:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":105}],139:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":105}],140:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":105}],141:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":105}],142:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],143:[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],144:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":212}],145:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":107}],146:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":150}],147:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],148:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":102}],149:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],150:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],151:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":26}],152:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":102}],153:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],154:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],155:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],156:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":69,"./_shortOut":157}],157:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],158:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":14}],159:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],160:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],161:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],162:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":14,"./_Map":15,"./_MapCache":16}],163:[function(require,module,exports){
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

},{}],164:[function(require,module,exports){
var asciiToArray = require('./_asciiToArray'),
    hasUnicode = require('./_hasUnicode'),
    unicodeToArray = require('./_unicodeToArray');

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;

},{"./_asciiToArray":34,"./_hasUnicode":115,"./_unicodeToArray":168}],165:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":144}],166:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":206}],167:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],168:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;

},{}],169:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    keysIn = require('./keysIn');

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

module.exports = assignInWith;

},{"./_copyObject":88,"./_createAssigner":92,"./keysIn":210}],170:[function(require,module,exports){
var toString = require('./toString'),
    upperFirst = require('./upperFirst');

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

module.exports = capitalize;

},{"./toString":222,"./upperFirst":225}],171:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":41}],172:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],173:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":202,"./now":213,"./toNumber":221}],174:[function(require,module,exports){
var apply = require('./_apply'),
    assignInWith = require('./assignInWith'),
    baseRest = require('./_baseRest'),
    customDefaultsAssignIn = require('./_customDefaultsAssignIn');

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(args) {
  args.push(undefined, customDefaultsAssignIn);
  return apply(assignInWith, undefined, args);
});

module.exports = defaults;

},{"./_apply":26,"./_baseRest":68,"./_customDefaultsAssignIn":97,"./assignInWith":169}],175:[function(require,module,exports){
module.exports = require('./forEach');

},{"./forEach":185}],176:[function(require,module,exports){
var baseClamp = require('./_baseClamp'),
    baseToString = require('./_baseToString'),
    toInteger = require('./toInteger'),
    toString = require('./toString');

/**
 * Checks if `string` ends with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=string.length] The position to search up to.
 * @returns {boolean} Returns `true` if `string` ends with `target`,
 *  else `false`.
 * @example
 *
 * _.endsWith('abc', 'c');
 * // => true
 *
 * _.endsWith('abc', 'b');
 * // => false
 *
 * _.endsWith('abc', 'b', 2);
 * // => true
 */
function endsWith(string, target, position) {
  string = toString(string);
  target = baseToString(target);

  var length = string.length;
  position = position === undefined
    ? length
    : baseClamp(toInteger(position), 0, length);

  var end = position;
  position -= target.length;
  return position >= 0 && string.slice(position, end) == target;
}

module.exports = endsWith;

},{"./_baseClamp":40,"./_baseToString":72,"./toInteger":220,"./toString":222}],177:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],178:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    baseFilter = require('./_baseFilter'),
    baseIteratee = require('./_baseIteratee'),
    isArray = require('./isArray');

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;

},{"./_arrayFilter":28,"./_baseFilter":44,"./_baseIteratee":61,"./isArray":193}],179:[function(require,module,exports){
var createFind = require('./_createFind'),
    findIndex = require('./findIndex');

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;

},{"./_createFind":96,"./findIndex":180}],180:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIteratee = require('./_baseIteratee'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;

},{"./_baseFindIndex":45,"./_baseIteratee":61,"./toInteger":220}],181:[function(require,module,exports){
var createFind = require('./_createFind'),
    findLastIndex = require('./findLastIndex');

/**
 * This method is like `_.find` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=collection.length-1] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * _.findLast([1, 2, 3, 4], function(n) {
 *   return n % 2 == 1;
 * });
 * // => 3
 */
var findLast = createFind(findLastIndex);

module.exports = findLast;

},{"./_createFind":96,"./findLastIndex":182}],182:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIteratee = require('./_baseIteratee'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * This method is like `_.findIndex` except that it iterates over elements
 * of `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
 * // => 2
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
 * // => 0
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastIndex(users, ['active', false]);
 * // => 2
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastIndex(users, 'active');
 * // => 0
 */
function findLastIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== undefined) {
    index = toInteger(fromIndex);
    index = fromIndex < 0
      ? nativeMax(length + index, 0)
      : nativeMin(index, length - 1);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);
}

module.exports = findLastIndex;

},{"./_baseFindIndex":45,"./_baseIteratee":61,"./toInteger":220}],183:[function(require,module,exports){
module.exports = require('./head');

},{"./head":188}],184:[function(require,module,exports){
var baseFlatten = require('./_baseFlatten');

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

},{"./_baseFlatten":46}],185:[function(require,module,exports){
var arrayEach = require('./_arrayEach'),
    baseEach = require('./_baseEach'),
    castFunction = require('./_castFunction'),
    isArray = require('./isArray');

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

},{"./_arrayEach":27,"./_baseEach":43,"./_castFunction":76,"./isArray":193}],186:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":49}],187:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":52,"./_hasPath":114}],188:[function(require,module,exports){
/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

module.exports = head;

},{}],189:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],190:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf'),
    isArrayLike = require('./isArrayLike'),
    isString = require('./isString'),
    toInteger = require('./toInteger'),
    values = require('./values');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

module.exports = includes;

},{"./_baseIndexOf":53,"./isArrayLike":194,"./isString":205,"./toInteger":220,"./values":226}],191:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseIndexOf(array, value, index);
}

module.exports = indexOf;

},{"./_baseIndexOf":53,"./toInteger":220}],192:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":54,"./isObjectLike":203}],193:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],194:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":199,"./isLength":200}],195:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":194,"./isObjectLike":203}],196:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":152,"./stubFalse":217}],197:[function(require,module,exports){
var isObjectLike = require('./isObjectLike'),
    isPlainObject = require('./isPlainObject');

/**
 * Checks if `value` is likely a DOM element.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
 * @example
 *
 * _.isElement(document.body);
 * // => true
 *
 * _.isElement('<body>');
 * // => false
 */
function isElement(value) {
  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
}

module.exports = isElement;

},{"./isObjectLike":203,"./isPlainObject":204}],198:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

},{"./_baseIsEqual":55}],199:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":51,"./isObject":202}],200:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],201:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;

},{"./_baseGetTag":51,"./isObjectLike":203}],202:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],203:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],204:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":51,"./_getPrototype":108,"./isObjectLike":203}],205:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

},{"./_baseGetTag":51,"./isArray":193,"./isObjectLike":203}],206:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":51,"./isObjectLike":203}],207:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":60,"./_baseUnary":73,"./_nodeUtil":148}],208:[function(require,module,exports){
/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

},{}],209:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":29,"./_baseKeys":62,"./isArrayLike":194}],210:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":29,"./_baseKeysIn":63,"./isArrayLike":194}],211:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],212:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":16}],213:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":152}],214:[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":66,"./_basePropertyDeep":67,"./_isKey":127,"./_toKey":166}],215:[function(require,module,exports){
var baseClamp = require('./_baseClamp'),
    baseToString = require('./_baseToString'),
    toInteger = require('./toInteger'),
    toString = require('./toString');

/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */
function startsWith(string, target, position) {
  string = toString(string);
  position = position == null
    ? 0
    : baseClamp(toInteger(position), 0, string.length);

  target = baseToString(target);
  return string.slice(position, position + target.length) == target;
}

module.exports = startsWith;

},{"./_baseClamp":40,"./_baseToString":72,"./toInteger":220,"./toString":222}],216:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],217:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],218:[function(require,module,exports){
var debounce = require('./debounce'),
    isObject = require('./isObject');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

},{"./debounce":173,"./isObject":202}],219:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":221}],220:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":219}],221:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":202,"./isSymbol":206}],222:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":72}],223:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    arrayMap = require('./_arrayMap'),
    baseProperty = require('./_baseProperty'),
    baseTimes = require('./_baseTimes'),
    isArrayLikeObject = require('./isArrayLikeObject');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.zip` except that it accepts an array of grouped
 * elements and creates an array regrouping the elements to their pre-zip
 * configuration.
 *
 * @static
 * @memberOf _
 * @since 1.2.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
 * // => [['a', 1, true], ['b', 2, false]]
 *
 * _.unzip(zipped);
 * // => [['a', 'b'], [1, 2], [true, false]]
 */
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = arrayFilter(array, function(group) {
    if (isArrayLikeObject(group)) {
      length = nativeMax(group.length, length);
      return true;
    }
  });
  return baseTimes(length, function(index) {
    return arrayMap(array, baseProperty(index));
  });
}

module.exports = unzip;

},{"./_arrayFilter":28,"./_arrayMap":30,"./_baseProperty":66,"./_baseTimes":71,"./isArrayLikeObject":195}],224:[function(require,module,exports){
var apply = require('./_apply'),
    arrayMap = require('./_arrayMap'),
    unzip = require('./unzip');

/**
 * This method is like `_.unzip` except that it accepts `iteratee` to specify
 * how regrouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  regrouped values.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
 * // => [[1, 10, 100], [2, 20, 200]]
 *
 * _.unzipWith(zipped, _.add);
 * // => [3, 30, 300]
 */
function unzipWith(array, iteratee) {
  if (!(array && array.length)) {
    return [];
  }
  var result = unzip(array);
  if (iteratee == null) {
    return result;
  }
  return arrayMap(result, function(group) {
    return apply(iteratee, undefined, group);
  });
}

module.exports = unzipWith;

},{"./_apply":26,"./_arrayMap":30,"./unzip":223}],225:[function(require,module,exports){
var createCaseFirst = require('./_createCaseFirst');

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

module.exports = upperFirst;

},{"./_createCaseFirst":95}],226:[function(require,module,exports){
var baseValues = require('./_baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

},{"./_baseValues":74,"./keys":209}],227:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    unzipWith = require('./unzipWith');

/**
 * This method is like `_.zip` except that it accepts `iteratee` to specify
 * how grouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  grouped values.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
 *   return a + b + c;
 * });
 * // => [111, 222]
 */
var zipWith = baseRest(function(arrays) {
  var length = arrays.length,
      iteratee = length > 1 ? arrays[length - 1] : undefined;

  iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
  return unzipWith(arrays, iteratee);
});

module.exports = zipWith;

},{"./_baseRest":68,"./unzipWith":224}],228:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":9,"trim":231}],229:[function(require,module,exports){
'use strict';

var isArrayish = require('is-arrayish');

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};

},{"is-arrayish":230}],230:[function(require,module,exports){
'use strict';

module.exports = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

},{}],231:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],232:[function(require,module,exports){
"use strict";
var window = require("global/window")
var isFunction = require("is-function")
var parseHeaders = require("parse-headers")
var xtend = require("xtend")

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML
    }

    return null
}

function noop() {}

},{"global/window":10,"is-function":11,"parse-headers":228,"xtend":233}],233:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],234:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _Style = require('zimplist/utils/Style');

var _Style2 = _interopRequireDefault(_Style);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies
// import _ from "lodash";

// Zimplist Depedencies


/*
 Encoder commands :

 You will need FFMPEG with recent libvpx and libH264 support compiled

 // for the fallback
 ffmpeg -i dancer.mov -vf "split [rgb][alpha]; [alpha] alphaextract [alpha]; [rgb] pad=width=iw:height=2*ih:x=0:y=0 [rgb]; [rgb][alpha] overlay=x=0:y=h, scale=720:-1" -c:v libx264 -profile:v main -level 5 -pix_fmt yuv420p -crf 21 -movflags +faststart -y output.mp4


 // native VP9 alpha channel
 ffmpeg -i papillons.mov -r 25 -c:v libvpx-vp9 -b:v 500k -crf 20 -quality best -speed 0 -threads 8 -tile-columns 3 -pix_fmt yuva420p -y output.webm

 */

// Hidden consts

/**
 *
 */
var AlphaVideo = function (_BaseView) {
    _inherits(AlphaVideo, _BaseView);

    function AlphaVideo(el, options) {
        _classCallCheck(this, AlphaVideo);

        /**
         * The native video player
         *
         * @type {Element}
         */
        var _this = _possibleConstructorReturn(this, (AlphaVideo.__proto__ || Object.getPrototypeOf(AlphaVideo)).call(this, el, options));

        _this.nativeVideo = _this.el.querySelector('video');

        // Detect if we can use transparent VP9 encoding
        _this.useFallback = !(_this.nativeVideo.canPlayType('video/webm; codecs=vp9') === 'probably');

        // TODO add 'noFallback' option

        /**
         * Base source path. resolotion and format specifiers are appended when detected
         * @type {string}
         */
        _this.srcBase = _this.nativeVideo.getAttribute('data-src');

        if (_this.useFallback) {

            /**
             * The scale of the fall back. Use to scale up smaller videos that are easier to paint
             * @type {Number}
             */
            _this.fallbackScale = parseFloat(_this.nativeVideo.getAttribute('data-fallback-scale')) || 1;

            _this.el.classList.add('fallback');

            _this.nativeVideo.src = _this.srcBase + '_small.mp4';

            if (_this.nativeVideo.videoWidth && _this.nativeVideo.videoHeight && _this.nativeVideo.duration) {
                _this._createRenderer();
            } else {
                _this.addDomEvent('loadedmetadata', _this._nativeVideoMetadataHandler, _this.nativeVideo);
            }

            _this.addDomEvent('playing', _this._nativeVideoPlayingHandler, _this.nativeVideo);
            _this.addDomEvent('pause', _this._nativeVideoPauseHandler, _this.nativeVideo);

            // Video might already be loaded
            if (!_this.nativeVideo.paused) {
                _this._createRenderer();
                _this._startRenderLoop();
            }
        } else {

            _this.nativeVideo.src = _this.srcBase + '_full.webm';
        }

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(AlphaVideo, [{
        key: 'breakpointChanged',
        value: function breakpointChanged(breakpoint, previousBreakpoint) {
            _get(AlphaVideo.prototype.__proto__ || Object.getPrototypeOf(AlphaVideo.prototype), 'breakpointChanged', this).call(this, breakpoint, previousBreakpoint);
        }

        /* ==========================
          Private Methods
          ========================== */

    }, {
        key: '_createRenderer',
        value: function _createRenderer() {

            if (!this._renderCanvas) {
                var renderCanvas = document.createElement('canvas');
                renderCanvas.width = this.nativeVideo.videoWidth;
                renderCanvas.height = this.nativeVideo.videoHeight / 2;

                var alphaCanvas = document.createElement('canvas');
                alphaCanvas.width = this.nativeVideo.videoWidth;
                alphaCanvas.height = this.nativeVideo.videoHeight / 2;

                this._renderCanvas = renderCanvas;
                this._renderContext = renderCanvas.getContext('2d');

                this._alphaContext = alphaCanvas;
                this._alphaContext = alphaCanvas.getContext('2d');

                // Apply scale
                _Style2.default.set(this._renderCanvas, { transform: 'scale(' + this.fallbackScale + ')' });

                _Style2.default.set(this.el, {
                    width: this.nativeVideo.videoWidth * this.fallbackScale,
                    height: this.nativeVideo.videoHeight / 2 * this.fallbackScale
                });

                this.el.appendChild(renderCanvas);
            }
        }
    }, {
        key: '_render',
        value: function _render() {

            var frameWidth = this.nativeVideo.videoWidth;
            var frameHeight = this.nativeVideo.videoHeight / 2;

            // Copy RGB Data
            this._renderContext.drawImage(this.nativeVideo, 0, 0, frameWidth, frameHeight, 0, 0, frameWidth, frameHeight);

            // Copy Alpha Data
            this._alphaContext.drawImage(this.nativeVideo, 0, frameHeight, frameWidth, frameHeight, 0, 0, frameWidth, frameHeight);

            var rgbData = this._renderContext.getImageData(0, 0, frameWidth, frameHeight);
            var alphaData = this._alphaContext.getImageData(0, 0, frameWidth, frameHeight);

            var rgbDataLen = rgbData.data.length;

            // Get grayscale value from alpha data
            for (var i = 0; i < rgbDataLen - 3; i += 4) {

                var aR = alphaData.data[i];
                var aB = alphaData.data[i + 1];
                var aG = alphaData.data[i + 2];

                // Set rgba's Alpha value to the grayscale value
                rgbData.data[i + 3] = (aR + aB + aG) / 3; // Average
            }

            this._renderContext.putImageData(rgbData, 0, 0);
        }
    }, {
        key: '_startRenderLoop',
        value: function _startRenderLoop() {
            var _this2 = this;

            if (!this._queuedFrame) {
                this._queuedFrame = window.requestAnimationFrame(function () {
                    _this2._queuedFrame = null;
                    _this2._render();
                    _this2._startRenderLoop();
                });
            }
        }
    }, {
        key: '_stopRenderLoop',
        value: function _stopRenderLoop() {
            console.log('stop render');
            if (this._queuedFrame) {
                window.cancelAnimationFrame(this.queuedFrame);
            }
        }

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_nativeVideoMetadataHandler',
        value: function _nativeVideoMetadataHandler(event) {
            this._createRenderer();
        }
    }, {
        key: '_nativeVideoPlayingHandler',
        value: function _nativeVideoPlayingHandler(event) {
            if (this.useFallback) {
                this._startRenderLoop();
            }
        }
    }, {
        key: '_nativeVideoPauseHandler',
        value: function _nativeVideoPauseHandler(event) {
            if (this.useFallback) {
                this._stopRenderLoop();
            }
        }
    }]);

    return AlphaVideo;
}(_BaseView3.default);

exports.default = AlphaVideo;

},{"zimplist/display/BaseView":258,"zimplist/utils/Style":274}],235:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _Style = require('zimplist/utils/Style');

var _Style2 = _interopRequireDefault(_Style);

var _WindowManager = require('zimplist/utils/WindowManager');

var _WindowManager2 = _interopRequireDefault(_WindowManager);

var _Touch = require('zimplist/input/Touch');

var _Touch2 = _interopRequireDefault(_Touch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
// Zimplist Dependencies


// import getDocumentRect from 'zimplist/display/getDocumentRect';

var CareerSlider = function (_BaseView) {
    _inherits(CareerSlider, _BaseView);

    function CareerSlider(el, options) {
        _classCallCheck(this, CareerSlider);

        var _this = _possibleConstructorReturn(this, (CareerSlider.__proto__ || Object.getPrototypeOf(CareerSlider)).call(this, el, { breakpoints: ['xxs', 's', 'm'] }));

        _this.itemContainer = _this.el.querySelector('.slider-item-container');

        _this.items = Array.from(_this.el.querySelectorAll('.slider-item'));

        _this.currentIndex = 0;
        _this.countVisibleItems();

        _this.gotoItem(0);

        // setup DOM events
        _this.addDomEvent('click', _this._navClickHandler, 'button');

        // Setup touch detection
        _this._touchManager = new _Touch2.default(_this.el);

        _this._touchManager.on('swipe', function (event) {
            var itemIndex = _this.currentIndex + (event.distance.x > 0 ? -1 : 1);
            itemIndex = Math.max(0, Math.min(_this.items.length - 1, itemIndex));

            _this.gotoItem(itemIndex);
        });

        return _this;
    }

    _createClass(CareerSlider, [{
        key: 'countVisibleItems',
        value: function countVisibleItems() {
            switch (this.currentBreakpoint.name) {
                case 'xxs':
                    this.visibleItems = 1;
                    break;
                case 's':
                    this.visibleItems = 2;
                    break;
                case 'm':
                    this.visibleItems = 3;
                    break;
            }
        }
    }, {
        key: 'resize',
        value: function resize() {

            // measure item width by getting
            this.itemWidth = this.items[1].offsetLeft;
        }
    }, {
        key: 'breakpointChanged',
        value: function breakpointChanged(breakpoint, previousBreakpoint) {
            _get(CareerSlider.prototype.__proto__ || Object.getPrototypeOf(CareerSlider.prototype), 'breakpointChanged', this).call(this, breakpoint, previousBreakpoint);
            this.countVisibleItems();
            this.gotoItem(this.currentIndex);
        }
    }, {
        key: 'gotoItem',
        value: function gotoItem(itemIndex) {
            var _this2 = this;

            _Style2.default.set(this.itemContainer, {
                transform: 'translateX(-' + itemIndex * this.itemWidth + 'px)'
            });

            // show hide elements
            this.items.forEach(function (item, i) {
                if (i >= itemIndex && i <= itemIndex + _this2.visibleItems - 1) {
                    item.classList.add('visible');
                } else {
                    item.classList.remove('visible');
                }
            });

            // show/hide nav buttons
            if (itemIndex === 0) {
                this.el.classList.add('hide-prev');
                this.el.classList.remove('hide-next');
            } else if (itemIndex === this.items.length - this.visibleItems) {
                this.el.classList.remove('hide-prev');
                this.el.classList.add('hide-next');
            } else {
                this.el.classList.remove('hide-prev');
                this.el.classList.remove('hide-next');
            }

            this.currentIndex = itemIndex;
        }

        /*
         Event Handlers
          */

    }, {
        key: '_navClickHandler',
        value: function _navClickHandler(event) {
            var itemIndex = void 0;
            if (event.delegateTarget.classList.contains('prev')) {
                itemIndex = Math.max(0, this.currentIndex - 1);
            } else {
                itemIndex = Math.min(this.items.length - this.visibleItems, this.currentIndex + 1);
            }
            this.gotoItem(itemIndex);
        }
    }]);

    return CareerSlider;
}(_BaseView3.default);

exports.default = CareerSlider;

},{"zimplist/display/BaseView":258,"zimplist/input/Touch":269,"zimplist/utils/Style":274,"zimplist/utils/WindowManager":275}],236:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies

// UZIK Depedencies


// Local app Dependencies


/**
 * Select style link list
 */
var LinkSelect = function (_BaseView) {
    _inherits(LinkSelect, _BaseView);

    function LinkSelect(el, options) {
        _classCallCheck(this, LinkSelect);

        var _this = _possibleConstructorReturn(this, (LinkSelect.__proto__ || Object.getPrototypeOf(LinkSelect)).call(this, el, options));

        _this.addDomEvent('click', _this._labelClickHandler, '.label');
        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    /* ==========================
      Private Methods
      ========================== */

    /* ==========================
      Event Handlers
      ========================== */


    _createClass(LinkSelect, [{
        key: '_labelClickHandler',
        value: function _labelClickHandler(event) {

            if (this.el.classList.contains('expanded')) {

                this.el.classList.remove('expanded');
                this.trigger('close', {});
            } else {

                this.el.classList.add('expanded');
                this.trigger('open', {});
            }
        }
    }]);

    return LinkSelect;
}(_BaseView3.default);

exports.default = LinkSelect;

},{"zimplist/display/BaseView":258}],237:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _zipWith = require('lodash/zipWith');

var _zipWith2 = _interopRequireDefault(_zipWith);

var _animejs = require('animejs');

var _animejs2 = _interopRequireDefault(_animejs);

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _Style = require('zimplist/utils/Style');

var _Style2 = _interopRequireDefault(_Style);

var _YoutubePlayer = require('app/components/YoutubePlayer');

var _YoutubePlayer2 = _interopRequireDefault(_YoutubePlayer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// Zimplist Depedencies


// Local app Dependencies


// Hidden consts

/**
 *
 */
var MediaGallery = function (_BaseView) {
    _inherits(MediaGallery, _BaseView);

    function MediaGallery(el, options) {
        _classCallCheck(this, MediaGallery);

        var _this = _possibleConstructorReturn(this, (MediaGallery.__proto__ || Object.getPrototypeOf(MediaGallery)).call(this, el, options));

        _this.visualContainer = _this.el.querySelector('.gallery-visual-animator');
        _this.textContainer = _this.el.querySelector('.gallery-text-content');

        _this.visualItems = Array.from(_this.visualContainer.querySelectorAll('.gallery-item'));
        _this.textItems = Array.from(_this.textContainer.querySelectorAll('.gallery-item-text'));

        _this.indexEl = _this.el.querySelector('.gallery-item-index > .value');

        // merge two arrays together into object
        _this.items = (0, _zipWith2.default)(_this.visualItems, _this.textItems, function (visual, text) {
            visual.classList.add('visible');
            return { visual: visual, text: text };
        });

        _this.currentIndex = 0;

        _this.textItems[_this.currentIndex].classList.add('current');

        _this.addDomEvent('click', _this._navClickHandler, '.gallery-nav button');

        _this.addDomEvent('click', _this._videoItemClickHandler, '.gallery-item.item-video');

        _this.resize();
        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(MediaGallery, [{
        key: 'breakpointChanged',
        value: function breakpointChanged(breakpoint, previousBreakpoint) {}
    }, {
        key: 'resize',
        value: function resize() {

            // place all items in a row
            this.visualItems.forEach(function (item, i) {

                _Style2.default.set(item, { left: i * 100 + '%' });
            });
        }
    }, {
        key: 'gotoItem',
        value: function gotoItem(itemIndex) {
            if (itemIndex !== this.currentIndex) {
                var currentItem = this.items[this.currentIndex];
                var queuedItem = this.items[itemIndex];

                // get dirction of transition // TODO adapt for infinite slider
                var direction = itemIndex < this.currentIndex ? -1 : 1; // TODO use direction for sliding window effet

                var duration = Math.abs(itemIndex - this.currentIndex) * 500;

                (0, _animejs2.default)({
                    targets: this.visualContainer,
                    duration: duration,
                    translateX: -(itemIndex * 100) + '%',
                    easing: 'easeInOutCubic'
                });

                // Update texts
                this.textItems[this.currentIndex].classList.remove('current');
                this.textItems[itemIndex].classList.add('current');

                // update index
                this.indexEl.textContent = itemIndex + 1 + ' / ' + this.items.length;

                // Stp video player if it exists
                if (this.currentVideoPlayer) {
                    this.currentVideoPlayer.remove();
                    this.currentVideoPlayer = null;
                }

                // Swap references at the end
                this.currentIndex = itemIndex;
            }
        }

        /* ==========================
          Private Methods
          ========================== */

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_navClickHandler',
        value: function _navClickHandler(event) {
            var queuedItem = event.delegateTarget.classList.contains('prev') ? this.currentIndex - 1 : this.currentIndex + 1;

            // clamp values
            queuedItem = Math.max(0, Math.min(this.items.length - 1, queuedItem));

            this.gotoItem(queuedItem);
        }
    }, {
        key: '_videoItemClickHandler',
        value: function _videoItemClickHandler(event) {

            var videoContainer = document.createElement('div');
            videoContainer.className = 'youtube-player';

            var youtubePlayer = new _YoutubePlayer2.default(videoContainer, {
                videoId: event.delegateTarget.getAttribute('data-video-id'),
                autoPlay: true
            });

            this.currentVideoPlayer = youtubePlayer;

            // Append player to container
            event.delegateTarget.appendChild(youtubePlayer.el);
        }
    }]);

    return MediaGallery;
}(_BaseView3.default);

exports.default = MediaGallery;

},{"animejs":1,"app/components/YoutubePlayer":240,"lodash/zipWith":227,"zimplist/display/BaseView":258,"zimplist/utils/Style":274}],238:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _animejs = require('animejs');

var _animejs2 = _interopRequireDefault(_animejs);

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _Touch = require('zimplist/input/Touch');

var _Touch2 = _interopRequireDefault(_Touch);

var _Style = require('zimplist/utils/Style');

var _Style2 = _interopRequireDefault(_Style);

var _WindowManager = require('zimplist/utils/WindowManager');

var _WindowManager2 = _interopRequireDefault(_WindowManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// Zimplist Depedencies


// Local app Dependencies


// Hidden consts
var TRANSITION_SPEED = 1.25;

/**
 *
 */

var ProfileSlider = function (_BaseView) {
    _inherits(ProfileSlider, _BaseView);

    function ProfileSlider(el, options) {
        _classCallCheck(this, ProfileSlider);

        // Save DOM references
        var _this = _possibleConstructorReturn(this, (ProfileSlider.__proto__ || Object.getPrototypeOf(ProfileSlider)).call(this, el, { breakpoints: ['xxs', 'm'] }));

        _this._itemContainer = _this.el.querySelector('.item-container');
        _this._items = Array.from(_this._itemContainer.querySelectorAll('.career-profile'));

        // State vars
        _this.currentIndex = 0;
        _this.currentOffset = 0;

        // Touch handling
        _this._touchTracker = new _Touch2.default(_this.el);

        _this.listenTo(_this._touchTracker, 'move', _this._touchMoveHandler);
        _this.listenTo(_this._touchTracker, 'end', _this._touchEndHandler);

        _this.resize();

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(ProfileSlider, [{
        key: 'breakpointChanged',
        value: function breakpointChanged(breakpoint, previousBreakpoin) {

            if (breakpoint.name === 'm') {} else {}
        }
    }, {
        key: 'resize',
        value: function resize() {

            if (!this.minWidth('m')) {
                this._itemWidth = this._items[0].clientWidth;
                this._itemMargin = this._items[1].offsetLeft - this._items[0].offsetLeft - this._itemWidth;

                this._itemOffset = this._itemWidth + this._itemMargin;

                // offset container to maintain item centering
                var offset = (_WindowManager2.default.width - this._itemWidth) / 2;
                _Style2.default.set(this._itemContainer, { left: offset });
            } else {

                _Style2.default.set(this._itemContainer, { left: null, transform: null });

                // this._itemContainer.style.removeProperty('left');
            }
        }
    }, {
        key: 'gotoItem',
        value: function gotoItem(itemIndex) {
            var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


            // calc px offest for index
            var offset = -(itemIndex * this._itemOffset);

            // Duration relative to the distance to scroll
            var duration = Math.max(150, Math.abs(offset - this.currentOffset) * TRANSITION_SPEED); // at least 100ms to snap back from end

            if (animate) {
                (0, _animejs2.default)({
                    targets: this._itemContainer,
                    duration: duration,
                    translateX: offset,
                    easing: 'easeOutCubic'
                });
            } else {
                _Style2.default.set(this._itemContainer, { transform: 'translateX(' + offset + 'px)' });
            }

            // save state vars
            this.currentOffset = offset;
            this.currentIndex = itemIndex;
        }

        /* ==========================
          Private Methods
          ========================== */

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_touchMoveHandler',
        value: function _touchMoveHandler() {

            if (this.minWidth('m')) return;

            var distanceX = this._touchTracker.distanceX;
            var distanceY = this._touchTracker.distanceY;

            if (Math.abs(distanceX) > Math.abs(distanceY)) {
                var offset = this.currentOffset + distanceX;
                _Style2.default.set(this._itemContainer, { transform: 'translateX(' + offset + 'px)' });
            }
        }
    }, {
        key: '_touchEndHandler',
        value: function _touchEndHandler() {

            if (this.minWidth('m')) return;

            var distanceX = this._touchTracker.distanceX;
            var distanceY = this._touchTracker.distanceY;

            if (Math.abs(distanceX) > 30 && Math.abs(distanceX) > Math.abs(distanceY)) {

                var queuedIndex = distanceX > 0 ? this.currentIndex - 1 : this.currentIndex + 1;

                // Clamp to item range
                queuedIndex = Math.max(0, Math.min(this._items.length - 1, queuedIndex));

                this.gotoItem(queuedIndex);
            } else {
                // snap back to the current item if it hasn't moved much
                this.gotoItem(this.currentIndex);
            }
        }
    }]);

    return ProfileSlider;
}(_BaseView3.default);

exports.default = ProfileSlider;

},{"animejs":1,"zimplist/display/BaseView":258,"zimplist/input/Touch":269,"zimplist/utils/Style":274,"zimplist/utils/WindowManager":275}],239:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _flatten = require('lodash/flatten');

var _flatten2 = _interopRequireDefault(_flatten);

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _getDocumentRect = require('zimplist/display/getDocumentRect');

var _getDocumentRect2 = _interopRequireDefault(_getDocumentRect);

var _Style = require('zimplist/utils/Style');

var _Style2 = _interopRequireDefault(_Style);

var _WindowManager = require('zimplist/utils/WindowManager');

var _WindowManager2 = _interopRequireDefault(_WindowManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// Zimplist Dependencies


// Local app Dependencies


// Hidden consts
var PATH_WIDTH_RATIO = 0.36;
var WAYPOINT_HEIGHT_RATIO = 0.6; // This is used because the way points visual centers aren't the whole dimensions center
var CUTOUT_PADDING = 10;
var SCROLL_PADDING = 266 + window.innerHeight * 0.2; // 266 = height of the header
var MASK_SPEED = 750;

/**
 *
 */

var ProgressPath = function (_BaseView) {
    _inherits(ProgressPath, _BaseView);

    function ProgressPath(el, options) {
        _classCallCheck(this, ProgressPath);

        // These are the elements that define the progress paths waypoints
        var _this = _possibleConstructorReturn(this, (ProgressPath.__proto__ || Object.getPrototypeOf(ProgressPath)).call(this, el, options));

        _this.waypoints = options.waypoints;

        // cutouts are elems that mask the renderers (in reality they go back and clear zones on the renderers)
        _this.cutouts = options.cutouts;

        // create scrolling Tracker for animation
        _this.currentMaskHeight = 0;

        _this._createPathsDOM();
        _this._render();

        // After first render start listening for events to trigger animated masks
        _this.listenTo(_WindowManager2.default, 'scroll', _this._scrollHandler);

        _this.breakpointChanged();
        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(ProgressPath, [{
        key: 'breakpointChanged',
        value: function breakpointChanged(breakpoint, previousBreakpoint) {
            _get(ProgressPath.prototype.__proto__ || Object.getPrototypeOf(ProgressPath.prototype), 'breakpointChanged', this).call(this, breakpoint, previousBreakpoint);

            if (this.minWidth('s')) {
                this.currentMaskHeight = Math.max(this.currentMaskHeight, _WindowManager2.default.scrollPosition.top + _WindowManager2.default.height * 0.9);

                _Style2.default.set(this._pathContainer, {
                    height: this.currentMaskHeight, overflow: 'hidden',
                    transitionDuration: this.currentMaskHeight * MASK_SPEED

                });
            } else {
                _Style2.default.set(this._pathContainer, { height: 'auto', overflow: 'visible' });
            }
        }
    }, {
        key: 'resize',
        value: function resize() {
            this._render();
        }

        /* ==========================
          Private Methods
          ========================== */

    }, {
        key: '_createPathsDOM',
        value: function _createPathsDOM() {
            var pathContainer = document.createElement('div');
            pathContainer.className = 'progress-path-mask';

            var renderers = [];

            // Create a renderer canvas between each waypoint
            for (var i = 0; i < this.waypoints.length - 1; i++) {
                var pathRenderer = document.createElement('canvas');
                pathContainer.appendChild(pathRenderer);
                renderers.push(pathRenderer);
            }

            // Save DOM references
            this._pathContainer = pathContainer;
            this._pathRenderers = renderers;

            this.el.appendChild(this._pathContainer);
        }
    }, {
        key: '_render',
        value: function _render() {
            var _this2 = this;

            var rootElOffset = (0, _getDocumentRect2.default)(this.el).top;

            // get offsets for all the waypoints
            var waypointOffsets = this.waypoints.map(function (waypoint) {
                return (0, _getDocumentRect2.default)(waypoint);
            });

            // Get displayed client rects from cutouts
            var cutoutRects = this.cutouts.map(function (cutout) {
                // console.log('cutout: ', cutout);
                return Array.from(cutout.getClientRects()).map(function (rect) {
                    return {
                        top: rect.top + _WindowManager2.default.scrollPosition.top - CUTOUT_PADDING,
                        left: rect.left + _WindowManager2.default.scrollPosition.left - CUTOUT_PADDING,
                        width: rect.width + 2 * CUTOUT_PADDING,
                        height: rect.height + 2 * CUTOUT_PADDING
                    };
                });
            });

            // flatten array for simple looping
            cutoutRects = (0, _flatten2.default)(cutoutRects);

            var _loop = function _loop(i) {
                var renderer = _this2._pathRenderers[i];
                var currentWaypoint = waypointOffsets[i];
                var nextWaypoint = waypointOffsets[i + 1];

                // Renderers have alternating directions
                var direction = i % 2 === 0 ? -1 : 1;

                // Get dimensions and position for new renderer
                var rendererHeight = nextWaypoint.top - currentWaypoint.top - currentWaypoint.height * WAYPOINT_HEIGHT_RATIO;
                var rendererWidth = rendererHeight * PATH_WIDTH_RATIO;
                var rendererLeft = direction > 0 ? (_WindowManager2.default.width + currentWaypoint.width) / 2 : _WindowManager2.default.width / 2 - (rendererWidth + currentWaypoint.width / 2);
                var rendererTop = currentWaypoint.top + currentWaypoint.height;

                // Set dimensions as CSS values and properties (canvas needs property to size properly)
                _Style2.default.set(renderer, {
                    width: rendererWidth,
                    height: rendererHeight,
                    top: rendererTop - rootElOffset,
                    left: rendererLeft
                });
                renderer.width = rendererWidth;
                renderer.height = rendererHeight;

                // Draw dashed line along path
                var ctx = renderer.getContext('2d');
                ctx.clearRect(0, 0, rendererWidth, rendererHeight);
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(0,0,0,0.65)';
                ctx.setLineDash(_this2.minWidth('s') ? [7, 10] : [4, 8]); // smaller dashes on mobile
                if (direction > 0) {
                    ctx.moveTo(0, 0);
                    ctx.bezierCurveTo(rendererWidth * 1.25, rendererHeight * 0.25, rendererWidth * 1.25, rendererHeight * 0.75, 0, rendererHeight);
                } else {
                    ctx.moveTo(rendererWidth, 0);
                    ctx.bezierCurveTo(rendererWidth - rendererWidth * 1.25, rendererHeight * 0.25, rendererWidth - rendererWidth * 1.25, rendererHeight * 0.75, rendererWidth, rendererHeight);
                }
                ctx.stroke();

                // Intersect with cutouts to hide/clear parts of the renderer
                cutoutRects.forEach(function (cutout) {

                    var aX = Math.max(cutout.left, rendererLeft);
                    var aY = Math.max(cutout.top, rendererTop);

                    var bX = Math.min(cutout.left + cutout.width, rendererLeft + rendererWidth);
                    var bY = Math.min(cutout.top + cutout.height, rendererTop + rendererHeight);

                    // If cutout and renderer intersect, clear the intersecting part from the renderer
                    if (!(aX >= bX || aY >= bY)) {
                        ctx.clearRect(cutout.left - rendererLeft, cutout.top - rendererTop, cutout.width, cutout.height);
                    }
                });
            };

            for (var i = 0; i < this._pathRenderers.length; i++) {
                _loop(i);
            }
        }

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_scrollHandler',
        value: function _scrollHandler() {

            // Update mask height
            if (this.minWidth('s')) {
                var newMaskHeight = Math.max(this.currentMaskHeight, _WindowManager2.default.scrollPosition.top + _WindowManager2.default.height - SCROLL_PADDING);

                var distance = newMaskHeight - this.currentMaskHeight;

                this.currentMaskHeight = newMaskHeight;
                _Style2.default.set(this._pathContainer, {
                    height: this.currentMaskHeight
                    // transitionDuration : distance * MASK_SPEED
                });
            }
        }
    }]);

    return ProgressPath;
}(_BaseView3.default);

exports.default = ProgressPath;

},{"lodash/flatten":184,"zimplist/display/BaseView":258,"zimplist/display/getDocumentRect":266,"zimplist/utils/Style":274,"zimplist/utils/WindowManager":275}],240:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _forEach = require('lodash/forEach');

var _forEach2 = _interopRequireDefault(_forEach);

var _defaults = require('lodash/defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// UZIK Depedencies


// Local app Dependencies


// Hidden consts


/*

 STATIC API MANIPULATION

 */
var YOUTUBE_API_URL = "https://www.youtube.com/iframe_api";
var loadingScript = void 0;
var queuedInstances = [];

function loadAPI(instance) {

    // queue the player instance
    queuedInstances.push(instance);

    // create the call back for the API. name specified by YT API docs
    window.onYouTubeIframeAPIReady = function () {
        console.log('YT: ', window.YT);
        // call create player on all queued instances
        while (queuedInstances.length > 0) {
            var inst = queuedInstances.shift();
            if (inst.options.autoLoad) {
                inst._createPlayer.call(inst);
            }
        }
    };

    // load API (once)
    if (!loadingScript) {

        // create script
        loadingScript = document.createElement('script');

        var firstScript = document.getElementsByTagName('script')[0];
        firstScript.parentNode.insertBefore(loadingScript, firstScript);

        loadingScript.async = false;
        loadingScript.src = YOUTUBE_API_URL;
    }
}

var defaultOptions = {
    autoLoad: true
};

/**
 *
 */

var YoutubePlayer = function (_BaseView) {
    _inherits(YoutubePlayer, _BaseView);

    function YoutubePlayer(el, options) {
        _classCallCheck(this, YoutubePlayer);

        var _this = _possibleConstructorReturn(this, (YoutubePlayer.__proto__ || Object.getPrototypeOf(YoutubePlayer)).call(this, el, (0, _defaults2.default)(options, defaultOptions)));

        _this.videoId = 'videoId' in options ? options.videoId : _this.el.getAttribute('data-video-id');

        _this.playerContainer = _this.el.querySelector('.player-container');

        if (!_this.playerContainer) {
            _this.playerContainer = document.createElement('div');
            _this.playerContainer.className = 'player-container';
            _this.el.appendChild(_this.playerContainer);
        }

        // If API has already loaded, create the player imeadiatly otherwise, queue it
        if (window.YT && _this.options.autoLoad) {
            _this._createPlayer();
        } else {
            loadAPI(_this);
        }

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(YoutubePlayer, [{
        key: 'breakpointChanged',
        value: function breakpointChanged(breakpoint, previousBreakpoint) {}
    }, {
        key: 'play',
        value: function play() {
            if (this._player) {
                if (this._playerReady) {
                    this._player.playVideo();
                } else {
                    this._playbackRequsted = true;
                }
            } else {
                this._playbackRequsted = true;
                this._createPlayer();
            }
        }
    }, {
        key: 'pause',
        value: function pause() {
            if (this._player) {
                this._player.pauseVideo();
            }
        }
    }, {
        key: 'stop',
        value: function stop() {
            if (this._player) {
                this._player.stopVideo();
            }
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this._player.destroy();
            _get(YoutubePlayer.prototype.__proto__ || Object.getPrototypeOf(YoutubePlayer.prototype), 'destroy', this).call(this);
        }

        /* ==========================
          Private Methods
          ========================== */

    }, {
        key: '_createPlayer',
        value: function _createPlayer() {
            this._player = new YT.Player(this.playerContainer, {
                width: '100%',
                height: '100%',
                videoId: this.videoId,
                playerVars: {
                    modestbranding: false,
                    rel: false, // display related videos at the end of the video
                    showinfo: false,
                    theme: 'light',
                    origin: window.location.domain
                },
                events: {
                    onReady: this._playerReadyHandler.bind(this),
                    onStateChange: this._playerStateChangeHandler.bind(this)
                }
            });

            // check if this is an autoload video. In case it isn't trigger a loading event anyway to get an immediate UI response for the user
            if (!this.options.autoLoad) {
                this._updateState(YoutubePlayer.STATE.LOADING);
            }

            if (this.options.autoPlay) {
                this.play();
            }
        }
    }, {
        key: '_updateState',
        value: function _updateState(newState) {
            var _this2 = this;

            // change class name
            var stateClass = 'state-' + newState;

            // update classes
            (0, _forEach2.default)(YoutubePlayer.STATE, function (state) {
                if (state !== newState) {
                    _this2.el.classList.remove('state-' + state);
                }
            });

            this.el.classList.add(stateClass);

            // update internal var
            this.state = newState;

            // trigger event for state
            this.trigger(newState);
        }

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_playerReadyHandler',
        value: function _playerReadyHandler(event) {
            // re assign var because it has been replaced by the YT iFrame
            this.playerContainer = this.el.querySelector('.player-container');

            this._playerReady = true;

            // if the player was loaded when trying to play the video, it gets played here
            if (this._playbackRequsted) {
                this._player.playVideo();
                this._playbackRequsted = false;
            }

            this.trigger('ready');
        }
    }, {
        key: '_playerStateChangeHandler',
        value: function _playerStateChangeHandler(event) {

            switch (event.data) {
                case YT.PlayerState.PLAYING:

                    /* if (Vichy.Config.env == 'dev') {
                         this._player.mute();
                     }
                      this._startTimeMonitor();*/

                    this._updateState(YoutubePlayer.STATE.PLAYING);
                    break;

                case YT.PlayerState.BUFFERING:
                    //this.showPlayer();
                    // this._stopTimeMonitor();
                    this._updateState(YoutubePlayer.STATE.LOADING);
                    break;

                case YT.PlayerState.PAUSED:
                    // this._stopTimeMonitor();
                    this._updateState(YoutubePlayer.STATE.PAUSED);
                    break;

                case YT.PlayerState.ENDED:
                    // this._stopTimeMonitor();
                    this._updateState(YoutubePlayer.STATE.ENDED);
                    break;
            }
        }
    }]);

    return YoutubePlayer;
}(_BaseView3.default);

YoutubePlayer.STATE = {
    PENDING: 'pending',
    LOADING: 'loading',
    PLAYING: 'playing',
    PAUSED: 'paused',
    ENDED: 'ended'
};

exports.default = YoutubePlayer;

},{"lodash/defaults":174,"lodash/forEach":185,"zimplist/display/BaseView":258}],241:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _color = require('color');

var _color2 = _interopRequireDefault(_color);

var _animejs = require('animejs');

var _animejs2 = _interopRequireDefault(_animejs);

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _Point = require('zimplist/geometry/Point');

var _Point2 = _interopRequireDefault(_Point);

var _Style = require('zimplist/utils/Style');

var _Style2 = _interopRequireDefault(_Style);

var _index = require('zimplist/display/dom/index');

var _index2 = _interopRequireDefault(_index);

var _empty = require('zimplist/display/dom/empty');

var _empty2 = _interopRequireDefault(_empty);

var _SpriteAnimator = require('zimplist/display/animation/SpriteAnimator');

var _SpriteAnimator2 = _interopRequireDefault(_SpriteAnimator);

var _renderBackground2 = require('app/components/values-wheel/renderBackground');

var _renderBackground3 = _interopRequireDefault(_renderBackground2);

var _generatePoints = require('app/components/values-wheel/generatePoints');

var _generatePoints2 = _interopRequireDefault(_generatePoints);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// Zimplist Depedencies


// Local app Dependencies


// Hidden consts
var WHEEL_RADIUS = 250;
var INTRO_DELAY = 260;

/**
 *
 */

var ValuesWheel = function (_BaseView) {
    _inherits(ValuesWheel, _BaseView);

    function ValuesWheel(el, options) {
        _classCallCheck(this, ValuesWheel);

        // Canvases
        var _this = _possibleConstructorReturn(this, (ValuesWheel.__proto__ || Object.getPrototypeOf(ValuesWheel)).call(this, el, options));

        _this.bgRenderer = _this.el.querySelector('.bg-renderer');
        _this.lineRenderer = _this.el.querySelector('.line-renderer');

        _this.valueItems = Array.from(_this.el.querySelectorAll('.values-wheel-large .value-item'));
        _this.colors = _this.valueItems.map(function (label) {
            return label.getAttribute('data-color');
        });

        _this.textContainer = _this.el.querySelector('.values-wheel-large .value-text-container');

        /**
         * An array of 0-2 values containing selected values (represented by their DOM nodes)
         * @type {Array}
         */
        _this.activeValues = [];

        // object with a normalized number for every value representing the lines progress
        _this.lineProgress = {};

        _this.valueItems.map(function (value) {
            return value.getAttribute('data-value-id');
        }).forEach(function (valueId) {
            return _this.lineProgress[valueId] = 0;
        });

        _this.currentMessage = _this.el.querySelector('.values-wheel-large .value-text-container .message');

        // Setup points on the circle
        /*let stepRad = (Math.PI * 2) / this.valueItems.length;
        let quaterRad = (Math.PI * 2) / 4;
         this.wheelPoints = this.valueItems.map( (step, i) => {
            let angle = (stepRad * i) - quaterRad;
            let x = WHEEL_RADIUS * Math.cos( angle ) + WHEEL_RADIUS;
            let y = WHEEL_RADIUS * Math.sin( angle ) + WHEEL_RADIUS;
            return new Point( x, y, angle, WHEEL_RADIUS );
        });*/

        _this.wheelPoints = (0, _generatePoints2.default)(_this.valueItems.length, WHEEL_RADIUS);

        _this.labelSprites = _this.valueItems.map(function (value) {
            var spriteCanvas = value.querySelector('.sprite');
            return new _SpriteAnimator2.default(spriteCanvas, { fps: 25, autoplay: false, loop: false, numFrames: 36, url: spriteCanvas.getAttribute('data-src') });
        });

        // Setup DOM events
        _this.addDomEvent('click', _this._valueItemClickHandler, '.value-item');

        _this._renderBackground();

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(ValuesWheel, [{
        key: 'introAnimation',
        value: function introAnimation() {
            var _this2 = this;

            // TODO Add sprite mask

            setTimeout(function () {
                _this2.bgRenderer.classList.remove('hidden');
                var firstHint = _this2.textContainer.querySelector('.message:first-child');

                // remove first hint
                (0, _animejs2.default)({
                    targets: firstHint,
                    opacity: [0, 1],
                    easing: 'easeInCubic',
                    duration: 1000
                });
            }, INTRO_DELAY);

            this.valueItems.forEach(function (label, i) {
                setTimeout(function () {
                    label.classList.remove('hidden');
                }, (i + 1) * 120 + INTRO_DELAY);
            });
        }

        /* ==========================
          Private Methods
          ========================== */

    }, {
        key: '_renderBackground',
        value: function _renderBackground() {
            var _this3 = this;

            // Draw background
            var ctx = this.bgRenderer.getContext('2d');

            (0, _renderBackground3.default)(ctx, this.colors, this.wheelPoints, WHEEL_RADIUS);

            /*// Create mask
            ctx.clearRect(0, 0, 2 * WHEEL_RADIUS, 2 * WHEEL_RADIUS);
            ctx.beginPath();
            ctx.arc( WHEEL_RADIUS, WHEEL_RADIUS, WHEEL_RADIUS, 0, Math.PI *2, false );
            ctx.clip();
            ctx.globalCompositeOperation = 'screen';
             // create gradients for the colors
            this.colors.forEach( (color, i) => {
                 let x = this.wheelPoints[i].x;
                let y = this.wheelPoints[i].y;
                 let gradient = ctx.createRadialGradient(x, y, 0, x, y, WHEEL_RADIUS );
                gradient.addColorStop(0, color );
                gradient.addColorStop(1, Color(color).fade(1) );
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, WHEEL_RADIUS * 2, WHEEL_RADIUS * 2);
             });
              // Last white gradient in center
            ctx.globalCompositeOperation = 'source-over';
            let whiteGradient = ctx.createRadialGradient(WHEEL_RADIUS, WHEEL_RADIUS, 0, WHEEL_RADIUS, WHEEL_RADIUS, WHEEL_RADIUS);
             whiteGradient.addColorStop(0, 'rgba(255, 255, 255, 0.15');
            whiteGradient.addColorStop(1, 'rgba(255, 255, 255, 0');
             ctx.fillStyle = whiteGradient;
            ctx.fillRect(0, 0, WHEEL_RADIUS * 2, WHEEL_RADIUS * 2);*/

            // Position Labels
            this.valueItems.forEach(function (label, i) {
                var point = _this3.wheelPoints[i];

                _Style2.default.set(label, {
                    top: point.y,
                    left: point.x
                });
            });
        }
    }, {
        key: '_renderLines',
        value: function _renderLines() {
            var _this4 = this;

            var ctx = this.lineRenderer.getContext('2d');

            // Clear canvas
            ctx.clearRect(0, 0, WHEEL_RADIUS * 2, WHEEL_RADIUS * 2);

            this.activeValues.forEach(function (value) {

                // get other elements tied to the value
                var valueId = value.getAttribute('data-value-id');
                var valueIndex = _this4.valueItems.indexOf(value);
                var valuePoint = _this4.wheelPoints[valueIndex];

                // Setup stroke style
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(0,0,0,0.65)';
                ctx.setLineDash([7, 10]);

                // Special case is points 0 and 3 which are straight lines
                if (valueIndex === 0 || valueIndex === 3) {

                    var wheelPoint = _this4.wheelPoints[valueIndex];

                    var endX = WHEEL_RADIUS;
                    var endY = WHEEL_RADIUS + (wheelPoint.y - WHEEL_RADIUS) * (1 - _this4.lineProgress[valueId]);

                    ctx.moveTo(wheelPoint.x, wheelPoint.y);
                    ctx.lineTo(endX, endY);
                } else {
                    // Get adjacent point to build circle with
                    var adjacentPoint = void 0;

                    // direction of the arc depending on which point is being clicked
                    var arcClockwise = void 0;

                    switch (valueIndex) {
                        case 1:
                            adjacentPoint = _this4.wheelPoints[valueIndex + 1];
                            arcClockwise = false;
                            break;
                        case 2:
                            adjacentPoint = _this4.wheelPoints[valueIndex - 1];
                            arcClockwise = true;
                            break;
                        case 4:
                            adjacentPoint = _this4.wheelPoints[valueIndex + 1];
                            arcClockwise = false;
                            break;
                        case 5:
                            adjacentPoint = _this4.wheelPoints[valueIndex - 1];
                            arcClockwise = true;
                            break;

                        default:
                            adjacentPoint = _this4.wheelPoints[0];
                    }

                    // Get center point of a circle via average of the three points
                    // create point objects for the triangle
                    var centerPoint = new _Point2.default((WHEEL_RADIUS + valuePoint.x + adjacentPoint.x) / 3, (WHEEL_RADIUS + valuePoint.y + adjacentPoint.y) / 3);
                    var _wheelPoint = new _Point2.default(WHEEL_RADIUS, WHEEL_RADIUS); //TODO move for optimization

                    // Radius of circumbscribing circle
                    var arcRadius = WHEEL_RADIUS / Math.sqrt(3);

                    // get side distances to calc the angle of the arc
                    // longest side will always be the distance between the center and the value point
                    var sideC = _Point2.default.distance(valuePoint, _wheelPoint);
                    var sideA = _Point2.default.distance(valuePoint, centerPoint);
                    var sideB = _Point2.default.distance(_wheelPoint, centerPoint);

                    // Measure obtuse angle of the triangle
                    var arcAngle = Math.acos((sideA * sideA + sideB * sideB - sideC * sideC) / (2 * sideA * sideB));
                    var stepRad = Math.PI * 2 / _this4.valueItems.length; // TODO move for optimization

                    var startAngle = void 0,
                        endAngle = void 0;

                    // let arcProgress = (this.activeValues.length === 0 || i > 0) ? arcAngle * this.lineProgress.progress : arcAngle;
                    var arcProgress = arcAngle * _this4.lineProgress[valueId];

                    switch (valueIndex) {
                        case 1:
                            startAngle = Math.PI + arcAngle; // Math.PI + (stepRad * (valueIndex - 1) );
                            endAngle = startAngle - arcProgress;
                            break;
                        case 2:
                            startAngle = Math.PI - stepRad * valueIndex;
                            endAngle = startAngle + arcProgress;
                            break;
                        case 4:
                            startAngle = stepRad * 2;
                            endAngle = startAngle - arcProgress;
                            break;
                        case 5:
                            startAngle = Math.PI - stepRad * valueIndex;
                            endAngle = startAngle + arcProgress;
                            break;
                    }

                    ctx.arc(centerPoint.x, centerPoint.y, arcRadius, startAngle, endAngle, !arcClockwise);
                }

                ctx.stroke();
                ctx.closePath();
            });

            // cutout current message
            // TODO line by line clear
            ctx.clearRect(this.currentMessage.offsetLeft, this.currentMessage.offsetTop, this.currentMessage.offsetWidth, this.currentMessage.offsetHeight);
        }

        /**
         *
         * @param {DOMElement} value - Value element.
         * @private
         */

    }, {
        key: '_activateValue',
        value: function _activateValue(value) {
            // console.log('activate value');
            if (this.activeValues.length === 2) {
                // disable first
                this._deactivateValue(this.activeValues[0]);
            }

            // remove hints
            var valueIndex = (0, _index2.default)(value);

            var button = value.querySelector('button');
            var buttonBg = button.querySelector('.background');

            value.classList.add('active');
            _Style2.default.set(buttonBg, { backgroundColor: this.colors[valueIndex] });

            // Add to Selected values
            this.activeValues.push(value);

            var labelSprite = this.labelSprites[valueIndex];
            labelSprite.el.style.opacity = 1;
            labelSprite.play();

            this._updateTextContent();
        }
    }, {
        key: '_deactivateValue',
        value: function _deactivateValue(value) {
            // remove form list of active values
            var valueIndex = (0, _index2.default)(value);
            var valueId = value.getAttribute('data-value-id');
            var button = value.querySelector('button');
            var buttonBg = button.querySelector('.background');

            this.activeValues.splice(this.activeValues.indexOf(value), 1);
            value.classList.remove('active');
            _Style2.default.set(buttonBg, { backgroundColor: null });

            // remove dotted line
            this.lineProgress[valueId] = 0;

            // remove butterflies label sprite
            (0, _animejs2.default)({
                targets: this.labelSprites[valueIndex].el,
                duration: 1000,
                opacity: 0
            });

            this._updateTextContent();
        }
    }, {
        key: '_removeCurrentMessage',
        value: function _removeCurrentMessage(callback) {

            if (this.currentMessage) {
                (0, _animejs2.default)({
                    targets: this.currentMessage,
                    opacity: 0,
                    duration: 500,
                    easing: 'easeOutCubic',
                    complete: function complete() {
                        callback();
                    }
                });
            } else {
                callback();
            }
        }

        /**
         * Update the text content for active value(s)
         * @private
         */

    }, {
        key: '_updateTextContent',
        value: function _updateTextContent() {
            var _this5 = this;

            // get id from pair of attributes
            var valueId = void 0;

            if (this.activeValues.length === 1) {
                valueId = this.activeValues[0].getAttribute('data-value-id');
            } else if (this.activeValues.length === 2) {

                var valueA = this.activeValues[0];
                var valueB = this.activeValues[1];

                var indexA = (0, _index2.default)(valueA);
                var indexB = (0, _index2.default)(valueB);

                // get pair of id's as a single id "idA-idB". The order is determined by the DOM, not alphabetically
                valueId = indexA < indexB ? valueA.getAttribute('data-value-id') + '-' + valueB.getAttribute('data-value-id') : valueB.getAttribute('data-value-id') + '-' + valueA.getAttribute('data-value-id');

                // get number of points between points
                // let distance = Math.abs( indexA - indexB );
                // let shortDistance = Math.min( distance, this.valueItems.length - distance);

            } else {
                // Empty the block
                this.lineRenderer.getContext('2d').clearRect(0, 0, WHEEL_RADIUS * 2, WHEEL_RADIUS * 2);
            }

            // If we have found an element
            if (valueId) {

                // Get clone of element
                var messageEl = this.el.querySelector('.value-message-library .value-message[data-value-id="' + valueId + '"]').cloneNode(true);

                this._removeCurrentMessage(function () {
                    (0, _empty2.default)(_this5.textContainer);

                    // Save current message element
                    _this5.currentMessage = messageEl;

                    messageEl.style.opacity = 0;
                    (0, _animejs2.default)({
                        targets: messageEl,
                        opacity: [0, 1],
                        duration: 350,
                        easing: 'easeInCubic'
                    });

                    _this5.textContainer.appendChild(messageEl);
                });

                // multple lines to animate?
                valueId.split('-').forEach(function (valueProp) {

                    var currentValue = _this5.lineProgress[valueProp];

                    // don't reanimate complete lines
                    if (currentValue < 1) {
                        // set basic props
                        var animProps = {
                            targets: _this5.lineProgress,
                            duration: 1400,
                            easing: 'easeInOutCirc',
                            update: function update() {
                                _this5._renderLines();
                            }
                        };

                        // dynamic property creation for this value
                        animProps[valueProp] = [currentValue, 1];

                        // start anim
                        (0, _animejs2.default)(animProps);
                    }
                });
            }

            // Draw lines to bloc
            this._renderLines();
        }

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_valueItemClickHandler',
        value: function _valueItemClickHandler(event) {

            if (event.delegateTarget.classList.contains('active')) {
                this._deactivateValue(event.delegateTarget);
            } else {
                this._activateValue(event.delegateTarget);
            }
        }
    }]);

    return ValuesWheel;
}(_BaseView3.default);

exports.default = ValuesWheel;

},{"animejs":1,"app/components/values-wheel/generatePoints":243,"app/components/values-wheel/renderBackground":244,"color":7,"zimplist/display/BaseView":258,"zimplist/display/animation/SpriteAnimator":260,"zimplist/display/dom/empty":261,"zimplist/display/dom/index":263,"zimplist/geometry/Point":267,"zimplist/utils/Style":274}],242:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _animejs = require('animejs');

var _animejs2 = _interopRequireDefault(_animejs);

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _Style = require('zimplist/utils/Style');

var _Style2 = _interopRequireDefault(_Style);

var _Point = require('zimplist/geometry/Point');

var _Point2 = _interopRequireDefault(_Point);

var _index = require('zimplist/display/dom/index');

var _index2 = _interopRequireDefault(_index);

var _empty = require('zimplist/display/dom/empty');

var _empty2 = _interopRequireDefault(_empty);

var _removeClasses = require('zimplist/display/dom/removeClasses');

var _removeClasses2 = _interopRequireDefault(_removeClasses);

var _renderBackground2 = require('./renderBackground');

var _renderBackground3 = _interopRequireDefault(_renderBackground2);

var _generatePoints = require('./generatePoints');

var _generatePoints2 = _interopRequireDefault(_generatePoints);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// UZIK Depedencies


// Local app Dependencies


// Hidden consts
var WHEEL_RADIUS = 170; // Must match value in SCSS
var WHEEL_POINT_ANGLE = 45 * (Math.PI / 180);

/**
 *
 */

var ValuesWheelSmall = function (_BaseView) {
    _inherits(ValuesWheelSmall, _BaseView);

    function ValuesWheelSmall(el, options) {
        _classCallCheck(this, ValuesWheelSmall);

        // this.addDomEvent('click', this._childClickHandler);
        var _this = _possibleConstructorReturn(this, (ValuesWheelSmall.__proto__ || Object.getPrototypeOf(ValuesWheelSmall)).call(this, el, options));

        _this.addDomEvent('click', _this._itemClickHandler, '.values-wheel-small .value-item');

        // Get refence to the original value list and hide it
        _this.valueList = _this.el.querySelector('.values-list');
        _this.valueElements = Array.from(_this.valueList.querySelectorAll('.value-item'));

        _this.valueListA = _this.valueList.cloneNode(true);
        _this.valueListB = _this.valueList.cloneNode(true);

        // Hide list after cloning it
        _Style2.default.set(_this.valueList, { display: 'none' });

        _this.wheelContainerA = _this.el.querySelector('.wheel-container-small:first-child');
        _this.wheelContainerB = _this.el.querySelector('.wheel-container-small:last-child');

        // Get backgrounds
        _this.backgroundA = _this.el.querySelector('.wheel-container-small:first-child .bg-renderer-small');
        _this.backgroundB = _this.el.querySelector('.wheel-container-small:last-child .bg-renderer-small');

        _this.wheelContainerA.appendChild(_this.valueListA);
        _this.wheelContainerB.appendChild(_this.valueListB);

        _this.selectedValueA = 0;
        _this.selectedValueB = 0;

        _this._activeValues = {
            a: null,
            b: null
        };

        _this.textContainer = _this.el.querySelector('.value-text-container.small');

        // Get values
        // this.values = {};

        /*this.valueElementsA.forEach( (value, i) => {
            let id      = value.getAttribute('data-value-id');
            let color   = value.getAttribute('data-color');
             this.values[ id ] = {
                el : value,
                color: color,
                index : i
            };
        });*/

        // get an array of colors from each point
        _this.colors = _this.valueElements.map(function (el) {
            return el.getAttribute('data-color');
        });

        // create wheel points
        // this.wheelPoints = generatePoints( this.valueElements.length, WHEEL_RADIUS, 30 );

        _this.wheelPoints = [];

        var firstPointOffset = 0 - Math.floor(5 / 2) * WHEEL_POINT_ANGLE;
        for (var i = 0; i < _this.valueElements.length; i++) {

            // get offset for
            var angle = firstPointOffset + i * WHEEL_POINT_ANGLE;
            var x = WHEEL_RADIUS + Math.cos(angle) * WHEEL_RADIUS;
            var y = WHEEL_RADIUS + Math.sin(angle) * WHEEL_RADIUS;

            _this.wheelPoints.push(new _Point2.default(x, y, angle, WHEEL_RADIUS));
        }

        _this._renderBackground();

        _this._positionLabels();
        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */


    _createClass(ValuesWheelSmall, [{
        key: 'introAnimation',
        value: function introAnimation() {

            Array.from(this.valueListA.querySelectorAll('.value-item.hidden')).forEach(function (item) {
                return item.classList.remove('hidden');
            });
            Array.from(this.valueListB.querySelectorAll('.value-item.hidden')).forEach(function (item) {
                return item.classList.remove('hidden');
            });
        }

        /* ==========================
          Private Methods
          ========================== */

    }, {
        key: '_activateValue',
        value: function _activateValue(valueIndex) {
            var group = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'a';


            this['selectedValue' + group.toUpperCase()] = valueIndex;

            this._activeValues[group] = valueIndex;

            this['valueList' + group.toUpperCase()].children[valueIndex].classList.add('active');
        }
    }, {
        key: '_deactivateValue',
        value: function _deactivateValue(valueIndex) {
            var group = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'a';

            this._activeValues[group] = null;

            this['valueList' + group.toUpperCase()].children[valueIndex].classList.remove('active');

            // this._positionLabels();
            // this._updateTextContent();
        }
    }, {
        key: '_positionLabels',
        value: function _positionLabels() {
            var _this2 = this;

            /*
             A
              */

            var orderedValuesA = [];
            var orderIndexA = 2 - this.selectedValueA; // 5/2
            orderIndexA = orderIndexA < 0 ? orderIndexA + this.valueElements.length : orderIndexA;

            var labelsA = Array.from(this.valueListA.querySelectorAll('.value-item'));

            for (var i = 0; i < labelsA.length; i++) {
                var currentLabel = labelsA[i];

                // TODO refactor with same code below
                (0, _removeClasses2.default)(currentLabel, 'state-*');
                if (orderIndexA === 2) {
                    currentLabel.classList.add('state-selected');
                } else if (!(orderIndexA === 1 || orderIndexA === 3)) {
                    currentLabel.classList.add('state-off');
                }

                orderedValuesA[orderIndexA++] = currentLabel;
                orderIndexA = orderIndexA < labelsA.length ? orderIndexA : 0;
            }

            orderedValuesA.forEach(function (item, i) {
                _Style2.default.set(item, {
                    top: _this2.wheelPoints[i].y,
                    left: _this2.wheelPoints[i].x
                });
            });

            /*
             B
              */
            var orderedValuesB = [];
            var orderIndexB = 2 - this.selectedValueB; // 5/2
            orderIndexB = orderIndexB < 0 ? orderIndexB + this.valueElements.length : orderIndexB;

            var labelsB = Array.from(this.valueListB.querySelectorAll('.value-item'));

            for (var _i = 0; _i < labelsB.length; _i++) {
                var _currentLabel = labelsB[_i];

                // TODO refactor with same code above
                (0, _removeClasses2.default)(_currentLabel, 'state-*');
                if (orderIndexB === 2) {
                    _currentLabel.classList.add('state-selected');
                } else if (!(orderIndexB === 1 || orderIndexB === 3)) {
                    _currentLabel.classList.add('state-off');
                }

                orderedValuesB[orderIndexB++] = _currentLabel;
                orderIndexB = orderIndexB < labelsB.length ? orderIndexB : 0;
            }

            orderedValuesB.forEach(function (item, i) {

                var x = _this2.wheelPoints[i].x;
                var y = _this2.wheelPoints[i].y;

                x = WHEEL_RADIUS - (x - WHEEL_RADIUS);

                _Style2.default.set(item, {
                    top: y,
                    left: x
                });
            });
        }
    }, {
        key: '_removeCurrentMessage',
        value: function _removeCurrentMessage(callback) {

            if (this.currentMessage) {
                (0, _animejs2.default)({
                    targets: this.currentMessage,
                    opacity: 0,
                    duration: 500,
                    easing: 'easeOutCubic',
                    complete: function complete() {
                        callback();
                    }
                });
            } else {
                callback();
            }
        }
    }, {
        key: '_updateTextContent',
        value: function _updateTextContent() {
            var _this3 = this;

            // value id will be either single id or combination
            var valueId = void 0;

            // get selected values
            if (this._activeValues.a !== null) {

                if (this._activeValues.b !== null && this._activeValues.a !== this._activeValues.b) {
                    var indexA = this._activeValues.a;
                    var indexB = this._activeValues.b;

                    var valueA = this.valueElements[indexA].getAttribute('data-value-id');
                    var valueB = this.valueElements[indexB].getAttribute('data-value-id');

                    valueId = indexA < indexB ? valueA + '-' + valueB : valueB + '-' + valueA;
                } else {
                    valueId = this.valueElements[this._activeValues.a].getAttribute('data-value-id');
                }
            }

            // Get message for this values
            var messageEl = this.el.querySelector('.value-message-library .value-message[data-value-id="' + valueId + '"]').cloneNode(true);

            if (messageEl) {
                this._removeCurrentMessage(function () {
                    (0, _empty2.default)(_this3.textContainer);

                    // Save current message element
                    _this3.currentMessage = messageEl;

                    messageEl.style.opacity = 0;
                    (0, _animejs2.default)({
                        targets: messageEl,
                        opacity: [0, 1],
                        duration: 350,
                        easing: 'easeInCubic'
                    });

                    _this3.textContainer.appendChild(messageEl);
                });
            }
        }
    }, {
        key: '_renderBackground',
        value: function _renderBackground() {

            (0, _renderBackground3.default)(this.backgroundA.getContext('2d'), this.colors, this.wheelPoints, WHEEL_RADIUS);
            (0, _renderBackground3.default)(this.backgroundB.getContext('2d'), this.colors, this.wheelPoints, WHEEL_RADIUS);
        }

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_childClickHandler',
        value: function _childClickHandler(event) {
            this.selectedValueA++;

            if (this.selectedValueA >= this.valueElements.length) {
                this.selectedValueA = 0;
            }

            this.selectedValueB++;

            if (this.selectedValueB >= this.valueElements.length) {
                this.selectedValueB = 0;
            }

            this._positionLabels();
        }
    }, {
        key: '_itemClickHandler',
        value: function _itemClickHandler(event) {

            var itemGroup = this.valueListA.contains(event.delegateTarget) ? 'a' : 'b';
            var itemId = event.delegateTarget.getAttribute('data-value-id');
            var itemIndex = (0, _index2.default)(event.delegateTarget);

            // TODO check disabled items

            // We can't disable A, otherwise nothing will be displayed
            /*if (this._activeValues[itemGroup] !== null && this._activeValues[itemGroup] === itemIndex) {
                this._deactivateValue(itemIndex, itemGroup);
            } else */if (this._activeValues[itemGroup] !== null) {
                this._deactivateValue(this._activeValues[itemGroup], itemGroup);
            }

            this._activateValue(itemIndex, itemGroup);

            this._positionLabels();
            this._updateTextContent();
        }
    }]);

    return ValuesWheelSmall;
}(_BaseView3.default);

exports.default = ValuesWheelSmall;

},{"./generatePoints":243,"./renderBackground":244,"animejs":1,"zimplist/display/BaseView":258,"zimplist/display/dom/empty":261,"zimplist/display/dom/index":263,"zimplist/display/dom/removeClasses":264,"zimplist/geometry/Point":267,"zimplist/utils/Style":274}],243:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Point = require('zimplist/geometry/Point');

var _Point2 = _interopRequireDefault(_Point);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function generatePoints(length, radius) {

    var stepRad = Math.PI * 2 / length;
    var quaterRad = Math.PI * 2 / 4;

    var points = [];

    for (var i = 0; i < length; i++) {
        var angle = stepRad * i - quaterRad;
        var x = radius * Math.cos(angle) + radius;
        var y = radius * Math.sin(angle) + radius;

        points.push(new _Point2.default(x, y, angle, radius));
    }

    return points;
}

exports.default = generatePoints;

},{"zimplist/geometry/Point":267}],244:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _color = require('color');

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function renderBackground(ctx, colors, wheelPoints, radius) {

    // Create mask
    ctx.clearRect(0, 0, 2 * radius, 2 * radius);
    ctx.beginPath();
    ctx.arc(radius, radius, radius, 0, Math.PI * 2, false);
    ctx.clip();
    ctx.globalCompositeOperation = 'screen';

    // create gradients for the colors
    colors.forEach(function (color, i) {

        var wheelPoint = wheelPoints[i];

        var x = wheelPoint.x;
        var y = wheelPoint.y;

        var gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, (0, _color2.default)(color).fade(1));
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, radius * 2, radius * 2);
    });

    // Last white gradient in center
    ctx.globalCompositeOperation = 'source-over';
    var whiteGradient = ctx.createRadialGradient(radius, radius, 0, radius, radius, radius);

    whiteGradient.addColorStop(0, 'rgba(255, 255, 255, 0.15');
    whiteGradient.addColorStop(1, 'rgba(255, 255, 255, 0');

    ctx.fillStyle = whiteGradient;
    ctx.fillRect(0, 0, radius * 2, radius * 2);
}

exports.default = renderBackground;

},{"color":7}],245:[function(require,module,exports){
"use strict";

var _fontfaceobserver = require("fontfaceobserver");

var _fontfaceobserver2 = _interopRequireDefault(_fontfaceobserver);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _WindowManager = require("zimplist/utils/WindowManager");

var _WindowManager2 = _interopRequireDefault(_WindowManager);

var _Config = require("zimplist/utils/Config");

var _Config2 = _interopRequireDefault(_Config);

var _stringToElement = require("zimplist/display/dom/stringToElement");

var _stringToElement2 = _interopRequireDefault(_stringToElement);

var _pageList = require("app/pages/pageList");

var _pageList2 = _interopRequireDefault(_pageList);

var _PageDraw = require("app/ui/PageDraw");

var _PageDraw2 = _interopRequireDefault(_PageDraw);

var _Header = require("app/ui/Header");

var _Header2 = _interopRequireDefault(_Header);

var _Footer = require("app/ui/Footer");

var _Footer2 = _interopRequireDefault(_Footer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Create main object
var VCA = {
    start: function start() {

        // Init global config with page data
        var bootstrapConfig = window.VCA_CONFIG;

        if (!bootstrapConfig) {
            console.warn('No bootstrap config provided');
        } else {
            _Config2.default.initialize(bootstrapConfig);
        }

        // Setup WindowManager
        _WindowManager2.default.initialize({
            breakpoints: [{ name: 'xxs', value: 0 }, // needs to be 0 to avoid screwing up the detection
            { name: 'xs', value: 550 }, { name: 's', value: 750 }, { name: 'm', value: 980 }, { name: 'l', value: 1200 }, { name: 'xl', value: 1400 }, { name: 'xxl', value: 1600 }]
        });

        // Setup font-face observer
        this.initFontFaceObservers();

        // Load SVG Sprite
        this.initSVGSprite();

        // Init static ui elements
        this.header = new _Header2.default(document.getElementById('site-header'));

        this.footer = new _Footer2.default(document.getElementById('site-footer'));

        this.pageDraw = new _PageDraw2.default(document.getElementById('page-draw'));

        // Initialize page in place and create new history entry
        // WARNING : make sure there are is only one '.page' loaded in the layout
        var page = this.initPage(document.querySelector('.page'));

        // console.log( window.location.href );

        window.history.replaceState({ pageId: page.id }, window.title, window.location.href);

        /*
         Setup AJAX navigation
         */
        // declare regex to detect internal links
        // TODO move to config?
        this.loadableRegex = new RegExp("(^/|" + window.location.origin + "/.*)");

        window.addEventListener('popstate', this._popstateHandler.bind(this));

        // bind link DOM events to hijack nav events
        window.document.addEventListener('click', this._globalClickHandler.bind(this));

        // Wait for load to trigger another re-render
        _WindowManager2.default.on('load', function () {
            _WindowManager2.default.trigger('resize');
        });
    },
    initFontFaceObservers: function initFontFaceObservers() {
        var fontObserverNeutrafaceSemi = new _fontfaceobserver2.default('neutrafacetext', { weight: 600 });
        var fontObserverNeutrafaceBold = new _fontfaceobserver2.default('neutrafacetext', { weight: 700 });

        var fontObserverFilosofiaRegular = new _fontfaceobserver2.default('filosofia', { weight: 400 });
        var fontObserverFilosofiaItalic = new _fontfaceobserver2.default('filosofia', { weight: 400, style: 'italic' });
        var fontObserverFilosofiaBold = new _fontfaceobserver2.default('filosofia', { weight: 700 });

        // Load all Filosofia fonts
        var filosofiaAll = Promise.all([fontObserverFilosofiaRegular.load(), fontObserverFilosofiaItalic.load(), fontObserverFilosofiaBold.load()]).then(function () {
            return document.documentElement.classList.add('font-filosofia-loaded');
        });

        // Load all Neutraface fonts
        var neutrafaceAll = Promise.all([fontObserverNeutrafaceSemi.load(), fontObserverNeutrafaceBold.load()]).then(function () {
            return document.documentElement.classList.add('font-neutraface-loaded');
        });

        // trigger window resize to force re-render when all fonts are loaded;
        Promise.all([filosofiaAll, neutrafaceAll]).then(function () {
            _WindowManager2.default.trigger('resize');
            window.sessionStorage.setItem('fontsLoaded', true); // Thi is checked directly in the layout to avoid FOUT during refreshes
        });
    },
    initSVGSprite: function initSVGSprite() {

        var svgData = window.sessionStorage.getItem('svg-sprite');
        if (svgData && svgData.length && _Config2.default.env !== 'development') {
            // Create SVG element from string and inject at the start of the body
            var svgDoc = document.createElement('div');
            svgDoc.innerHTML = svgData;
            document.body.insertBefore(svgDoc.firstChild, document.body.firstChild);
        } else {
            var svgLoader = fetch(_Config2.default.assetPath + "img/svg/icon-sprite.svg");
            svgLoader.then(function (response) {
                return response.text();
            }).then(function (responseData) {

                var tempContainer = document.createElement('div');
                tempContainer.innerHTML = responseData;

                var svgData = tempContainer.firstChild;

                // Cache SVG sprite
                window.sessionStorage.setItem('svg-sprite', responseData);

                // inject SVG
                document.body.insertBefore(svgData, document.body.firstChild);
            });
        }
    },
    loadPage: function loadPage(url) {
        var _this = this;

        // TODO replace with loader

        fetch(url, {
            credentials: 'same-origin'
        }).then(function (response) {
            // decide if we're returning JSON or string
            return response.headers.has('Content-Type') && response.headers.get('Content-Type').includes('application/json') ? response.json() : response.text();
        }).then(function (responseData) {
            var documentEl = (0, _stringToElement2.default)(responseData);

            // TODO Change page title
            var pageEl = documentEl.querySelector('.page');

            var page = _this.initPage(pageEl);

            // Set initial state in history
            window.history.pushState({ pageId: page.id }, window.title, url);
        });
    },
    initPage: function initPage(pageEl) {

        // get unique string that id's the page
        var pageId = pageEl.getAttribute('data-page-id');

        // Append page element before
        if (pageId !== 'home') {
            this.pageDraw.injectPageEl(pageEl);
        }

        // Get an instance for the class attributed for this page
        var pageObj = void 0;
        if (_pageList2.default[pageId]) {
            pageObj = new _pageList2.default[pageId](pageEl);
        } else {
            pageObj = new _pageList2.default['default'](pageEl);
            console.error("Can't find page class for id: " + pageId);
        }

        if (pageId === 'home') {
            this.currentPage = pageObj;
            this.closePageDraw();
        } else {
            this.currentDrawPage = pageObj;
            this.openPageDraw();
        }

        return pageObj;
    },
    openPageDraw: function openPageDraw() {
        // TODO pause currentPage

        this.pageDraw.open();
    },
    closePageDraw: function closePageDraw() {

        // TODO if there is no current page, redirect?

        if (this.currentDrawPage) {
            this.pageDraw.close();
            this.currentDrawPage.remove(); // TODO wait for transition to end ?
            this.currentDrawPage = null;
        }

        // TODO un-pause currentPage

        // TODO Empty the draw
    },
    _popstateHandler: function _popstateHandler(event) {

        console.log(window.location.href);

        if (event.state.pageId && event.state.pageId === 'home') {
            this.closePageDraw();
        } else {
            // TODO load page and reopen draw
            this.loadPage(window.location.href);
        }
    },
    _globalClickHandler: function _globalClickHandler(event) {
        // iterate up the DOM to find if a link was clicked
        var linkTarget = void 0;
        var domIter = event.target;
        while (domIter !== document.documentElement) {
            if (domIter && domIter.tagName && domIter.tagName.toLowerCase() === 'a') {
                linkTarget = domIter;
                break;
            } else {
                domIter = domIter.parentNode;
            }
        }

        // Check this target
        // - is a link,
        // - has a href attr
        // - the user isn't pressing any keyboard buttons to open tab in new window.
        // - doesn't have the force-reload class (like the lang select for example)
        if (linkTarget && !event.metaKey && !event.ctrlKey && linkTarget.tagName.toLowerCase() === 'a' && linkTarget.hasAttribute('href') && !linkTarget.classList.contains('force-reload')) {

            if (linkTarget.classList.contains('close-page-draw')) {

                // Go back to home page
                if (this.currentPage) {
                    event.preventDefault();
                    this.closePageDraw();
                    window.history.pushState({ pageId: this.currentPage.id }, window.title, linkTarget.getAttribute('href'));
                } else {
                    // DO nothing. Let it happen. (temporary)
                }
            } else {
                var linkHref = linkTarget.getAttribute('href');
                if (window.location.href !== linkHref && this.loadableRegex.test(linkHref)) {
                    event.preventDefault();

                    if (this.currentDrawPage) {
                        (0, _animejs2.default)({
                            targets: this.currentDrawPage.el,
                            duration: 1000,
                            opacity: 0
                        });
                    }

                    // Will probably be a content page, display the mask
                    this.pageDraw.prepare();

                    this.loadPage(linkHref);
                }
            }
        }
    }
};

// Start App.


// Imports
VCA.start();

},{"animejs":1,"app/pages/pageList":253,"app/ui/Footer":254,"app/ui/Header":255,"app/ui/PageDraw":256,"fontfaceobserver":8,"zimplist/display/dom/stringToElement":265,"zimplist/utils/Config":272,"zimplist/utils/WindowManager":275}],246:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Config = require('zimplist/utils/Config');

var _Config2 = _interopRequireDefault(_Config);

var _Page2 = require('app/pages/Page.abstract');

var _Page3 = _interopRequireDefault(_Page2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies
// import _ from "lodash";


// Local app Dependencies


// Hidden consts

/**
 *
 */
var CandidatePage = function (_Page) {
    _inherits(CandidatePage, _Page);

    function CandidatePage(el, options) {
        _classCallCheck(this, CandidatePage);

        var _this = _possibleConstructorReturn(this, (CandidatePage.__proto__ || Object.getPrototypeOf(CandidatePage)).call(this, el, options));

        if (window.dataLayer || _Config2.default.env === 'development') {
            console.log('tracking time');
            _this._initGTMTracking();
        }

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(CandidatePage, [{
        key: 'breakpointChanged',
        value: function breakpointChanged(breakpoint, previousBreakpoint) {}

        /* ==========================
          Private Methods
          ========================== */

    }, {
        key: '_initGTMTracking',
        value: function _initGTMTracking() {
            this.addDomEvent('click', function (event) {
                var button = event.delegateTarget;

                var linkType = button.getAttribute('data-link-type');
                var externalPlatform = button.getAttribute('data-external-platform');

                window.dataLayer.push({
                    'event': 'externalClick',
                    'pageGroupingMaison': 'Human Resources',
                    'linkType': linkType,
                    'externalPlatform': externalPlatform,
                    'pageLanguage': document.documentElement.lang,
                    'uri': window.location.pathname + window.location.search + window.location.hash
                });
            }, '.button');
        }

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_childClickHandler',
        value: function _childClickHandler(event) {}
    }]);

    return CandidatePage;
}(_Page3.default);

exports.default = CandidatePage;

},{"app/pages/Page.abstract":251,"zimplist/utils/Config":272}],247:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ScrollingTracker = require('zimplist/utils/ScrollingTracker');

var _ScrollingTracker2 = _interopRequireDefault(_ScrollingTracker);

var _Page2 = require('app/pages/Page.abstract');

var _Page3 = _interopRequireDefault(_Page2);

var _ProfileSlider = require('app/components/ProfileSlider');

var _ProfileSlider2 = _interopRequireDefault(_ProfileSlider);

var _MediaGallery = require('app/components/MediaGallery');

var _MediaGallery2 = _interopRequireDefault(_MediaGallery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies
// import _ from "lodash";

// Local app Dependencies


// Hidden consts

/**
 *
 */
var CareersPage = function (_Page) {
    _inherits(CareersPage, _Page);

    function CareersPage(el, options) {
        _classCallCheck(this, CareersPage);

        var _this = _possibleConstructorReturn(this, (CareersPage.__proto__ || Object.getPrototypeOf(CareersPage)).call(this, el, options));

        var profileEl = _this.el.querySelector('.career-profiles');
        if (profileEl) {
            _this.profilesSlider = new _ProfileSlider2.default(profileEl);
            _this._registerSubView(_this.profilesSlider);

            var profileTracker = _this.scrollTracker.trackElement(profileEl, 1);

            if (profileTracker.state !== _ScrollingTracker2.default.STATE.OFF) {
                _this._animateProfiles();
            } else {
                profileTracker.on('state', function (event) {
                    if (event.state !== _ScrollingTracker2.default.STATE.OFF) {
                        _this._animateProfiles();
                        profileTracker.off('state');
                    }
                });
            }
        }

        var mediaGalleryEl = _this.el.querySelector('.media-gallery');
        if (mediaGalleryEl) {
            _this.mediaGallery = new _MediaGallery2.default(mediaGalleryEl);
            _this._registerSubView(_this.mediaGallery);
        }

        if (window.dataLayer) {
            _this._initGTMTracking();
        }

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    /* ==========================
      Private Methods
      ========================== */

    _createClass(CareersPage, [{
        key: '_initGTMTracking',
        value: function _initGTMTracking() {

            this.addDomEvent('click', function (event) {
                window.dataLayer.push({
                    'event': 'videoPlay',
                    'pageGroupingMaison': 'Human Resources',
                    'pageLanguage': document.documentElement.lang
                });
            }, '.gallery-item.item-video.visible');
        }
    }, {
        key: '_animateProfiles',
        value: function _animateProfiles() {
            Array.from(this.profilesSlider.el.querySelectorAll('.career-profile')).forEach(function (card) {
                return card.classList.remove('hidden');
            });
        }

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_childClickHandler',
        value: function _childClickHandler(event) {}
    }]);

    return CareersPage;
}(_Page3.default);

exports.default = CareersPage;

},{"app/components/MediaGallery":237,"app/components/ProfileSlider":238,"app/pages/Page.abstract":251,"zimplist/utils/ScrollingTracker":273}],248:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _xhr = require('xhr');

var _xhr2 = _interopRequireDefault(_xhr);

var _Page2 = require('app/pages/Page.abstract');

var _Page3 = _interopRequireDefault(_Page2);

var _empty = require('zimplist/display/dom/empty');

var _empty2 = _interopRequireDefault(_empty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// Local app Dependencies


// Hidden consts
var RECAPTCHA_API_URL = 'https://www.google.com/recaptcha/api.js';

var instances = [];

function loadRecaptchaApi(instance) {
    if (!window.grecaptcha) {

        instances.push(instance);

        var scriptEl = document.createElement('script');
        scriptEl.setAttribute('nonce', window.VCA_CONFIG.cspNonceRecaptcha);
        scriptEl.async = true;
        scriptEl.defer = true;
        scriptEl.src = RECAPTCHA_API_URL + '?onload=recaptchaLoaded&render=explicit&hl=' + document.documentElement.lang;
        document.head.appendChild(scriptEl);
    }
}

window.recaptchaLoaded = function () {
    while (instances.length) {
        instances.shift()._initCaptcha();
    }
};

/**
 *
 * Contact Page Class
 *
 */

var ContactPage = function (_Page) {
    _inherits(ContactPage, _Page);

    function ContactPage(el, options) {
        _classCallCheck(this, ContactPage);

        var _this = _possibleConstructorReturn(this, (ContactPage.__proto__ || Object.getPrototypeOf(ContactPage)).call(this, el, options));

        _this.contactForm = _this.el.querySelector('form');

        if (window.grecaptcha) {
            _this._initCaptcha();
        } else {
            loadRecaptchaApi(_this);
        }

        // setup DOM events
        _this.addDomEvent('submit', _this._formSubmitHandler, _this.contactForm);
        return _this;
    }

    _createClass(ContactPage, [{
        key: '_initCaptcha',
        value: function _initCaptcha() {
            this._captchaLoaded = true;

            var captchaEl = this.el.querySelector('.g-recaptcha');

            (0, _empty2.default)(captchaEl);

            var captchaRenderer = document.createElement('div');
            captchaEl.appendChild(captchaRenderer);
            window.grecaptcha.render(captchaRenderer, {
                sitekey: captchaEl.getAttribute('data-sitekey'),
                size: this.minWidth('m') ? 'normal' : 'compact'
            });
        }
    }, {
        key: 'sendData',
        value: function sendData() {
            var _this2 = this;

            var that = this;
            var formData = new FormData(this.contactForm);
            var action = this.contactForm.action;
            var method = this.contactForm.method;

            (0, _xhr2.default)({
                body: formData,
                uri: action,
                method: method
            }, function (err, resp, body) {
                var bodyObj = JSON.parse(body);
                var errors = bodyObj.errors;
                var isSent = bodyObj.is_sent;
                var contactErrorContainer = that.el.querySelector('#contact-error');

                if (!isSent) {

                    _this2._initCaptcha();

                    contactErrorContainer.classList.add('visible');
                    for (var error in errors) {
                        var formField = document.getElementById(error);

                        if (formField) {
                            formField.classList.remove('error');
                            formField.parentNode.classList.remove('error');

                            if (errors[error] && formField) {
                                formField.classList.add('error');
                                formField.parentNode.classList.add('error');
                            }
                        }
                    }

                    // Recaptcha specific errors
                    var recaptchaErrorEl = _this2.el.querySelector('.recaptcha-error');
                    if (errors['recaptcha']) {
                        recaptchaErrorEl.textContent = errors['recaptcha'];
                        recaptchaErrorEl.classList.add('visible');
                    } else {
                        recaptchaErrorEl.classList.remove('visible');
                    }
                } else {
                    // hide errors
                    contactErrorContainer.classList.remove('visible');

                    // remove errors from labels
                    var formLabels = document.getElementsByTagName('label');
                    for (var i = 0; i < formLabels.length; i++) {
                        formLabels[i].classList.remove('error');
                    }

                    // remove errors from inputs
                    var formInputs = document.getElementsByTagName('input');
                    for (var _i = 0; _i < formInputs.length; _i++) {
                        formInputs[_i].classList.remove('error');
                        formInputs[_i].value = '';
                    }

                    // remove errors from textareas
                    var formTextareas = document.getElementsByTagName('textarea');
                    for (var _i2 = 0; _i2 < formTextareas.length; _i2++) {
                        formTextareas[_i2].classList.remove('error');
                        formTextareas[_i2].value = '';
                    }

                    var submitContainer = _this2.el.querySelector('.submit-container .button');
                    submitContainer.classList.add('disabled');
                    submitContainer.querySelector('input[type="submit"]').disabled = true;

                    // show success message ?
                    var success = _this2.el.querySelector('.success');
                    success.classList.add('visible');

                    // this.contactForm.classList.add('is-sent');
                }
            });
        }

        /* ==========================
          Public Methods
          ========================== */

        /* ==========================
          Private Methods
          ========================== */

    }, {
        key: '_privateFunction',
        value: function _privateFunction() {}

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_childClickHandler',
        value: function _childClickHandler() {}
    }, {
        key: '_formSubmitHandler',
        value: function _formSubmitHandler(event) {
            event.preventDefault();

            this.sendData();
        }
    }]);

    return ContactPage;
}(_Page3.default);

exports.default = ContactPage;

},{"app/pages/Page.abstract":251,"xhr":232,"zimplist/display/dom/empty":261}],249:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _findLast = require('lodash/findLast');

var _findLast2 = _interopRequireDefault(_findLast);

var _SpriteAnimator = require('zimplist/display/animation/SpriteAnimator');

var _SpriteAnimator2 = _interopRequireDefault(_SpriteAnimator);

var _ScrollingTracker = require('zimplist/utils/ScrollingTracker');

var _ScrollingTracker2 = _interopRequireDefault(_ScrollingTracker);

var _WindowManager = require('zimplist/utils/WindowManager');

var _WindowManager2 = _interopRequireDefault(_WindowManager);

var _getDocumentRect = require('zimplist/display/getDocumentRect');

var _getDocumentRect2 = _interopRequireDefault(_getDocumentRect);

var _Page2 = require('app/pages/Page.abstract');

var _Page3 = _interopRequireDefault(_Page2);

var _ProgressPath = require('app/components/ProgressPath');

var _ProgressPath2 = _interopRequireDefault(_ProgressPath);

var _CareerSlider = require('app/components/CareerSlider');

var _CareerSlider2 = _interopRequireDefault(_CareerSlider);

var _AlphaVideo = require('app/components/AlphaVideo');

var _AlphaVideo2 = _interopRequireDefault(_AlphaVideo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies
// import _ from "lodash";


// Local app Dependencies


// Hidden consts
var MENU_COLLAPSE_HEIGHT = 111;

/**
 *
 */

var HomePage = function (_Page) {
    _inherits(HomePage, _Page);

    function HomePage(el, options) {
        _classCallCheck(this, HomePage);

        var _this = _possibleConstructorReturn(this, (HomePage.__proto__ || Object.getPrototypeOf(HomePage)).call(this, el, options));

        _this.careerSlider = new _CareerSlider2.default(_this.el.querySelector('.slider'));

        _this.progressPath = new _ProgressPath2.default(_this.el.querySelector('.progress-path'), {
            waypoints: Array.from(_this.el.querySelectorAll('.brand-initials')),
            cutouts: Array.from(_this.el.querySelectorAll('.progress-path-cutout'))
        });

        _this.alphaVideos = Array.from(_this.el.querySelectorAll('.alpha-video')).map(function (alphaVideo) {
            return new _AlphaVideo2.default(alphaVideo);
        });

        // wait for dancer video to be loaded
        _this.addDomEvent('loadedmetadata', function () {
            _WindowManager2.default.trigger('resize');
        }, _this.el.querySelector('.dancer-anim video'));

        if (window.dataLayer) {
            _this._initGTMTracking();
            _this._currentTackedSection = null;
        }

        _this._registerSubView(_this.progressPath);
        _this._registerSubView(_this.careerSlider);

        _this.breakpointChanged();

        _this._initScrollingTracker();
        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(HomePage, [{
        key: 'breakpointChanged',
        value: function breakpointChanged() {

            if (this.minWidth('m')) {

                if (!this.productSprite) {
                    var spriteEl = this.el.querySelector('.sprite');
                    this.productSprite = new _SpriteAnimator2.default(spriteEl, { fps: 0.75, numFrames: 9, url: spriteEl.getAttribute('data-src') });
                    this._registerSubView(this.productSprite);
                }
            } else {
                if (this.productSprite) {
                    this.productSprite.destroy();
                    this._unregisterSubView(this.productSprite);
                }
            }
        }
    }, {
        key: 'resize',
        value: function resize() {
            _get(HomePage.prototype.__proto__ || Object.getPrototypeOf(HomePage.prototype), 'resize', this).call(this);

            // Save section offset for GTM tracking
            this._sectionOffsets = Array.from(this.el.querySelectorAll('.page-section')).map(function (section) {
                return {
                    el: section,
                    offset: (0, _getDocumentRect2.default)(section).top - MENU_COLLAPSE_HEIGHT
                };
            });
        }

        /* ==========================
          Private Methods
          ========================== */

        /**
         * For performance and delayed animation reasons, we scroll track various elements
         *
         * @private
         */

    }, {
        key: '_initScrollingTracker',
        value: function _initScrollingTracker() {
            var _this2 = this;

            // this.scrollTracker = new ScrollingTracker();

            // scrolling tracker for butterfly anims for performance reasons
            Array.from(this.el.querySelectorAll('.butterfly-overlay.alpha-video')).forEach(function (overlay) {
                var tracker = _this2.scrollTracker.trackElement(overlay);
                tracker.on('state', function (event) {
                    var video = overlay.querySelector('video');
                    if (event.state === _ScrollingTracker2.default.STATE.OFF) {
                        video.pause();
                    } else {
                        video.play();
                    }
                });
            });

            // Scrolling tracker for product sprite animator
            if (this.productSprite) {
                var productSpriteTracker = this.scrollTracker.trackElement(this.productSprite.el);
                productSpriteTracker.on('state', function (event) {
                    if (event.state === _ScrollingTracker2.default.STATE.OVERLAP || event.state === _ScrollingTracker2.default.STATE.ON) {
                        _this2.productSprite.play();
                    } else {
                        _this2.productSprite.pause();
                    }
                });

                if (productSpriteTracker.state === _ScrollingTracker2.default.STATE.ON || productSpriteTracker.state === _ScrollingTracker2.default.STATE.OVERLAP) {
                    this.productSprite.play();
                }
            }

            // Track careers slider
            var careerSliderEl = this.el.querySelector('section.careers .slider');
            var careerSliderTracker = this.scrollTracker.trackElement(careerSliderEl);

            if (careerSliderTracker.state === _ScrollingTracker2.default.STATE.OFF) {
                var visibleSlides = Array.from(careerSliderEl.querySelectorAll('.slider-item.visible'));
                visibleSlides.forEach(function (slide) {
                    return slide.classList.add('anim-in');
                });
                careerSliderTracker.on('state', function (event) {
                    if (event.state !== _ScrollingTracker2.default.STATE.OFF) {
                        // remove event to only animate once
                        careerSliderTracker.off('state');
                        visibleSlides.forEach(function (slide, i) {
                            setTimeout(function () {
                                return slide.classList.remove('anim-in');
                            }, 400 + i * 200);
                        });
                    }
                });
            }

            // Scrolling tracker for dancer anim
            var dancerAnim = this.el.querySelector('.dancer-anim');
            var dancerAnimTracker = this.scrollTracker.trackElement(dancerAnim, 0.75);

            // only play once, so don't listen for events if already onscreen
            if (dancerAnimTracker.state === _ScrollingTracker2.default.STATE.ON || dancerAnimTracker.state === _ScrollingTracker2.default.STATE.OVERLAP) {
                dancerAnim.querySelector('video').play();
            } else {
                dancerAnimTracker.on('state', function (event) {
                    if (event.state === _ScrollingTracker2.default.STATE.OVERLAP || event.state === _ScrollingTracker2.default.STATE.ON) {
                        setTimeout(function () {
                            return dancerAnim.querySelector('video').play();
                        }, 375);
                        dancerAnimTracker.off('state');
                    } else {
                        dancerAnim.querySelector('video').pause();
                    }
                });
            }

            // Track theme items to fade in
            Array.from(this.el.querySelectorAll('.theme-container li.theme-hidden')).forEach(function (themeItem) {

                var tracker = _this2.scrollTracker.trackElement(themeItem);

                // only play once, so don't listen for events if already onscreen
                if (tracker.state === _ScrollingTracker2.default.STATE.ON || tracker.state === _ScrollingTracker2.default.STATE.OVERLAP) {
                    themeItem.classList.remove('theme-hidden');
                } else {
                    tracker.on('state', function (event) {
                        if (event.state === _ScrollingTracker2.default.STATE.OVERLAP || event.state === _ScrollingTracker2.default.STATE.ON) {
                            themeItem.classList.remove('theme-hidden');
                        }
                    });
                }
            });

            // enable scrolling tracker for dancer-line.
            var dancerLineFull = this.el.querySelector('.candidate .dancer-line .full');
            var dancerLineScrollTracker = this.scrollTracker.trackElement(dancerLineFull, 0.25);

            if (dancerLineScrollTracker.state === _ScrollingTracker2.default.STATE.ON) {
                dancerLineFull.classList.remove('stacked');
            } else {
                dancerLineScrollTracker.once('state:overlap', function () {
                    return dancerLineFull.classList.remove('stacked');
                });
            }
        }
    }, {
        key: '_initGTMTracking',
        value: function _initGTMTracking() {
            var _this3 = this;

            // Our values CTA
            this.addDomEvent('click', function (event) {
                window.dataLayer.push({
                    'event': 'virtualSection',
                    'pageGroupingMaison': 'Human Resources',
                    'section': 'brand-values',
                    'subSection': 'brand-values',
                    'uri': event.delegateTarget.getAttribute('href'),
                    'pageLanguage': document.documentElement.lang
                });
            }, 'section.brand-values .button');

            this.addDomEvent('click', function (event) {

                var link = event.delegateTarget.querySelector('.career-title a');

                window.dataLayer.push({
                    'event': 'virtualSection',
                    'pageGroupingMaison': 'Human Resources',
                    'section': 'human-resources',
                    'subSection': link.getAttribute('data-tracking-id'),
                    'uri': link.getAttribute('href'),
                    'pageLanguage': document.documentElement.lang

                });
            }, '.careers .slider-item');

            this.addDomEvent('click', function (event) {

                var link = event.delegateTarget;

                window.dataLayer.push({
                    'event': 'virtualSection',
                    'pageGroupingMaison': 'Human Resources',
                    'section': 'Human Resources',
                    'subSection': link.getAttribute('data-tracking-id'),
                    'uri': link.getAttribute('href'),
                    'pageLanguage': document.documentElement.lang
                });
            }, '.page-section.human-resources .button');

            this.addDomEvent('click', function (event) {
                window.dataLayer.push({
                    'event': 'virtualSection',
                    'pageGroupingMaison': 'Human Resources',
                    'section': 'candidate',
                    'subSection': 'candidate',
                    'uri': event.delegateTarget.getAttribute('href'),
                    'pageLanguage': document.documentElement.lang
                });
            }, 'section.candidate .button');

            this.listenTo(_WindowManager2.default, 'scroll', function (event) {

                var section = (0, _findLast2.default)(_this3._sectionOffsets, function (sectionOffset) {
                    return _WindowManager2.default.scrollPosition.top >= sectionOffset.offset;
                });

                if (section && section !== _this3._currentTackedSection) {
                    var sectionAnchor = section.el.querySelector('a[name]');
                    if (sectionAnchor) {

                        window.dataLayer.push({
                            'event': 'virtualSection',
                            'pageGroupingMaison': 'Human Resources',
                            'section': sectionAnchor.getAttribute('name'),
                            'uri': window.location.pathname,
                            'pageLanguage': document.documentElement.lang
                        });

                        _this3._currentTackedSection = section;
                    }
                }
            });
        }

        /* ==========================
          Event Handlers
          ========================== */

    }]);

    return HomePage;
}(_Page3.default);

exports.default = HomePage;

},{"app/components/AlphaVideo":234,"app/components/CareerSlider":235,"app/components/ProgressPath":239,"app/pages/Page.abstract":251,"lodash/findLast":181,"zimplist/display/animation/SpriteAnimator":260,"zimplist/display/getDocumentRect":266,"zimplist/utils/ScrollingTracker":273,"zimplist/utils/WindowManager":275}],250:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ScrollingTracker = require('zimplist/utils/ScrollingTracker');

var _ScrollingTracker2 = _interopRequireDefault(_ScrollingTracker);

var _Page2 = require('app/pages/Page.abstract');

var _Page3 = _interopRequireDefault(_Page2);

var _ProfileSlider = require('app/components/ProfileSlider');

var _ProfileSlider2 = _interopRequireDefault(_ProfileSlider);

var _MediaGallery = require('app/components/MediaGallery');

var _MediaGallery2 = _interopRequireDefault(_MediaGallery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies
// import _ from "lodash";

// Local app Dependencies


// Hidden consts

/**
 *
 */
var HumanResourcesPage = function (_Page) {
    _inherits(HumanResourcesPage, _Page);

    function HumanResourcesPage(el, options) {
        _classCallCheck(this, HumanResourcesPage);

        var _this = _possibleConstructorReturn(this, (HumanResourcesPage.__proto__ || Object.getPrototypeOf(HumanResourcesPage)).call(this, el, options));

        var profileEl = _this.el.querySelector('.career-profile-slider');
        if (profileEl) {
            _this.profilesSlider = new _ProfileSlider2.default(profileEl);
            _this._registerSubView(_this.profilesSlider);

            var profileTracker = _this.scrollTracker.trackElement(profileEl, 0.75);

            if (profileTracker.state !== _ScrollingTracker2.default.STATE.OFF) {
                _this._animateProfiles();
            } else {

                profileTracker.on('state', function (event) {
                    if (event.state === _ScrollingTracker2.default.STATE.OVERLAP || event.state === _ScrollingTracker2.default.STATE.ON) {
                        _this._animateProfiles();
                        profileTracker.off('state');
                    }
                });
            }
        }

        var mediaGalleryEl = _this.el.querySelector('.media-gallery');
        if (mediaGalleryEl) {
            _this.mediaGallery = new _MediaGallery2.default(mediaGalleryEl);
            _this._registerSubView(_this.mediaGallery);
        }

        // Google Tag Manager
        if (window.dataLayer) {
            _this._initGTMTracking();
        }

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    /* ==========================
      Private Methods
      ========================== */

    _createClass(HumanResourcesPage, [{
        key: '_initGTMTracking',
        value: function _initGTMTracking() {
            this.addDomEvent('click', function (event) {

                var button = event.delegateTarget;

                var linkType = button.getAttribute('data-link-type');
                var externalPlatform = button.getAttribute('data-external-platform');

                if (linkType) {
                    window.dataLayer.push({
                        'event': 'externalClick',
                        'pageGroupingMaison': 'Human Resources',
                        'linkType': linkType,
                        'pageLanguage': document.documentElement.lang
                    });
                } else if (externalPlatform) {
                    window.dataLayer.push({
                        'event': 'externalClick',
                        'pageGroupingMaison': 'Human Resources',
                        'externalPlatform': externalPlatform,
                        'pageLanguage': document.documentElement.lang
                    });
                }
            }, '.button');

            this.addDomEvent('click', function () {

                window.dataLayer.push({
                    'event': 'videoPlay',
                    'line': 'Human Resources'
                });
            }, '.gallery-item.item-video.visible');
        }
    }, {
        key: '_animateProfiles',
        value: function _animateProfiles() {
            Array.from(this.profilesSlider.el.querySelectorAll('.career-profile')).forEach(function (card) {
                return card.classList.remove('hidden');
            });
        }

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_childClickHandler',
        value: function _childClickHandler(event) {}
    }]);

    return HumanResourcesPage;
}(_Page3.default);

exports.default = HumanResourcesPage;

},{"app/components/MediaGallery":237,"app/components/ProfileSlider":238,"app/pages/Page.abstract":251,"zimplist/utils/ScrollingTracker":273}],251:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _debounce = require('lodash/debounce');

var _debounce2 = _interopRequireDefault(_debounce);

var _animejs = require('animejs');

var _animejs2 = _interopRequireDefault(_animejs);

var _ContainerView2 = require('zimplist/display/ContainerView');

var _ContainerView3 = _interopRequireDefault(_ContainerView2);

var _WindowManager = require('zimplist/utils/WindowManager');

var _WindowManager2 = _interopRequireDefault(_WindowManager);

var _ScrollingTracker = require('zimplist/utils/ScrollingTracker');

var _ScrollingTracker2 = _interopRequireDefault(_ScrollingTracker);

var _Style = require('zimplist/utils/Style');

var _Style2 = _interopRequireDefault(_Style);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// Zimplist Depedencies


// Local app Dependencies


// Hidden consts

/**
 *
 */
var Page = function (_ContainerView) {
    _inherits(Page, _ContainerView);

    function Page(el, options) {
        _classCallCheck(this, Page);

        var _this = _possibleConstructorReturn(this, (Page.__proto__ || Object.getPrototypeOf(Page)).call(this, el, options));

        _this.listenTo(_WindowManager2.default, 'resize', _this.resize);

        // Every page needs a scrolling tracker
        var parentNode = _this.el.parentNode;

        _this.scrollTracker = new _ScrollingTracker2.default(_this.id === 'home' ? window : parentNode);

        var contentPageCover = _this.el.querySelector('.content-page-cover > img');
        if (contentPageCover) {
            _this.contentPageCover = contentPageCover;
            _this.addDomEvent('scroll', _this._scrollHandler, _this.scrollTracker.scrollContainer);
        }

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(Page, [{
        key: '_scrollHandler',
        value: function _scrollHandler(event) {
            var _this2 = this;

            if (!this.queuedFrame) {

                this.queuedFrame = requestAnimationFrame(function () {
                    var scrollTop = _this2.scrollTracker._getScrollContainerScrollTop();
                    _Style2.default.set(_this2.contentPageCover, { transform: 'translateY(' + scrollTop * 0.5 + 'px)' });
                    _this2.queuedFrame = null;
                });
            }
        }
    }, {
        key: 'id',
        get: function get() {
            return this.el.getAttribute('data-page-id');
        }
    }]);

    return Page;
}(_ContainerView3.default);

exports.default = Page;

},{"animejs":1,"lodash/debounce":173,"zimplist/display/ContainerView":259,"zimplist/utils/ScrollingTracker":273,"zimplist/utils/Style":274,"zimplist/utils/WindowManager":275}],252:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _animejs = require('animejs');

var _animejs2 = _interopRequireDefault(_animejs);

var _ScrollingTracker = require('zimplist/utils/ScrollingTracker');

var _ScrollingTracker2 = _interopRequireDefault(_ScrollingTracker);

var _Page2 = require('app/pages/Page.abstract');

var _Page3 = _interopRequireDefault(_Page2);

var _ValuesWheel = require('app/components/values-wheel/ValuesWheel');

var _ValuesWheel2 = _interopRequireDefault(_ValuesWheel);

var _ValuesWheelSmall = require('app/components/values-wheel/ValuesWheelSmall');

var _ValuesWheelSmall2 = _interopRequireDefault(_ValuesWheelSmall);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies
// import _ from "lodash";


// Local app Dependencies


// Hidden consts

/**
 *
 */
var ValuesPage = function (_Page) {
    _inherits(ValuesPage, _Page);

    function ValuesPage(el, options) {
        _classCallCheck(this, ValuesPage);

        var _this = _possibleConstructorReturn(this, (ValuesPage.__proto__ || Object.getPrototypeOf(ValuesPage)).call(this, el, options));

        _this.addDomEvent('click', _this._moreValuesTriggerClickHandler, '.more-values-trigger');

        var valuesWheelEl = _this.el.querySelector('.values-wheel');

        if (_this.minWidth('m')) {
            _this.wheel = new _ValuesWheel2.default(valuesWheelEl);
        } else {
            _this.wheel = new _ValuesWheelSmall2.default(valuesWheelEl);
        }

        var wheelTracker = _this.scrollTracker.trackElement(valuesWheelEl);

        if (wheelTracker.state !== _ScrollingTracker2.default.STATE.OFF) {
            _this.wheel.introAnimation();
            _this.scrollTracker.untrackElement(wheelTracker);
        } else {
            wheelTracker.on('state', function (event) {
                if (event.state === _ScrollingTracker2.default.STATE.ON || event.state === _ScrollingTracker2.default.STATE.OVERLAP) {
                    _this.wheel.introAnimation();
                    wheelTracker.off('state');
                    _this.scrollTracker.untrackElement(wheelTracker);
                }
            });
        }

        // Google Tag Manager
        var buttons = _this.el.querySelectorAll('.button');

        buttons.forEach(function (button) {
            _this.addDomEvent('click', function () {

                var linkType = button.getAttribute('data-link-type');
                var externalPlatform = button.getAttribute('data-external-platform');

                if (linkType) {
                    window.dataLayer.push({
                        'event': 'externalClick',
                        'pageGroupingMaison': 'Human Resources',
                        'linkType': linkType,
                        'pageLanguage': document.documentElement.lang
                    });
                } else if (externalPlatform) {
                    window.dataLayer.push({
                        'event': 'externalClick',
                        'pageGroupingMaison': 'Human Resources',
                        'externalPlatform': externalPlatform,
                        'pageLanguage': document.documentElement.lang
                    });
                }
            }, button);
        });

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    /* ==========================
      Private Methods
      ========================== */


    _createClass(ValuesPage, [{
        key: '_privateFunction',
        value: function _privateFunction() {}

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_moreValuesTriggerClickHandler',
        value: function _moreValuesTriggerClickHandler(event) {

            var mask = this.el.querySelector('.more-values-mask');

            if (mask.classList.contains('hidden')) {
                (0, _animejs2.default)({
                    targets: mask,
                    duration: 1000,
                    height: [0, this.el.querySelector('.more-values-content').clientHeight],
                    easing: 'easeInOutCubic',
                    complete: function complete() {
                        mask.classList.remove('hidden');
                    }
                });

                this.el.querySelector('.trigger-container').classList.add('disabled');
            }
        }
    }]);

    return ValuesPage;
}(_Page3.default);

exports.default = ValuesPage;

},{"animejs":1,"app/components/values-wheel/ValuesWheel":241,"app/components/values-wheel/ValuesWheelSmall":242,"app/pages/Page.abstract":251,"zimplist/utils/ScrollingTracker":273}],253:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Page = require('app/pages/Page.abstract');

var _Page2 = _interopRequireDefault(_Page);

var _HomePage = require('app/pages/HomePage');

var _HomePage2 = _interopRequireDefault(_HomePage);

var _ValuesPage = require('app/pages/ValuesPage');

var _ValuesPage2 = _interopRequireDefault(_ValuesPage);

var _CareersPage = require('app/pages/CareersPage');

var _CareersPage2 = _interopRequireDefault(_CareersPage);

var _HumanResourcesPage = require('app/pages/HumanResourcesPage');

var _HumanResourcesPage2 = _interopRequireDefault(_HumanResourcesPage);

var _ContactPage = require('app/pages/ContactPage');

var _ContactPage2 = _interopRequireDefault(_ContactPage);

var _CandidatePage = require('app/pages/CandidatePage');

var _CandidatePage2 = _interopRequireDefault(_CandidatePage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Map of page ID's and view classes
// The keys must match the page IDs sent by the server
var pageList = {
    'default': _Page2.default,
    'home': _HomePage2.default,
    'our-values': _ValuesPage2.default,
    'careers': _CareersPage2.default,
    'human-resources': _HumanResourcesPage2.default,
    'contact': _ContactPage2.default,
    'candidate': _CandidatePage2.default,
    'legals': _Page2.default
};

exports.default = pageList;

},{"app/pages/CandidatePage":246,"app/pages/CareersPage":247,"app/pages/ContactPage":248,"app/pages/HomePage":249,"app/pages/HumanResourcesPage":250,"app/pages/Page.abstract":251,"app/pages/ValuesPage":252}],254:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _LinkSelect = require('app/components/LinkSelect');

var _LinkSelect2 = _interopRequireDefault(_LinkSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Footer = function (_BaseView) {
    _inherits(Footer, _BaseView);

    function Footer(el, options) {
        _classCallCheck(this, Footer);

        // init link select for languages
        var _this = _possibleConstructorReturn(this, (Footer.__proto__ || Object.getPrototypeOf(Footer)).call(this, el, options));

        _this.langSelect = new _LinkSelect2.default(_this.el.querySelector('.lang-select'));

        if (window.dataLayer) {
            _this._initGTMTracking();
        }

        return _this;
    }

    _createClass(Footer, [{
        key: '_initGTMTracking',
        value: function _initGTMTracking() {
            this.addDomEvent('click', function () {
                window.dataLayer.push({
                    'event': 'newsletterHR',
                    'pageGroupingMaison': 'Human Resources',
                    'pageLanguage': document.documentElement.lang
                });
            }, '.gtm');
        }
    }]);

    return Footer;
}(_BaseView3.default);

exports.default = Footer;

},{"app/components/LinkSelect":236,"zimplist/display/BaseView":258}],255:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _animejs = require('animejs');

var _animejs2 = _interopRequireDefault(_animejs);

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _WindowManager = require('zimplist/utils/WindowManager');

var _WindowManager2 = _interopRequireDefault(_WindowManager);

var _getDocumentRect = require('zimplist/display/getDocumentRect');

var _getDocumentRect2 = _interopRequireDefault(_getDocumentRect);

var _LinkSelect = require('app/components/LinkSelect');

var _LinkSelect2 = _interopRequireDefault(_LinkSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// Zimplist Depedencies

// import getScrollParent from 'zimplist/display/dom/getScrollParent';

// Local app Dependencies


// Hidden consts
var SCROLL_SPEED_RATIO = 0.7;
var HEIGHT_HEADER_MENU = 111;

/**
 *
 */

var Header = function (_BaseView) {
    _inherits(Header, _BaseView);

    function Header(el, options) {
        _classCallCheck(this, Header);

        var _this = _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).call(this, el, options));

        _this.langSelect = new _LinkSelect2.default(_this.el.querySelector('.lang-select'));

        // Dom Events
        _this.addDomEvent('transitionend', _this._transitionEndHandler);
        _this.addDomEvent('click', _this._menuToggleClickHandler, '.menu-toggle'); // specifying this.el prevents bubbled events from triggering this
        _this.addDomEvent('click', _this._menuItemClickHandler, '.menu a');
        _this.addDomEvent('click', _this._menuLogoClickHandler, '.small-logo');

        _this.listenTo(_WindowManager2.default, 'scroll', _this._scrollHandler);

        _this.langSelect.on('open', function (event) {
            _this.el.classList.add('is-fade-out');
        });

        _this.langSelect.on('close', function (event) {
            _this.el.classList.remove('is-fade-out');
        });

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(Header, [{
        key: 'breakpointChanged',
        value: function breakpointChanged(breakpoint, previousBreakpoint) {
            _get(Header.prototype.__proto__ || Object.getPrototypeOf(Header.prototype), 'breakpointChanged', this).call(this, breakpoint, previousBreakpoint);

            if (this.minWidth('m')) {
                this.close(); // Close because we don't need scroll lock
            }
        }
    }, {
        key: 'open',
        value: function open() {
            this.isOpen = true;
            this.el.classList.add('open');

            document.body.classList.add('scroll-lock');
        }
    }, {
        key: 'close',
        value: function close() {
            this.isOpen = false;
            this.el.classList.remove('open');

            document.body.classList.remove('scroll-lock');
        }

        /* ==========================
          Private Methods
          ========================== */

    }, {
        key: '_scrollPage',
        value: function _scrollPage(offset, speed) {

            console.log(offset);

            if (this.minWidth('m')) {
                (0, _animejs2.default)({
                    targets: { // target is a proxy object to the window manager

                        get scrollTop() {
                            return _WindowManager2.default.scrollPosition.top;
                        },

                        set scrollTop(value) {
                            _WindowManager2.default.scrollTo(parseFloat(value), 0); // for some reason animejs sets a string for float values
                        }

                    },
                    duration: speed,
                    scrollTop: offset,
                    easing: 'easeInOutCubic'
                });
            } else {
                // offset = anchorBox.top - 20;
                _WindowManager2.default.scrollTo(offset);
                this.close();
            }
        }

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_menuToggleClickHandler',
        value: function _menuToggleClickHandler() {
            this.isOpen ? this.close() : this.open();
        }
    }, {
        key: '_transitionEndHandler',
        value: function _transitionEndHandler(event) {

            if (event.target === this.el) {
                _WindowManager2.default.trigger('resize');
            }
        }
    }, {
        key: '_menuItemClickHandler',
        value: function _menuItemClickHandler(event) {

            if (!(event.metaKey || event.ctrlKey)) {
                event.preventDefault();

                var sectionName = event.delegateTarget.getAttribute('href').slice(1);
                var sectionAnchor = document.querySelector('a[name="' + sectionName + '"]').parentNode;

                var anchorBox = (0, _getDocumentRect2.default)(sectionAnchor);
                var offset = this.minWidth('m') ? anchorBox.top - HEIGHT_HEADER_MENU + 2 : // +2 to fudge the GTM tracking
                anchorBox.top - 22;

                var distance = Math.abs(_WindowManager2.default.scrollPosition.top - offset);

                this._scrollPage(offset, distance * SCROLL_SPEED_RATIO);
            }
        }
    }, {
        key: '_menuLogoClickHandler',
        value: function _menuLogoClickHandler(event) {
            event.preventDefault();
            event.stopPropagation();

            this._scrollPage(0, _WindowManager2.default.scrollPosition.top * SCROLL_SPEED_RATIO);
        }
    }, {
        key: '_scrollHandler',
        value: function _scrollHandler() {

            if (_WindowManager2.default.scrollPosition.top <= 100) {
                this.el.classList.remove('collapsed');
                document.body.classList.remove('menu-collapsed');
            } else {
                this.el.classList.add('collapsed');
                document.body.classList.add('menu-collapsed');
            }
        }
    }]);

    return Header;
}(_BaseView3.default);

exports.default = Header;

},{"animejs":1,"app/components/LinkSelect":236,"zimplist/display/BaseView":258,"zimplist/display/getDocumentRect":266,"zimplist/utils/WindowManager":275}],256:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _animejs = require('animejs');

var _animejs2 = _interopRequireDefault(_animejs);

var _BaseView2 = require('zimplist/display/BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _empty = require('zimplist/display/dom/empty');

var _empty2 = _interopRequireDefault(_empty);

var _Keyboard = require('zimplist/input/Keyboard');

var _Keyboard2 = _interopRequireDefault(_Keyboard);

var _SpriteAnimator = require('zimplist/display/animation/SpriteAnimator');

var _SpriteAnimator2 = _interopRequireDefault(_SpriteAnimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies
// import _ from "lodash";


// Zimplist Depedencies


// Local app Dependencies


// Hidden consts

/**
 *
 */
var PageDraw = function (_BaseView) {
    _inherits(PageDraw, _BaseView);

    function PageDraw(el, options) {
        _classCallCheck(this, PageDraw);

        var _this = _possibleConstructorReturn(this, (PageDraw.__proto__ || Object.getPrototypeOf(PageDraw)).call(this, el, options));

        _this.pageContainer = _this.el.querySelector('.page-draw-main');

        var spriteCanvas = _this.el.querySelector('.sprite');
        _this.sprite = new _SpriteAnimator2.default(spriteCanvas, { fps: 25, autoplay: false, loop: false, numFrames: 36, url: spriteCanvas.getAttribute('data-src') });

        var loaderCanvas = document.body.querySelector('.page-draw-loader canvas');
        _this.loader = new _SpriteAnimator2.default(loaderCanvas, { fps: 25, autoplay: false, loop: true, numFrames: 36, url: loaderCanvas.getAttribute('data-src') });

        _this.addDomEvent('transitionend', _this._transitionEndHandler); // specifying this.el prevents bubbled events from triggering this // TODO test this

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    _createClass(PageDraw, [{
        key: 'injectPageEl',
        value: function injectPageEl(pageEl) {

            if (this.currentPageEl) {
                (0, _empty2.default)(this.pageContainer);
                this.pageContainer.scrollTop = 0;
            }

            this.currentPageEl = pageEl;

            if (!this.pageContainer.contains(pageEl)) {
                this.pageContainer.appendChild(pageEl);

                pageEl.style.opacity = 0;

                (0, _animejs2.default)({
                    targets: pageEl,
                    duration: 1000,
                    easing: 'easeOutCubic',
                    opacity: [0, 1]
                });
            }
        }
    }, {
        key: 'prepare',
        value: function prepare() {
            document.body.classList.add('page-draw-mask');
            this.loader.play();
        }
    }, {
        key: 'open',
        value: function open() {
            this.isOpen = true;
            document.body.classList.add('page-draw-open');

            /*if ( this.minWidth('m') ) {
                // setTimeout( () => this.sprite.play(), 800);
            }
            */
        }
    }, {
        key: 'close',
        value: function close() {
            this.isOpen = false;
            document.body.classList.remove('page-draw-open');
            document.body.classList.remove('scroll-lock');
            document.body.classList.remove('page-draw-mask');

            this.loader.pause();
            this.loader.currentFrame = 0;

            this.sprite.currentFrame = 0;
        }

        /* ==========================
          Private Methods
          ========================== */

    }, {
        key: '_privateFunction',
        value: function _privateFunction() {}

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_transitionEndHandler',
        value: function _transitionEndHandler(event) {
            if (event.target === this.el) {
                if (this.isOpen) {
                    document.body.classList.add('scroll-lock');
                    if (this.minWidth('m')) {
                        this.sprite.play();
                    }
                } else {
                    (0, _empty2.default)(this.pageContainer);
                }
            }
        }
    }]);

    return PageDraw;
}(_BaseView3.default);

exports.default = PageDraw;

},{"animejs":1,"zimplist/display/BaseView":258,"zimplist/display/animation/SpriteAnimator":260,"zimplist/display/dom/empty":261,"zimplist/input/Keyboard":268}],257:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EVENTS = '_EVENTS'; // Define a unique key for all instances to create event hash on
var LISTEN_TARGETS = '_LISTEN_TARGETS'; // Define a unique key for all instances to create a listen array on;

/**
 * The EventTarget is a class that allows the use of custom events in it's instances. it is an implementation of the
 * Pub/Sub pattern.
 *
 * It is generally not used directly but is inherited from in other classes.
 *
 * Important : This class should not be mistaken with the native EventTarget class Elements, Window and Document inherit from.
 *
 */

var EventTarget = function () {

    /**
     * This MUST be called by sub-classes to instantiate the correct properties where events are stored.
     *
     */
    function EventTarget() {
        _classCallCheck(this, EventTarget);

        /**
         * @private
         * @type {{}}
         */
        this[EVENTS] = {};

        /**
         * @private
         * @type {Array}
         */
        this[LISTEN_TARGETS] = [];
    }

    /**
     * Register an event handler for a type
     * @param {string} type - The type of the event. A custom human readable string.
     * @param {function} handler - The function that will be invoked when the event is triggered. No signature is provided, it is up to the developer to determine what is passed to the listener at trigger time
     * @param {Object} [context=this] - The object the listener will called on. Defaults to `this` and can be changed if event delegation is needed.
     */


    _createClass(EventTarget, [{
        key: 'on',
        value: function on(type, handler) {
            var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;


            if (typeof type === 'string') {

                // ensure array of listeners for this type is available
                if (!this.hasListeners(type)) {
                    this[EVENTS][type] = [];
                }

                this[EVENTS][type].push({ handler: handler, context: context });
            } else {
                // Assume we have been passed an object of events.

                // loop over hash using key as type, and value as handler
                for (var key in type) {
                    if (type.hasOwnProperty(key)) {
                        var value = type[key];
                        this.on(key, value);
                    }
                }
            }
        }

        /**
         * Register an event handler that will trigger only once
         * @param {string} type - The type of the event. A custom human readable string.
         * @param {function} handler - The function that will be invoked when the event is triggered. No signature is provided, it is up to the developer to determine what is passed to the listener at trigger time
         * @param {Object} [context=this] - The object the listener will called on. Defaults to `this` and can be changed if event delegation is needed.
         */

    }, {
        key: 'once',
        value: function once(type, handler) {
            var _this = this;

            var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;


            // create surrogate handler that will execute once an remove event
            var onceHandler = function onceHandler() {
                for (var _len = arguments.length, eventData = Array(_len), _key = 0; _key < _len; _key++) {
                    eventData[_key] = arguments[_key];
                }

                handler.apply(_this, eventData);
                _this.off(type, onceHandler);
            };

            // register our surrogate event
            this.on(type, onceHandler, context);
        }

        /**
         * Remove event handler, either of one type, or just one listener
         * @param {string} type - The type of the event. A custom human readable string.
         * @param {function} [handler] - The event handler to be removed. If unspecififed, all handlers of the supplied type are removed.
         */

    }, {
        key: 'off',
        value: function off(type, handler) {

            if (this.hasListeners(type)) {

                if (typeof handler === "undefined") {
                    this[EVENTS][type] = [];
                } else {
                    var registeredHandler = this[EVENTS][type].find(function (testHandler) {
                        return testHandler.handler === handler;
                    });
                    if (registeredHandler !== -1) {
                        this[EVENTS][type].splice(this[EVENTS][type].lastIndexOf(registeredHandler), 1);
                    }
                }
            }
        }

        /**
         * Utility to allow EventTargets to listen to other EventTarget's events easily
         *
         * @TODO handle objects like in `on`
         *
         * @param {EventTarget} target - The instance of EventTarget to listen to events on
         * @param {string} type - The type of the event. A custom human readable string.
         * @param {function} handler - The function that will be invoked when the event is triggered. No signature is provided, it is up to the developer to determine what is passed to the listener at trigger time
         */

    }, {
        key: 'listenTo',
        value: function listenTo(target, type, handler) {

            if (!(target instanceof EventTarget)) {
                throw new Error('Attempting to listenTo an object that does not inherit from EventTarget');
            }

            // Determine if we are listening to this object yet
            var targetListeners = this[LISTEN_TARGETS].find(function (testTarget) {
                return testTarget.target === target;
            });

            // If target listeners doesn't exist yet, add it here
            if (!targetListeners) {
                targetListeners = { target: target, listeners: {} };
                this[LISTEN_TARGETS].push(targetListeners);
            }

            // make sure an array for this type of event is available
            targetListeners.listeners[type] = targetListeners.listeners[type] || [];

            // Add to register of functions
            targetListeners.listeners[type].push(handler);

            // bind event normally
            target.on(type, handler, this);
        }

        /**
         * Stop listening for events on another EventTarget
         * @param {EventTarget} target - The instance of EventTarget to stop receiving events from.
         * @param {string} type - The type of the event. A custom human readable string.
         */

    }, {
        key: 'stopListening',
        value: function stopListening(target, type) {

            // Determine if we are listening to this object yet
            // var targetListeners = _.find(this[LISTEN_TARGETS], {target : target });
            var targetListeners = this[LISTEN_TARGETS].find(function (testTarget) {
                return testTarget === target;
            });

            // If listeners are registered for this target
            if (targetListeners) {

                if (type) {

                    targetListeners.listeners[type].forEach(function (handler) {
                        target.off(type, handler);
                    });
                } else {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        var _loop = function _loop() {
                            var typeIter = _step.value;


                            targetListeners.listeners[typeIter].forEach(function (handler) {
                                target.off(typeIter, handler);
                            });
                        };

                        for (var _iterator = Object.keys(targetListeners.listeners)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            _loop();
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
            }
        }

        /**
         * Determine if this object has events registered of a certain type
         * @param {string} type - Event type to check.
         * @returns {boolean} if the EventTarget has listeners for this type of event
         */

    }, {
        key: 'hasListeners',
        value: function hasListeners(type) {
            return typeof this[EVENTS][type] !== 'undefined';
        }

        /**
         * Trigger an event on this object
         * @param {string} type - The event type who's listeners will be triggered
         * @param {...*} eventParams - The parameters to be passed to the listening objects. Any number can be passed but it is recomended to only pass a single event object on which you may attach multiple properties.
         */

    }, {
        key: 'trigger',
        value: function trigger(type) {

            // if an event of this type has been registered on this event
            if (this.hasListeners(type)) {

                // loop over listeners registered for this event type
                // note : could have used for of, but could need a Symbol polyfill which is too much code.
                var handlers = this[EVENTS][type];

                for (var _len2 = arguments.length, eventParams = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    eventParams[_key2 - 1] = arguments[_key2];
                }

                for (var eventKey in handlers) {

                    if (handlers.hasOwnProperty(eventKey)) {
                        var event = this[EVENTS][type][eventKey];

                        event.handler.apply(event.context, eventParams);
                    }
                }
            }
        }
    }]);

    return EventTarget;
}();

exports.default = EventTarget;

},{}],258:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isElement = require('lodash/isElement');

var _isElement2 = _interopRequireDefault(_isElement);

var _isString = require('lodash/isString');

var _isString2 = _interopRequireDefault(_isString);

var _isUndefined = require('lodash/isUndefined');

var _isUndefined2 = _interopRequireDefault(_isUndefined);

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _filter = require('lodash/filter');

var _filter2 = _interopRequireDefault(_filter);

var _each = require('lodash/each');

var _each2 = _interopRequireDefault(_each);

var _clone = require('lodash/clone');

var _clone2 = _interopRequireDefault(_clone);

var _includes = require('lodash/includes');

var _includes2 = _interopRequireDefault(_includes);

var _findLast = require('lodash/findLast');

var _findLast2 = _interopRequireDefault(_findLast);

var _EventTarget2 = require('../core/EventTarget');

var _EventTarget3 = _interopRequireDefault(_EventTarget2);

var _WindowManager = require('../utils/WindowManager');

var _WindowManager2 = _interopRequireDefault(_WindowManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// Zimple dependencies


/**
 * BaseView is the base class for organizing the DOM. It extends EventTarget to allow event based communication between
 * Views and their parents or other parts of the application that also inherit from EventTarget.
 *
 * BaseView enables easily adding DOM Events by doing the book keeping and allowing for event delegation.
 */
var BaseView = function (_EventTarget) {
    _inherits(BaseView, _EventTarget);

    /**
     *
     * @param {Element} el - The Element this view is responsible for. Saved to this.el, a View is always responsible
     *      For a single root element. The view can then split up it's contained elements with subviews
     * @param {Object} options - An object of options for the view
     * @param {Array} options.breakpoints - An array of breakpoint objects the view uses. If this options is specified,
     *      the `breakpointChanged` function will only be called with breakpoints specified here, otherwise it will be called
     *      for every breakpoint change.
     */
    function BaseView(el) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, BaseView);

        // Check supplied el parameter
        var _this = _possibleConstructorReturn(this, (BaseView.__proto__ || Object.getPrototypeOf(BaseView)).call(this));

        if (!el) {
            throw new Error('You must specify a root element for the View');
        } else if (!(0, _isElement2.default)(el)) {
            throw new Error('Supplied `el` argument needs to be a DOMElement');
        }

        // Save supplied values
        _this.el = el;
        _this.options = options;

        // Breakpoint handling
        if (_this.options.breakpoints) {
            // react only breakpoints specified in the options
            _this.breakpoints = (0, _filter2.default)(_WindowManager2.default.breakpoints, function (bp) {
                return (0, _includes2.default)(_this.options.breakpoints, bp.name);
            });
        } else {
            // use all breakpoints
            _this.breakpoints = (0, _clone2.default)(_WindowManager2.default.breakpoints);
        }

        // on first instantiation of any BaseView, bind the WindowManager.breakpoint handler
        if (!BaseView.instances.length) {
            _WindowManager2.default.on('breakpoint', breakpointHandler);
        }

        // Save newly created instance to static array.
        BaseView.instances.push(_this);

        // detect first breakpoint
        _this.currentBreakpoint = (0, _findLast2.default)(_this.breakpoints, function (bp) {
            return _WindowManager2.default.width >= bp.value;
        });

        return _this;
    }

    /**
     * Function is called when breakpoint is changed
     */


    _createClass(BaseView, [{
        key: 'breakpointChanged',
        value: function breakpointChanged() {}

        /**
         *  Bind a DOMEvent to the view, optionally filtered on the selector.
         *
         * @param {String} type - Event typoe
         * @param {Function(event)} listener - Event listener function that will be scoped to this view
         * @param {String|Element} [selector=this.el] - If selector is a String, the string will be used to test matching using
         *      delegated events to `this.el`. If it's an Element then bind event directly to that element.
         *      Binding directly to an element is usefull for events that don't bubble. (form submit, for example)
         */

    }, {
        key: 'addDomEvent',
        value: function addDomEvent(type, listener) {
            var _this2 = this;

            var selector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


            // init domEvents registry if not present
            this._domEvents = this._domEvents || {};

            // init registry for this type
            this._domEvents[type] = this._domEvents[type] || [];

            // Check selector is either a valid string or an element
            if (selector && !((0, _isString2.default)(selector) && selector !== 'all' || (0, _isElement2.default)(selector))) {
                throw new Error('Invalid selector passed to addDomEvent. Must be String or DOMElement. Can not be "all"');
            }

            // check we have a function to bind to.
            if (!(0, _isFunction2.default)(listener)) {
                throw new Error('no event listener function specified for addDomEvent');
            }

            // if the selector is an element, add event to it, otherwise use this.el for event delegation
            var target = (0, _isElement2.default)(selector) ? selector : this.el;

            // create internal listener that will be saved
            var internalListener = function internalListener(event) {

                // init a flag to indicate if a selector has been found
                var inSelector = false;

                // create element iterator that will climb up the DOM.
                var iterEl = void 0;

                if (!selector) {
                    inSelector = true; // if no selector specified, always trigger
                } else {

                    iterEl = event.target;

                    if ((0, _isString2.default)(selector)) {

                        while (iterEl !== _this2.el) {

                            // when clicking on SVG <use> tags in IE,
                            // the event.target is actually the declaration element, and not the actual <use> tag
                            // in that case, switch reference to the actual <use /> tag
                            if ("correspondingUseElement" in iterEl) {
                                iterEl = iterEl.correspondingUseElement;
                            }

                            // .matches does't exist on SVG elements in old IE
                            if ('matches' in iterEl && iterEl.matches(selector)) {
                                inSelector = true;
                                break;
                            } else {
                                iterEl = iterEl.parentNode;
                            }
                        }
                    } else if ((0, _isElement2.default)(selector)) {
                        // If selector is an Element, then it is our target and will always match
                        iterEl = selector;
                        inSelector = true;
                    }
                }

                if (inSelector) {
                    // Add found selector to event and transparently trigger our listener
                    event.delegateTarget = iterEl;
                    listener.apply(_this2, [event]);
                }
            };

            // Native dom event
            target.addEventListener(type, internalListener);

            // Save event object
            this._domEvents[type].push({ target: target, listener: internalListener });
        }

        /**
         * Remove DOM event from the element
         * @param {Element} target - The element to remove events from
         * @param {String} [type='all'] - The DOM event Type. Special keyword 'all' removes all event types
         */

    }, {
        key: 'removeDomEvent',
        value: function removeDomEvent(target) {
            var _this3 = this;

            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';


            if (this._domEvents) {

                var events = void 0;
                if ((0, _isUndefined2.default)(type) || type === 'all') {
                    events = this._domEvents; // remove all events if no type is specified
                } else {
                    events = {};
                    events[type] = this._domEvents[type];
                }

                // for each event type
                (0, _each2.default)(events, function (eventListeners, iterType) {

                    // we don't want to modify the array in place during the loop, so save removed event listeners to an array
                    var removed = [];

                    // loop over listener objects and remove
                    (0, _each2.default)(eventListeners, function (listenerObj, i) {

                        if (!target || listenerObj.target == target) {
                            listenerObj.target.removeEventListener(iterType, listenerObj.listener);
                            removed.push(i);
                        }
                    });

                    // remove of listener objects now
                    removed.forEach(function (i) {
                        eventListeners.splice(i);
                    });

                    // Delete the object if there are no more listeners for this type
                    if (!eventListeners || eventListeners.length == 0) {
                        delete _this3._domEvents[iterType];
                    }
                });
            }
        }

        /**
         * Remove all DOM event listeners and remove the View element from the DOM. This function is used when we want to
         * remove the element from the DOM but want the view to stay in memory
         */

    }, {
        key: 'remove',
        value: function remove() {
            this.removeDomEvent();
            // Might not still be attached to DOM
            if (this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
        }

        /**
         * Removes DOM Element and DOM events. Unbinds other Events.
         * Call this to clean up the view before de-referencing it.
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.stopListening();
            this.remove();

            // Remove from internal list of instances
            BaseView.instances.splice(BaseView.instances.indexOf(this), 1);
        }

        /**
         * Dummy function to implement resizing
         */

    }, {
        key: 'resize',
        value: function resize() {}

        /**
         * Test to see if the viewport is currently at a certain breakpoint
         *
         * Proxies WindowManager.minWidth
         *
         * @param breakpoint {Number|String|Object} a breakpoint name, object or numerical value. See WindowManager.minWidth for more info
         * @returns {boolean}
         */

    }, {
        key: 'minWidth',
        value: function minWidth(breakpoint) {
            return _WindowManager2.default.minWidth(breakpoint);
        }
    }]);

    return BaseView;
}(_EventTarget3.default);

/**
 * Static array of instances
 * @static
 * @private
 * @type {Array<BaseView>}
 */


BaseView.instances = [];

/**
 * Single event handler from WindowManager breakpoint event. Handles calling of breakpointChanged on each instance if applicable
 * @private
 * @static
 * @param event
 */
function breakpointHandler(event) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = BaseView.instances[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var instance = _step.value;

            // get the max breakpoint this instance handles
            var usedBreakpoint = (0, _findLast2.default)(instance.breakpoints, function (bp) {
                return event.breakpoint.value >= bp.value;
            });

            // Check it's not the current breakpoint and invoke breakpointChanged method
            if (!(0, _isEqual2.default)(usedBreakpoint, instance.currentBreakpoint)) {
                instance.currentBreakpoint = usedBreakpoint;
                instance.breakpointChanged(usedBreakpoint, event.previous);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}

exports.default = BaseView;

},{"../core/EventTarget":257,"../utils/WindowManager":275,"lodash/clone":171,"lodash/each":175,"lodash/filter":178,"lodash/findLast":181,"lodash/includes":190,"lodash/isElement":197,"lodash/isEqual":198,"lodash/isFunction":199,"lodash/isString":205,"lodash/isUndefined":208}],259:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _includes = require('lodash/includes');

var _includes2 = _interopRequireDefault(_includes);

var _BaseView2 = require('./BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Third party dependencies


// Zimple Depedencies


/**
 * A view that can contain other views.
 * Automatically call resize/breakpointChanged/destroy on children.
 */
var ContainerView = function (_BaseView) {
    _inherits(ContainerView, _BaseView);

    /**
     * See super declaration. This view also instantiates a subview array
     * @param el
     * @param options
     */
    function ContainerView(el, options) {
        _classCallCheck(this, ContainerView);

        /**
         * An array of contained sub views
         * @type {Array}
         * @private
         */
        var _this = _possibleConstructorReturn(this, (ContainerView.__proto__ || Object.getPrototypeOf(ContainerView)).call(this, el, options));

        _this._subViews = [];

        return _this;
    }

    /* ==========================
      Public Methods
      ========================== */

    /**
     * Destroy
     */


    _createClass(ContainerView, [{
        key: 'destroy',
        value: function destroy() {
            var _this2 = this;

            // destroy and unregister all sub views
            this._subViews.forEach(function (view) {
                view.destroy();
                _this2._unregisterSubView(view);
            });

            // after this view is done, call super destroyer to do the real cleanup
            _get(ContainerView.prototype.__proto__ || Object.getPrototypeOf(ContainerView.prototype), 'destroy', this).call(this);
        }

        /**
         * Call resize for all the sub-views
         */

    }, {
        key: 'resize',
        value: function resize() {
            this._subViews.forEach(function (view) {
                return view.resize();
            });
            _get(ContainerView.prototype.__proto__ || Object.getPrototypeOf(ContainerView.prototype), 'resize', this).call(this);
        }

        /* ==========================
          Private Methods
          ========================== */

        /**
         *
         * @param {BaseView} view - the sub-view to register with this as a parent
         * @private
         */

    }, {
        key: '_registerSubView',
        value: function _registerSubView(view) {

            if (!(view instanceof _BaseView3.default)) {
                throw new Error('Attempting to add a sub-view to the container that does not inherit from BaseView');
            }

            // only one copy of each view
            if (!(0, _includes2.default)(this._subViews, view)) {
                this._subViews.push(view);
            }

            if (!this.el.contains(view.el)) {
                console.warn('Adding sub-view who\'s DOM element isn\'t contained in this.el');
            }
        }

        /**
         *  Remove sub-view from internal array
         * @param view
         * @private
         */

    }, {
        key: '_unregisterSubView',
        value: function _unregisterSubView(view) {
            var viewIndex = this._subViews.indexOf(view);

            if (viewIndex > -1) {
                this._subViews.splice(viewIndex, 1);
            }
        }
    }]);

    return ContainerView;
}(_BaseView3.default);

exports.default = ContainerView;

},{"./BaseView":258,"lodash/includes":190}],260:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseView2 = require('../BaseView');

var _BaseView3 = _interopRequireDefault(_BaseView2);

var _ImageLoader = require('../../net/ImageLoader');

var _ImageLoader2 = _interopRequireDefault(_ImageLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // UZIK Depedencies


// Hidden consts

/**
 *
 *
 *
 */
var SpriteAnimator = function (_BaseView) {
    _inherits(SpriteAnimator, _BaseView);

    function SpriteAnimator(el, options) {
        _classCallCheck(this, SpriteAnimator);

        /**
         * Save rendering context reference
         * @type {CanvasRenderingContext2D}
         */
        var _this = _possibleConstructorReturn(this, (SpriteAnimator.__proto__ || Object.getPrototypeOf(SpriteAnimator)).call(this, el, options));

        _this.drawingContext = _this.el.getContext('2d');

        // HiDPI support
        _this.drawingContext.scale(1, 1);

        /**
         * Calc frame duration with FPS.
         * @type {number}
         */
        _this.frameDuration = 1000 / options.fps;

        /**
         * Get total number of frames. We can't calc this automatically.
         * @type {number}
         */
        _this.numFrames = options.numFrames;

        /**
         * Loop in point is the frame to loop from. If this value is -1, the sprite will not loop
         * @type {number}
         */
        _this.loop = options.loop === false ? -1 : options.loop || 0;

        _this.width = _this.el.width;
        _this.height = _this.el.height;

        _this._currentFrame = 0;
        _this.isPlaying = false;

        _this.imageLoader = new _ImageLoader2.default(options.url);
        _this.imageLoader.promise.then(function (img) {

            _this.source = img.data;

            _this.sourceCols = Math.floor(_this.source.width / _this.width);
            _this.sourceRows = Math.floor(_this.source.height / _this.height);

            if (options.autoplay || _this._playAfterLoad) {
                _this.play();
            }
        });

        return _this;
    }

    /* ==========================
      Getters and setters
      ========================== */

    _createClass(SpriteAnimator, [{
        key: 'play',


        /* ==========================
          Public Methods
          ========================== */

        value: function play() {
            var _this2 = this;

            if (this.imageLoader.status !== 'complete') {
                this._playAfterLoad = true;
                return;
            }

            this.isPlaying = true;

            if (!this.queuedFrame) {
                this.queuedFrame = requestAnimationFrame(function () {
                    if (isNaN(_this2.lastRender) || Date.now() - _this2.lastRender > _this2.frameDuration) {
                        _this2._render();
                    }

                    _this2.queuedFrame = null; // empty ref
                    if (_this2.isPlaying) _this2.play();
                });
            }
        }
    }, {
        key: 'pause',
        value: function pause() {

            this.isPlaying = false;

            if (this.queuedFrame) {
                window.cancelAnimationFrame(this.queuedFrame);
                this.queuedFrame = null;
                this._playAfterLoad = false; // in case the sprite is played and paused before load
            }
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.pause();
            _get(SpriteAnimator.prototype.__proto__ || Object.getPrototypeOf(SpriteAnimator.prototype), 'destroy', this).call(this);
        }

        /* ==========================
          Private Methods
          ========================== */

    }, {
        key: '_render',
        value: function _render() {
            var frame = this._currentFrame + 1;

            if (frame >= this.numFrames - 1) {

                if (this.loop < 0) {
                    this.pause();
                    this._currentFrame = 0;
                    return;
                } else {
                    frame = this.loop;
                }
            }

            this.drawingContext.clearRect(0, 0, this.width, this.height);

            var x = Math.floor(frame % this.sourceCols);
            var y = Math.floor(frame / this.sourceCols);

            this.drawingContext.drawImage(this.source, x * this.width, y * this.height, this.width, this.height, 0, 0, this.width, this.height);

            this._currentFrame = frame;
            this.lastRender = Date.now();
        }

        /* ==========================
          Event Handlers
          ========================== */

    }, {
        key: '_childClickHandler',
        value: function _childClickHandler() {}
    }, {
        key: 'currentFrames',
        get: function get() {
            return this._currentFrame;
        }
    }, {
        key: 'currentFrame',
        set: function set(value) {
            this._currentFrame = value - 1;
            this._render();
        }
    }]);

    return SpriteAnimator;
}(_BaseView3.default);

exports.default = SpriteAnimator;

},{"../../net/ImageLoader":270,"../BaseView":258}],261:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Simple function to empty an element
 * @param {Element} el - DOMElement to empty by removing all it's children.
 */
var empty = function empty(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
};

exports.default = empty;

},{}],262:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Find the first parent that is scrollable. in most cases this will be the document itself.
 * @param {Element} el - The element we need to find the scroll parent for
 * @returns {Element}
 */
function getScrollParent(el) {

    // Default is HTML tag
    var scrollParent = document.documentElement;

    var elIter = el;
    while (elIter.parentNode && elIter !== document.documentElement) {
        elIter = elIter.parentNode;

        if (/(auto|scroll)/.test(window.getComputedStyle(elIter).overflowY)) {
            scrollParent = elIter;
            break;
        }
    }

    return scrollParent;
}

exports.default = getScrollParent;

},{}],263:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _isElement = require('lodash/isElement');

var _isElement2 = _interopRequireDefault(_isElement);

var _isString = require('lodash/isString');

var _isString2 = _interopRequireDefault(_isString);

var _indexOf = require('lodash/indexOf');

var _indexOf2 = _interopRequireDefault(_indexOf);

var _findIndex = require('lodash/findIndex');

var _findIndex2 = _interopRequireDefault(_findIndex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Get index of searchCriteria in a collection of nodes (default is searchCritera's siblings
 * @param {Element|string} searchCriteria - An element or CSS selector to find an element
 * @param {Array<Element>} collection - The array of nodes to search in.
 * @returns {number} Index of the search criteria or -1 if the searchCritera was not found in this collection
 */
var index = function index(searchCriteria, collection) {

    var index = -1;

    // if collection parameter isn't present or an element, assume we want to find it's place among the other children of it's parent.
    if (!collection || !(0, _isElement2.default)(collection)) {
        collection = Array.from(searchCriteria.parentNode.children);
    }

    // check the collection is an array
    if ((0, _isArray2.default)(collection)) {

        // search as literal object
        if ((0, _isElement2.default)(searchCriteria)) {
            index = (0, _indexOf2.default)(collection, searchCriteria);
            // search as CSS selector
        } else if ((0, _isString2.default)(searchCriteria)) {
            index = (0, _findIndex2.default)(collection, function (item) {
                return item.matches(searchCriteria);
            });
        } else {
            throw new Error('Search criteria must be an element or a String');
        }
    } else {
        throw new Error('Trying to get an index in a non-Array collection');
    }

    return index;
};

exports.default = index;

},{"lodash/findIndex":180,"lodash/indexOf":191,"lodash/isArray":193,"lodash/isElement":197,"lodash/isString":205}],264:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Remove multiple classes from an Element. Supports removing classes with `*` wildcard
 *
 * @param {Element} el - DOM element to remove classes from
 * @param {...string} patterns - One or more class patterns. Patterns must be CSS class names but can also contain `*` as a wildcard.
 */
var removeClasses = function removeClasses(el) {

    // save classes to avoid transforming the className of the el multiple times
    var classes = el.className;

    for (var _len = arguments.length, patterns = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        patterns[_key - 1] = arguments[_key];
    }

    patterns.forEach(function (pattern) {

        // replace wildcard with regex, add space matcher after for elements with multiple classes
        var patternRegex = new RegExp(pattern.replace('*', '[a-zA-Z0-9-_]+') + '\\s?');

        // remove classes using Regex
        classes = classes.replace(patternRegex, '');
    });

    // re assign new classes to the element
    el.className = classes;
};

exports.default = removeClasses;

},{}],265:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Turns a string representing one or more DOM elements into usable objects.
 * @param {string} sourceString
 * @returns {Element|DocumentFragment} The DOM representation of the string. If multiple root tags are present in the
 *     string, it will return a DocumentFragment
 */
var stringToElement = function stringToElement(sourceString) {
    // create a dummy element that is used
    var elementIterator = document.createElement("div");
    var i = void 0;

    // Throw the string into HTML
    elementIterator.innerHTML = sourceString;

    // If there are multiple root elements.
    if (elementIterator.children.length > 1) {
        // return document fragment
        var docFrag = document.createDocumentFragment();
        while (i = elementIterator.firstChild) {
            docFrag.appendChild(i);
        }

        return docFrag;
    } else {
        // just return first element
        return elementIterator.firstElementChild;
    }
};

exports.default = stringToElement;

},{}],266:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getScrollParent = require('./dom/getScrollParent');

var _getScrollParent2 = _interopRequireDefault(_getScrollParent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getDocumentRect = function getDocumentRect(el) {

    var elRect = el.getBoundingClientRect();

    var scrollEl = (0, _getScrollParent2.default)(el);

    return {
        top: elRect.top + scrollEl.scrollTop,

        left: elRect.left + scrollEl.scrollTop,

        width: elRect.width,
        height: elRect.height,

        right: elRect.right + scrollEl.scrollLeft,
        bottom: elRect.bottom + scrollEl.scrollTop
    };
};

exports.default = getDocumentRect;

},{"./dom/getScrollParent":262}],267:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Point = function () {
    function Point(x, y) {
        var angle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
        var distance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;

        _classCallCheck(this, Point);

        this.x = x;
        this.y = y;

        // Save optional angle and distance
        this.angle = angle;
        this.distance = distance;
    }

    _createClass(Point, [{
        key: "toPolar",
        value: function toPolar() {

            // calculate polar coordinates if they weren't supplied to the constructor
            if (isNaN(this.angle) || isNaN(this.distance)) {
                this.distance = Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
                this.angle = Math.atan2(this.y, this.x);
            }

            return {
                angle: this.angle,
                distance: this.distance
            };
        }
    }]);

    return Point;
}();

/**
 *
 * @param {Point} a
 * @param {Point} b
 */


Point.distance = function (a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    return Math.sqrt(x * x + y * y);
};

exports.default = Point;

},{}],268:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EventTarget2 = require('../core/EventTarget');

var _EventTarget3 = _interopRequireDefault(_EventTarget2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Keyboard class provides a small abstraction layer to make Keyboard events more EventTarget friendly
 *
 */
var Keyboard = function (_EventTarget) {
  _inherits(Keyboard, _EventTarget);

  /**
   *
   * @param {Element} [target=window.document] - The element to listen to events to. Defaults to the document.
   */
  function Keyboard() {
    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.document;

    _classCallCheck(this, Keyboard);

    /**
     * DOM event target
     * @type {Element}
     */
    var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this));

    _this.target = target;

    /**
     *
     * @type {{press: (function(event:Event)), down: (function(event:Event))}}
     * @private
     */
    _this._keyboardEvents = {
      press: _this._keyPressHandler.bind(_this),
      down: _this._keyDownHandler.bind(_this)
    };

    target.addEventListener('keypress', _this._keyboardEvents.press);
    target.addEventListener('keydown', _this._keyboardEvents.down);

    return _this;
  }

  /**
   * Stop listening for events
   */


  _createClass(Keyboard, [{
    key: 'destroy',
    value: function destroy() {
      this.target.removeEventListener('keypress', this._keyboardEvents.press);
      this.target.removeEventListener('keydown', this._keyboardEvents.down);
    }

    /**
     * Keypress handler
     * @param {Event} event - DOM Event object
     * @emits {Event} Native event
     * @private
     */

  }, {
    key: '_keyPressHandler',
    value: function _keyPressHandler(event) {
      // forward event
      this.trigger('press', event);
    }

    /**
     * Keydown event. Adds symbol to event object before forwarding it.
     * @param {Event} event - DOM event
     * @emits {Event} Native event
     * @private
     */

  }, {
    key: '_keyDownHandler',
    value: function _keyDownHandler(event) {

      // get char
      event.symbol = Keyboard.codes[event.keyCode];

      // save latest points
      this.trigger('down', event);
    }
  }]);

  return Keyboard;
}(_EventTarget3.default);

// constant type values for comparison


Keyboard.keys = {};
Keyboard.keys.ESC = 27;

// Inverse lookup for keyboard values;
Keyboard.codes = [];
Keyboard.codes[27] = 'ESC';

exports.default = Keyboard;

},{"../core/EventTarget":257}],269:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _first3 = require('lodash/first');

var _first4 = _interopRequireDefault(_first3);

var _last3 = require('lodash/last');

var _last4 = _interopRequireDefault(_last3);

var _defaults = require('lodash/defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _EventTarget2 = require('../core/EventTarget');

var _EventTarget3 = _interopRequireDefault(_EventTarget2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * These constants represent gestures that the touch instance will try to match
 *
 *
 */
var GESTURES_DEFINITIONS = {

    /*
      SWIPE DETECTOR
      */
    'swipe': {
        detect: function detect(events, options) {

            var detection = null;

            // only detect swipes with multiple events
            if (events.length > 1) {
                var firstEvent = (0, _first4.default)(events);
                var lastEvent = (0, _last4.default)(events);

                // Swipe with one finger only.
                if (!isMultiTouch(firstEvent) && !isMultiTouch(lastEvent)) {

                    var deltaX = lastEvent.touches[0].screenX - firstEvent.touches[0].screenX;
                    var deltaY = lastEvent.touches[0].screenY - firstEvent.touches[0].screenY;

                    var aDeltaX = Math.abs(deltaX);
                    var aDeltaY = Math.abs(deltaY);

                    // determine direction by comparison
                    if (aDeltaX > 2 * aDeltaY && aDeltaX > options.swipeThreshold) {

                        detection = {
                            axis: 'x',
                            distance: {
                                x: deltaX,
                                y: deltaY
                            }
                        };
                    } else if (options.verticalSwipe && aDeltaY > 2 * aDeltaX) {

                        detection = {
                            axis: 'y',
                            distance: {
                                x: deltaX,
                                y: deltaY
                            }
                        };
                    }
                }
            }

            return detection;
        },
        dispatchEvent: function dispatchEvent(target, eventData) {

            // create event
            var swipeEvent = document.createEvent('CustomEvent');
            swipeEvent.initCustomEvent('swipe', true, false, null);
            swipeEvent.distance = eventData.distance;
            swipeEvent.axis = eventData.axis;

            // dispatch it through the DOM
            target.dispatchEvent(swipeEvent);
        },

        repeat: false
    },

    /*
      ZOOM DETECTOR
      */
    'zoom': {
        detect: function detect(events) {
            var detection = null;

            // only detect zooms with multiple events
            if (events.length >= 2) {

                var _first = events[events.length - 2];
                var _last = events[events.length - 1];

                // detect multiple multi touch events
                if (isMultiTouch(_first) && isMultiTouch(_last)) {

                    // get distances for both points
                    var firstDistance = touchDistance(_first);
                    var lastDistance = touchDistance(_last);

                    // Zoom is onlt when fingers expand away from each other
                    if (firstDistance < lastDistance) {

                        return {
                            distance: lastDistance,
                            center: touchCenter(_last)
                        };
                    }
                }
            }

            return detection;
        },
        dispatchEvent: function dispatchEvent(target, eventData) {

            // create event
            var swipeEvent = document.createEvent('CustomEvent');
            swipeEvent.initCustomEvent('zoom', true, false, null);
            swipeEvent.distance = eventData.distance;

            // dispatch it through the DOM
            target.dispatchEvent(swipeEvent);
        },

        repeat: true
    },

    'pinch': {
        detect: function detect(events) {
            var detection = null;

            // only detect zooms with multiple events
            if (events.length >= 2) {

                var _first2 = events[events.length - 2];
                var _last2 = events[events.length - 1];

                // detect multiple multi touch events
                if (isMultiTouch(_first2) && isMultiTouch(_last2)) {

                    // get distances for both points
                    var firstDistance = touchDistance(_first2);
                    var lastDistance = touchDistance(_last2);

                    if (firstDistance > lastDistance) {

                        return {
                            distance: lastDistance,
                            center: touchCenter(_last2)
                        };
                    }
                }
            }

            return detection;
        },
        dispatchEvent: function dispatchEvent(target, eventData) {

            // create event
            var swipeEvent = document.createEvent('CustomEvent');
            swipeEvent.initCustomEvent('zoom', true, false, null);
            swipeEvent.distance = eventData.distance;

            // dispatch it through the DOM
            target.dispatchEvent(swipeEvent);
        },

        repeat: true
    }

};

/**
 * Determines if event is detecting mutliple touch points.
 * @param {TouchEvent} event - The TouchEvent to test
 * @returns {boolean}
 */
function isMultiTouch(event) {
    return event.touches.length > 1;
}

/**
 * Get distance between two touches of an event. Simple square root.
 * @param {TouchEvent} event - A multi-touch native touch event
 * @returns {number} Distance in pixels between touches
 */
function touchDistance(event) {

    var a = event.touches[0];
    var b = event.touches[1];

    return Math.sqrt(Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2));
}

/**
 * Get center of touch event's touches.
 * @param {TouchEvent} event - The native event to analyse.
 * @return {{x: number, y: number}} The center the supplied event's touches. If there is a single touch, it will return it's coordinates.
 */
function touchCenter(event) {
    if (isMultiTouch(event)) {

        var a = event.touches[0];
        var b = event.touches[1];

        var aX = a.clientX;
        var aY = a.clientY;

        var bX = b.clientX;
        var bY = b.clientY;

        //         start
        var x = aX + (bX - aX) / 2;
        var y = aY + (bY - aY) / 2;

        return {
            x: x,
            y: y
        };
    } else {
        var touch = event.touches[0];

        return {
            x: touch.clientX,
            y: touch.clientY
        };
    }
}

/**
 * Class to track simple touch gestures. Inspired partly by hammer.js
 *
 * @TODO make gestures optional, moving detectors into separate class
 * @todo configure gesture detectors to avoid useless operations on multiple objects
 *
 */

var Touch = function (_EventTarget) {
    _inherits(Touch, _EventTarget);

    /**
     * @param {Element} target - Target of touch events to listen to
     * @param {Object} options - Options for class behavior. See defaults for more info.
     */
    function Touch(target) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Touch);

        /**
         * Save event target
         * @type {Element}
         */
        var _this = _possibleConstructorReturn(this, (Touch.__proto__ || Object.getPrototypeOf(Touch)).call(this));

        _this.target = target;

        /**
         * Saved options with default values.
         * @type {Object}
         */
        _this.options = (0, _defaults2.default)(options, Touch.defaultOptions);

        // create and store bound functions that are used as event listeners
        _this._touchEvents = {
            start: _this._touchStartHandler.bind(_this),
            move: _this._touchMoveHandler.bind(_this),
            end: _this._touchEndHandler.bind(_this)
        };

        _this.target.addEventListener('touchstart', _this._touchEvents.start);
        _this.target.addEventListener('touchmove', _this._touchEvents.move);
        _this.target.addEventListener('touchend', _this._touchEvents.end);

        // To help handling whole touch cycle (start -> move -> end) listen to the end event on the window too.
        if (_this.options.bindWindowEnd) {
            window.addEventListener('touchend', _this._touchEvents.end);
        }

        return _this;
    }

    /**
     * Get distance between first and last event points on both axis
     * @return {Number} Distance in pixels between first and last points currently tracked. Based on the first touch of a multi touch events
     */


    _createClass(Touch, [{
        key: 'destroy',

        /**
         * Remove native events and cleanup
         */
        value: function destroy() {

            this.target.removeEventListener('touchstart', this._touchEvents.start);
            this.target.removeEventListener('touchmove', this._touchEvents.move);
            this.target.removeEventListener('touchend', this._touchEvents.end);

            if (this.options.bindWindowEnd) {
                window.removeEventListener('touchend', this._touchEvents.end);
            }
        }

        /* =======
          Private methods
          ======== */

        /**
         * Start tracking touch events on the target element.
         *
         * @param {TouchEvent} event - Native DOM event
         * @emits {TouchEvent} Native DOM event
         * @private
         */

    }, {
        key: '_start',
        value: function _start(event) {

            // in case 'end()' isn't called properly. Probably shouldn't happen.
            if (this.isTouched) this.end();

            /**
             * flag to indicate if there is acutally a touch on the device.
             * @type {boolean}
             */
            this.isTouched = true;

            /**
             * Internal buffer of events to analyse
             * @type {TouchEvent[]}
             * @private
             */
            this._eventBuffer = [event];

            /**
             * Internal list of gestures currently being detected
             * @type {{}}
             * @private
             */
            this._currentGestures = {};

            this.trigger('start', event);
        }

        /**
         *
         * @param {TouchEvent} event - Native DOM event
         * @private
         */

    }, {
        key: '_move',
        value: function _move(event) {
            this._eventBuffer.push(event);

            // Run detectors
            // TODO move to sub-class
            for (var gesture in GESTURES_DEFINITIONS) {

                var gestureDef = GESTURES_DEFINITIONS[gesture];
                var gestureInfo = gestureDef.detect(this._eventBuffer, this.options);

                // if gesture detected
                if (gestureInfo) {

                    // prevent repeat events on gestures that only should happen once per touch cycle (swipe for example). Could also be handled in touchend?
                    if (gestureDef.repeat || !gestureDef.repeat && !this._currentGestures[gesture]) {

                        // attempt to prevent default
                        event.preventDefault();

                        // save gesture
                        this._currentGestures[gesture] = gestureInfo;

                        if (this.options.domEvents) {
                            gestureDef.dispatchEvent(this.target, gestureInfo);
                        }

                        this.trigger(gesture, gestureInfo);
                    }
                }
            }

            this.trigger('move', event);
        }

        /**
         * End of touch. Reset internal vars
         * @param event - Native DOM event
         * @emits {TouchEvent} - Native DOM event
         * @private
         */

    }, {
        key: '_end',
        value: function _end(event) {

            // Trigger event before disposing of saved state
            this.trigger('end', event);

            this._eventBuffer = [];
            this.isTouched = false;
        }

        /* =======
          Event Handlers
          ======== */

        /**
         * Native start event handler
         * @param event
         * @private
         */

    }, {
        key: '_touchStartHandler',
        value: function _touchStartHandler(event) {

            // standard behviour is too disable scrolling and zooming on multi touch
            if (event.touches.length > 1) {
                event.preventDefault();
            }

            // if we're already touching, and another finger starts touching, treat it as a move
            if (this.isTouched) {
                this._move(event);
            } else {
                this._start(event);
            }
        }

        /**
         * Native move event handler
         * @param event
         * @private
         */

    }, {
        key: '_touchMoveHandler',
        value: function _touchMoveHandler(event) {

            // standard behviour is too disable scrolling and zooming on multi touch
            if (event.touches.length > 1) {
                event.preventDefault();
            }

            this._move(event);
        }

        /**
         * Native end event handker
         * @param event
         * @private
         */

    }, {
        key: '_touchEndHandler',
        value: function _touchEndHandler(event) {
            this._end(event);
        }
    }, {
        key: 'distance',
        get: function get() {

            // only return a number if there is a proper distance
            if (!this._eventBuffer || this._eventBuffer.length < 2) {
                return NaN;
            } else {

                var a = this._eventBuffer[0].touches[0];
                var b = this._eventBuffer[this._eventBuffer.length - 1].touches[0];

                return Math.sqrt(Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2));
            }
        }

        /**
         * Get distance between first and last event points on the X axis
         * @return {Number} Distance in pixels between first and last points currently tracked. Based on the first touch of a multi touch events
         */

    }, {
        key: 'distanceX',
        get: function get() {
            // only return a number if there is a proper distance
            if (!this._eventBuffer || this._eventBuffer.length < 2) {
                return NaN;
            } else {

                var a = this._eventBuffer[0].touches[0];
                var b = this._eventBuffer[this._eventBuffer.length - 1].touches[0];

                return b.clientX - a.clientX;
            }
        }

        /**
         * Get distance between first and last event points on the Y axis
         * @return {Number} Distance in pixels between first and last points currently tracked. Based on the first touch of a multi touch events
         */

    }, {
        key: 'distanceY',
        get: function get() {
            // only return a number if there is a proper distance
            if (!this._eventBuffer || this._eventBuffer.length < 2) {
                return NaN;
            } else {

                var a = this._eventBuffer[0].touches[0];
                var b = this._eventBuffer[this._eventBuffer.length - 1].touches[0];

                return b.clientY - a.clientY;
            }
        }
    }]);

    return Touch;
}(_EventTarget3.default);

/**
 * @static
 * @type {{verticalSwipe: boolean, swipeThreshold: number, domEvents: boolean}}
 */


Touch.defaultOptions = {

    /**
     * Dected y axis when detecting swipes. Very often we don't want to block scrolling.
     */
    verticalSwipe: false,

    /**
     * Minimum distance to trigger swipe event
     */
    swipeThreshold: 10,

    /**
     * Will create and trigger custom bubbling DOM events for gestures.
     */
    domEvents: true

};

exports.default = Touch;

},{"../core/EventTarget":257,"lodash/defaults":174,"lodash/first":183,"lodash/last":211}],270:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _defaults = require('lodash/defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _Loader2 = require('./Loader');

var _Loader3 = _interopRequireDefault(_Loader2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ImageLoader = function (_Loader) {
    _inherits(ImageLoader, _Loader);

    function ImageLoader(url, srcset, sizes) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

        _classCallCheck(this, ImageLoader);

        // make sure it's paused so we can change paused status
        var paused = options.paused;

        var _this = _possibleConstructorReturn(this, (ImageLoader.__proto__ || Object.getPrototypeOf(ImageLoader)).call(this, url, (0, _defaults2.default)({ paused: true }, options)));

        _this.srcset = srcset;
        _this.sizes = sizes;

        if (!paused) {
            _this.load();
        }

        return _this;
    }

    /**
     * Override load mechanism
     */


    _createClass(ImageLoader, [{
        key: 'load',
        value: function load() {
            var _this2 = this;

            var image = new Image();

            image.onload = function () {
                _this2.status = _Loader3.default.STATUS.LOADING;
                _this2._promiseResolve({ url: _this2.url, data: image, rawData: image });
                _this2._handleLoadComplete();
            };

            image.onerror = function () {
                _this2._promiseReject('Could not load Image : ');
                _this2._handleLoadComplete();
            };

            // If already loaded call load handler manually
            if (image.complete === true && image.width && image.height) {
                setTimeout(function () {
                    return image.onload();
                }, 0);
            }

            // Add properties to start the load
            if (this.srcset) image.srcset = this.srcset;
            if (this.sizes) image.sizes = this.sizes;
            image.src = this.url;
        }
    }]);

    return ImageLoader;
}(_Loader3.default);

exports.default = ImageLoader;

},{"./Loader":271,"lodash/defaults":174}],271:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _xhr = require('xhr');

var _xhr2 = _interopRequireDefault(_xhr);

var _EventTarget2 = require('../core/EventTarget');

var _EventTarget3 = _interopRequireDefault(_EventTarget2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Zimple dependencies


var loaderID = 0;

var Loader = function (_EventTarget) {
    _inherits(Loader, _EventTarget);

    function Loader(url) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { paused: false, parseBody: true };

        _classCallCheck(this, Loader);

        var _this = _possibleConstructorReturn(this, (Loader.__proto__ || Object.getPrototypeOf(Loader)).call(this));

        _this.url = url;
        _this.id = options.id || 'loader-' + loaderID++;

        _this.options = options;

        // Load progress, at construct, it is always 0
        _this.progress = 0;

        // Create Promise for this loader, and save the resolve and reject functions for later
        _this.promise = new Promise(function (resolve, reject) {
            _this._promiseResolve = resolve;
            _this._promiseReject = reject;
        });

        // Start or pause loading
        if (_this.options.paused) {
            _this.status = Loader.STATUS.PAUSED;
        } else {
            _this.load();
        }

        return _this;
    }

    _createClass(Loader, [{
        key: 'load',
        value: function load() {
            var _this2 = this;

            // detect type of load
            this.request = (0, _xhr2.default)({
                url: this.url,
                beforeSend: function beforeSend(nativeXHR) {
                    // attach progress event. you never know
                    nativeXHR.addEventListener('progress', function (event) {
                        _this2._handleLoadProgress(event); // force context to instance of preloader
                    });
                }
            }, function (err, response, body) {

                var statusCodeCategory = parseInt(response.statusCode.toString()[0]);

                if (err) {

                    _this2._promiseReject(new Error(response.text));
                    _this2._handleLoadComplete();
                } else if (_.includes([4, 5], statusCodeCategory)) {} else {

                    // always save a copy of the raw data
                    _this2.rawData = body;

                    // might want to parse the body
                    if (_this2.options.parseBody) {

                        // in case there isn't an extension, resort to content-type sniffing and forcing the type
                        if (_this2.url.lastIndexOf('.') < _this2.url.lastIndexOf('/')) {
                            var contentType = response.headers['content-type'];
                            var type = void 0;
                            if (contentType.toLowerCase().includes('application/json')) {
                                type = 'json';
                            }

                            _this2.data = Loader.parseResponseBody(_this2.url, body, type);
                        } else {
                            _this2.data = Loader.parseResponseBody(_this2.url, body);
                        }
                    } else {
                        _this2.data = body;
                    }

                    _this2._promiseResolve({ url: _this2.url, data: _this2.data, rawData: body });
                    _this2._handleLoadComplete();
                }
            });

            this.status = Loader.STATUS.LOADING;

            return this.promise;
        }
    }, {
        key: '_handleLoadProgress',
        value: function _handleLoadProgress(event) {
            if (event.lengthComputable) {
                this.progress = event.loaded / event.total;
                this.trigger('progress', { progress: this.progress });
            }
        }

        /**
         * Handle end of loading. including changing loader status and firing events
         * @protected
         */

    }, {
        key: '_handleLoadComplete',
        value: function _handleLoadComplete() {

            this.status = Loader.STATUS.COMPLETE;
            this.progress = 1;
            this.trigger('complete', { target: this });
        }
    }]);

    return Loader;
}(_EventTarget3.default);

/**
 * Helper to return a more usable object from the preloader. Simple detection based on file extension
 *
 * @param url the loaded file's URL
 * @param body th loaded file's content
 * @param forceType sometimes we need to force parsing of a certain type regardless of it's file name
 */


Loader.parseResponseBody = function (url, body) {
    var forceType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


    var returnObject = void 0;

    var ext = forceType !== null ? forceType : url.substr(url.lastIndexOf('.') + 1);

    switch (ext) {
        case 'js':
            returnObject = document.createElement('script');
            returnObject.textContent = body;
            break;
        case 'json':
            returnObject = JSON.parse(body);
            break;
        case 'svg':
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = body;
            returnObject = tempDiv.firstChild;
            break;
        default:
            // pass through
            returnObject = body;
    }

    return returnObject;
};

Loader.STATUS = {
    PAUSED: 'paused',
    LOADING: 'loading',
    COMPLETE: 'complete'
};

exports.default = Loader;

},{"../core/EventTarget":257,"xhr":232}],272:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConfigClass = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _defaults = require('lodash/defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _startsWith = require('lodash/startsWith');

var _startsWith2 = _interopRequireDefault(_startsWith);

var _endsWith = require('lodash/endsWith');

var _endsWith2 = _interopRequireDefault(_endsWith);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultConfig = {
    env: 'prod',
    basePath: '/',
    assetPath: '/'
};

var ConfigClass = function () {
    function ConfigClass() {
        _classCallCheck(this, ConfigClass);
    }

    _createClass(ConfigClass, [{
        key: 'initialize',
        value: function initialize(bootstrapConfig) {
            this.baseConfig = {};

            // merge default config
            (0, _defaults2.default)(this.baseConfig, bootstrapConfig, defaultConfig);

            // strip first slashes on sub dir paths
            this.baseConfig.assetPath = (0, _startsWith2.default)(this.baseConfig.assetPath, '/') ? this.baseConfig.assetPath.substr(1) : this.baseConfig.assetPath;

            // ensure trailing slash
            this.baseConfig.basePath += (0, _endsWith2.default)(this.baseConfig.basePath, '/') ? '' : '/';
            this.baseConfig.assetPath += (0, _endsWith2.default)(this.baseConfig.assetPath, '/') ? '' : '/';

            // auto detect protocol://domain:port
            this.baseConfig.origin = location.protocol + '//' + location.hostname + (location.port ? ':' + location.port : '');
        }
    }, {
        key: 'env',
        get: function get() {
            return this.baseConfig.env;
        }
    }, {
        key: 'assetPath',
        get: function get() {
            return this.baseConfig.origin + this.baseConfig.basePath + this.baseConfig.assetPath;
        }
    }, {
        key: 'basePath',
        get: function get() {
            return this.baseConfig.origin + this.baseConfig.basePath;
        }
    }]);

    return ConfigClass;
}();

var Config = new ConfigClass();

exports.default = Config;
exports.ConfigClass = ConfigClass;

},{"lodash/defaults":174,"lodash/endsWith":176,"lodash/startsWith":215}],273:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tracker = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isElement = require('lodash/isElement');

var _isElement2 = _interopRequireDefault(_isElement);

var _debounce = require('lodash/debounce');

var _debounce2 = _interopRequireDefault(_debounce);

var _findIndex = require('lodash/findIndex');

var _findIndex2 = _interopRequireDefault(_findIndex);

var _EventTarget3 = require('../core/EventTarget');

var _EventTarget4 = _interopRequireDefault(_EventTarget3);

var _WindowManager = require('../utils/WindowManager');

var _WindowManager2 = _interopRequireDefault(_WindowManager);

var _Style = require('../utils/Style');

var _Style2 = _interopRequireDefault(_Style);

var _getDocumentRect = require('../display/getDocumentRect');

var _getDocumentRect2 = _interopRequireDefault(_getDocumentRect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tracker = function (_EventTarget) {
    _inherits(Tracker, _EventTarget);

    function Tracker(el) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        _classCallCheck(this, Tracker);

        var _this = _possibleConstructorReturn(this, (Tracker.__proto__ || Object.getPrototypeOf(Tracker)).call(this));

        _this.el = el;
        _this.offset = offset;
        _this.side = null;
        _this.state = null;

        return _this;
    }

    return Tracker;
}(_EventTarget4.default);

/**
 *
 *  Scrolling tracker allows us to know when an element is off screen, overlapping the screen or completely on screen.
 *  It also allows us to know which side the center of the element is (top or bottom) *
 *
 * @todo untrack elements
 *
 */


var ScrollingTracker = function (_EventTarget2) {
    _inherits(ScrollingTracker, _EventTarget2);

    function ScrollingTracker() {
        var scrollContainer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

        _classCallCheck(this, ScrollingTracker);

        /**
         * @type {Window}
         */
        var _this2 = _possibleConstructorReturn(this, (ScrollingTracker.__proto__ || Object.getPrototypeOf(ScrollingTracker)).call(this));

        _this2.scrollContainer = scrollContainer;

        _this2._trackers = [];

        if (scrollContainer === window) {
            _this2.listenTo(_WindowManager2.default, 'scroll', _this2._windowScrollHandler);
        } else {
            // create our own scroll handler if scrolling an element
            _this2._scrollHandler = _this2._windowScrollHandler.bind(_this2);
            scrollContainer.addEventListener('scroll', _this2._scrollHandler);
        }

        _this2.listenTo(_WindowManager2.default, 'resize', _this2._windowResizeHandler);

        return _this2;
    }

    /*
      Public methods
      */

    /**
     * Start tracking the scrollPosition of an element
     * @param {Element} el - The element to track.
     * @param {Number} offset - A ratio of the total height
     * @returns {Tracker} A tracker object that will emit events
     */


    _createClass(ScrollingTracker, [{
        key: 'trackElement',
        value: function trackElement(el) {
            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;


            var tracker = new Tracker(el, offset);

            this._trackers.push(tracker);

            this.refreshElementMetrics(tracker);

            this._update(false);

            return tracker;
        }
    }, {
        key: 'untrackElement',
        value: function untrackElement(elOrTracker) {

            var trackerIndex = void 0;

            if (elOrTracker instanceof Tracker) {
                trackerIndex = this._trackers.indexOf(elOrTracker);
            } else {
                trackerIndex = (0, _findIndex2.default)(this._trackers, { el: elOrTracker });
            }
        }

        /**
         *
         * @param {Element|Tracker} elOrTracker - Element or Tracker object that needs to be refreshed
         */

    }, {
        key: 'refreshElementMetrics',
        value: function refreshElementMetrics(elOrTracker) {

            var trackers = void 0;

            if (!elOrTracker) {
                trackers = this._trackers;
            } else if ((0, _isElement2.default)(elOrTracker)) {
                trackers = this._trackers.find(function (tracker) {
                    return tracker === elOrTracker;
                });
            } else if (elOrTracker instanceof Tracker) {
                trackers = [elOrTracker];
            }

            trackers.forEach(function (tracker) {

                // Save & remove transforms
                var isInlineTransformStyle = /transform\s*:\s*[a-z0-9]+/i.test(tracker.el.getAttribute('style'));
                var isInlineTransitionStyle = /transition\s*:\s*[a-z0-9]+/i.test(tracker.el.getAttribute('style'));

                var currentTransform = _Style2.default.get(tracker.el, 'transform');
                var currentTransition = _Style2.default.get(tracker.el, 'transition');

                _Style2.default.set(tracker.el, {
                    transform: 'none',
                    transition: 'none'
                });

                // Measure and save metrics to tracker
                var elementMetrics = (0, _getDocumentRect2.default)(tracker.el);

                // apply offset
                var height = elementMetrics.height * tracker.offset;
                var top = elementMetrics.top + (elementMetrics.height - height) / 2;

                tracker.top = top;
                tracker.height = height;

                // re-apply Transforms and transitions if they were removed
                if (currentTransform && isInlineTransformStyle) {
                    _Style2.default.set(tracker.el, { transform: currentTransform });
                } else {
                    tracker.el.style.removeProperty('transform');
                }

                if (currentTransition || isInlineTransitionStyle) {
                    _Style2.default.set(tracker.el, { transition: currentTransition });
                } else {
                    tracker.el.style.removeProperty('transition');
                }
            });

            this._update(false);
        }

        /*
         Private methods
          */

    }, {
        key: '_getScrollContainerScrollTop',
        value: function _getScrollContainerScrollTop() {
            return this.scrollContainer === window ? _WindowManager2.default.scrollPosition.top : this.scrollContainer.scrollTop;
        }
    }, {
        key: '_getScrollContainerHeight',
        value: function _getScrollContainerHeight() {
            return this.scrollContainer === window ? _WindowManager2.default.height : this.scrollContainer.offsetHeight;
        }
    }, {
        key: '_update',
        value: function _update() {
            var _this3 = this;

            var triggerEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;


            var screenTop = this._getScrollContainerScrollTop();
            var screenHeight = this._getScrollContainerHeight();
            var screenBottom = screenTop + this._getScrollContainerHeight();

            this._trackers.forEach(function (tracker) {

                var currentState = tracker.state;
                var currentSide = tracker.side;
                var newState = void 0;
                var newSide = void 0;

                var trackerTop = tracker.top;
                var trackerBottom = tracker.top + tracker.height;

                // State checking :

                // Check if element is OFF screen
                if (screenBottom < trackerTop || // off and below
                screenTop > trackerBottom) {
                    // off and above

                    newState = ScrollingTracker.STATE.OFF;

                    // Check if element is OVERLAPPING the screen
                } else if (screenTop < trackerTop && screenBottom < trackerBottom || // overlap bottom
                screenTop > trackerTop && screenTop < trackerBottom && // overlap above
                !(screenTop > trackerTop && screenBottom < trackerBottom)) {
                    // when an element is higher than  the screen, this avoids it never becoming on {

                    newState = ScrollingTracker.STATE.OVERLAP;

                    // If element is neither OFF or OVERLAPPING, it must be ON
                } else {
                    newState = ScrollingTracker.STATE.ON;
                }

                // Side checking :
                newSide = trackerTop + tracker.height * 0.5 < screenTop + screenHeight * 0.5 ? ScrollingTracker.SIDE.ABOVE : ScrollingTracker.SIDE.BELOW;

                // Determine if state or side has actually changed
                var updateState = newState !== currentState;
                var updateSide = newSide !== currentSide;

                // save values to tracker before emitting events for consistency.
                tracker.state = newState;
                tracker.side = newSide;

                if (triggerEvents) {

                    if (updateState) {
                        var eventObject = {
                            state: newState,
                            target: tracker
                        };

                        tracker.trigger('state', eventObject);
                        tracker.trigger('state:' + newState, eventObject);
                        _this3.trigger('element:state', eventObject);
                    }

                    if (updateSide) {

                        var _eventObject = {
                            side: newSide,
                            target: tracker
                        };

                        tracker.trigger('side', _eventObject);
                        tracker.trigger('side:' + newSide, _eventObject);
                        _this3.trigger('element:side', _eventObject);
                    }
                }
            });
        }

        /*
         Event handlers
          */

        // TODO rename because of div scrolling support

    }, {
        key: '_windowScrollHandler',
        value: function _windowScrollHandler(event) {
            this._update();
        }
    }, {
        key: '_windowResizeHandler',
        value: function _windowResizeHandler(event) {
            this.refreshElementMetrics();
        }
    }]);

    return ScrollingTracker;
}(_EventTarget4.default);

// Position relateive to the viewport


ScrollingTracker.STATE = {
    ON: 'on',
    OFF: 'off',
    OVERLAP: 'overlap'
};

// Side, determine if the element is below or above the screen. This also depends on the element height
ScrollingTracker.SIDE = {
    ABOVE: 'above',
    BELOW: 'below'
};

ScrollingTracker.DIRECTION = {
    UP: -1,
    DOWN: 1
};

exports.default = ScrollingTracker;
exports.Tracker = Tracker;

},{"../core/EventTarget":257,"../display/getDocumentRect":266,"../utils/Style":274,"../utils/WindowManager":275,"lodash/debounce":173,"lodash/findIndex":180,"lodash/isElement":197}],274:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _capitalize = require('lodash/capitalize');

var _capitalize2 = _interopRequireDefault(_capitalize);

var _find = require('lodash/find');

var _find2 = _interopRequireDefault(_find);

var _isElement = require('lodash/isElement');

var _isElement2 = _interopRequireDefault(_isElement);

var _isString = require('lodash/isString');

var _isString2 = _interopRequireDefault(_isString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// browser prefixes
var PREFIXES = ['Webkit', 'Moz', 'MS', 'O'];

// Cache of modifier functions once the proper prefix has been found
var prefixedModifierCache = {};

// Test element for finding prefixed properties
var prefixTestEl = document.createElement('div');

/**
 * Create a prefixed aware CSS modifier for a property.
 *
 * Generated modifiers are stored in the cache declared above
 *
 * @param property
 * @private
 * @returns {function}
 */
function createModifier(property) {

    // get all prefixed properties (and un-prefixed in first position). prefixed properties are camel cased
    var prefixedProperties = [property].concat(PREFIXES.map(function (prefix) {
        return prefix + (0, _capitalize2.default)(property);
    }));

    // find the first acceptable property name
    var prefixedPropName = (0, _find2.default)(prefixedProperties, function (prop) {
        return prop in prefixTestEl.style;
    });

    // cache modifier to object
    prefixedModifierCache[property] = function (targetStyle, value) {
        targetStyle[prefixedPropName] = value;
    };

    return prefixedModifierCache[property];
}

/**
 * Style util to help setting and getting style properties
 *
 * @todo accept shorthand transform properties like x,y,scale,rotate.
 * @type {{set: Style.set, get: Style.get, addUnits: Style.addUnits, stripUnits: Style.stripUnits}}
 */
var Style = {

    /**
     * Set styles on an Element
     *
     * @param {Element} element - The element on which to set styles. Can also be the Element's style object directly.
     * @param {Object} properties - Object with properties as keys and values as
     */
    set: function set(element, properties) {

        var elementStyles = (0, _isElement2.default)(element) ? element.style : element;

        // treat properties as an object of csspropertyname : value pairs
        for (var prop in properties) {
            if (properties.hasOwnProperty(prop)) {

                // if a the value of this properties isn't already a string, format it.
                var specifiedValue = properties[prop];
                var finalValue = void 0;

                if (specifiedValue !== null) {
                    finalValue = (0, _isString2.default)(specifiedValue) ? specifiedValue : this.addUnits(prop, specifiedValue);
                } else {
                    finalValue = null;
                }

                // get cached or new modifier function and use it to modify element styles
                (prefixedModifierCache[prop] || createModifier(prop))(elementStyles, finalValue);
            }
        }
    },

    /**
     * Get style applied to this element
     *
     * TODO check on element.style object if we can detect !important rules someway
     *
     * @param element
     * @param property
     * @returns {string|number} the CSS value
     */
    get: function get(element, property) {
        return this.stripUnits(property, window.getComputedStyle(element)[property]);
    },

    /**
     * Add units to the CSS value if possible. usefull for specifying pixel values as numbers
     *
     * @param {string} property - name of the CSS property
     * @param {string|number} value - value of the property that isn't a String
     * @param {string} [units='px'] - CSS unit for the value.
     * @returns {string} Value with appropriate units. be
     */
    addUnits: function addUnits(property, value) {
        var units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'px';


        var formattedValue = void 0;

        switch (property) {
            case 'top':
            case 'right':
            case 'bottom':
            case 'left':
            case 'minWidth':
            case 'minHeight':
            case 'width':
            case 'height':
                formattedValue = value.toString() + units;
                break;

            case 'opacity':
                formattedValue = value;
                break;
        }

        // format to empty string
        if (formattedValue === null) formattedValue = '';

        return formattedValue;
    },

    /**
     * Strip units and return as a number if possible, otherwise return a string
     *
     * @param {string} property - the CSS property name
     * @param {*} value - CSS value as read from the browser.
     * @return {string|number} CSS value cast to number if possible
     */
    stripUnits: function stripUnits(property, value) {

        var formattedValue = void 0;

        switch (property) {
            case 'top':
            case 'right':
            case 'bottom':
            case 'left':
            case 'minWidth':
            case 'minHeight':
            case 'width':
            case 'height':
            case 'opacity':
                formattedValue = parseFloat(value);
                break;
        }

        return formattedValue;
    }

};

exports.default = Style;

},{"lodash/capitalize":170,"lodash/find":179,"lodash/isElement":197,"lodash/isString":205}],275:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WindowManagerClass = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _defaults = require('lodash/defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _isString = require('lodash/isString');

var _isString2 = _interopRequireDefault(_isString);

var _isNumber = require('lodash/isNumber');

var _isNumber2 = _interopRequireDefault(_isNumber);

var _isObject = require('lodash/isObject');

var _isObject2 = _interopRequireDefault(_isObject);

var _find = require('lodash/find');

var _find2 = _interopRequireDefault(_find);

var _findLast = require('lodash/findLast');

var _findLast2 = _interopRequireDefault(_findLast);

var _EventTarget2 = require('../core/EventTarget');

var _EventTarget3 = _interopRequireDefault(_EventTarget2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Cross platform function to get scroll position
var getScrollTop = function getScrollTop() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
};

var getScrollLeft = function getScrollLeft() {
    return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
};

var WindowManager = void 0;

var WindowManagerClass = function (_EventTarget) {
    _inherits(WindowManagerClass, _EventTarget);

    function WindowManagerClass() {
        _classCallCheck(this, WindowManagerClass);

        // Singleton check
        if (WindowManager) {
            throw new Error("WindowManager is a Singleton, an instance already exists");
        }

        return _possibleConstructorReturn(this, (WindowManagerClass.__proto__ || Object.getPrototypeOf(WindowManagerClass)).call(this));
    }

    /* ==========================
      Initialization function
      ========================== */


    _createClass(WindowManagerClass, [{
        key: 'initialize',
        value: function initialize(config) {

            if (!this.initialized) {
                this.config = (0, _defaults2.default)(config || {}, WindowManagerClass.defaultConfig);

                /**
                 * Array of breakpoints. You can not change breakpoints once they are set
                 * @type {Array}
                 */
                this.breakpoints = this.config.breakpoints;

                // Freeze breakpoints
                this.breakpoints.forEach(function (bp) {
                    return Object.freeze(bp);
                });

                // Create and save Event Handlers
                this._domEvents = {};
                this._domEvents.resize = (0, _throttle2.default)(this._resizeHandler.bind(this), this.config.resizeThrottle);
                this._domEvents.load = this._loadHandler.bind(this);
                this._domEvents.unload = this._unloadHandler.bind(this);
                this._domEvents.scroll = (0, _throttle2.default)(this._scrollHandler.bind(this), this.config.scrollThrottle);

                // listen for events
                window.addEventListener('resize', this._domEvents.resize);
                window.addEventListener('load', this._domEvents.load);
                window.addEventListener('unload', this._domEvents.unload);

                this.bindScrollEvent();

                // set up variable tracking
                this.scrollPosition = this.scrollPosition || { top: getScrollTop() };

                // cache window metrics now
                this._updateMetrics();
                this._updateScrollMetrics();

                this._detectBreakpoint(true);

                this.initialized = true;
            }
        }

        /* ==========================
          Public Members
          ========================== */

        // Allow scroll event to be detached from window. Useful for virtual scrolling. (shout out to MG, he'll love it)
        /**
         * Start listening for native window scroll events
         */

    }, {
        key: 'bindScrollEvent',
        value: function bindScrollEvent() {
            window.addEventListener('scroll', this._domEvents.scroll);
        }

        /**
         * Stop listening for native window scroll events
         */

    }, {
        key: 'unbindScrollEvent',
        value: function unbindScrollEvent() {
            window.removeEventListener('scroll', this._domEvents.scroll);
        }

        /**
         * Scroll to this position in the window. Updates the internal variables.
         * @param {number} y - Move scroll to to here
         * @param {number} x - Move scroll left to here.
         */

    }, {
        key: 'scrollTo',
        value: function scrollTo() {
            var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;


            this.scrollPosition.top = y;
            this.scrollPosition.left = x;

            window.scrollTo(x, y);
        }

        /**
         * Determine if the viewport is of a a minimum width
         *
         * @param {Object|String|Number} breakpoint - If of type object, assumes to be a named breakpoint object with a value property.
         *  If a string, a named breakpoint's name. If a number the breakpoint's value. A number maybe used to arbitrarily check window width
         * @returns {boolean} if the viewport is at least of breakpoint size.
         */

    }, {
        key: 'minWidth',
        value: function minWidth(breakpoint) {

            // Get numerical value for breakpoint
            var breakpointValue = void 0;
            if ((0, _isNumber2.default)(breakpoint)) {
                breakpointValue = breakpoint;
            } else if ((0, _isString2.default)(breakpoint)) {
                breakpointValue = (0, _find2.default)(this.breakpoints, { name: breakpoint }).value;
            } else if ((0, _isObject2.default)(breakpoint)) {
                breakpointValue = breakpoint.value;
            }

            return this.width >= breakpointValue;
        }

        /* ==========================
          Private Members
          ========================== */
        /**
         * Save the window metrics to this object
         * @private
         */

    }, {
        key: '_updateMetrics',
        value: function _updateMetrics() {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
        }

        /**
         * Update internal var that tracks the scroll position
         * @private
         */

    }, {
        key: '_updateScrollMetrics',
        value: function _updateScrollMetrics() {
            this.scrollPosition.top = getScrollTop();
            this.scrollPosition.left = getScrollLeft();
        }

        /**
         * Called on window resize events to detect which breakpoint we're on
         *
         * @param {Boolean} [suppressEvents=false] - Do not trigger a breakpoint event when a change is detected
         * @private
         */

    }, {
        key: '_detectBreakpoint',
        value: function _detectBreakpoint() {
            var _this2 = this;

            var suppressEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


            // find biggest matching BP
            var breakpoint = (0, _findLast2.default)(this.breakpoints, function (bp) {
                return _this2.width >= bp.value;
            });

            // ony if the breakpoint has changed
            if (this.currentBreakpoint !== breakpoint) {
                var previousBreakpoint = this.currentBreakpoint;
                this.currentBreakpoint = breakpoint;

                // dispatch event for breakpoint, simply cloning the BP object for the event data
                if (!suppressEvents) {
                    this.trigger('breakpoint', { breakpoint: breakpoint, previous: previousBreakpoint }); // TODO make breakpoints immutable
                }
            }
        }

        /* ==========================
          Event Handlers
          ========================== */
        /**
         * Internal window scroll handler. This call is throttled
         * @param event
         * @private
         */

    }, {
        key: '_scrollHandler',
        value: function _scrollHandler(event) {
            var previousTop = this.scrollPosition.top;
            this._updateScrollMetrics();
            var currentTop = this.scrollPosition.top;

            // determine direction by comparing previous scroll position
            var direction = previousTop < currentTop ? 1 : -1;

            // trigger custom event
            this.trigger('scroll', { scrollPosition: this.scrollPosition, direction: direction, originalEvent: event });
        }

        /**
         * Internal window resize handler. This call is throttled
         * @private
         */

    }, {
        key: '_resizeHandler',
        value: function _resizeHandler() {
            this._updateMetrics();
            this.trigger('resize', { width: this.width, height: this.height });
            this._detectBreakpoint();
        }

        /**
         * Called when the window unloads
         * @private
         */

    }, {
        key: '_unloadHandler',
        value: function _unloadHandler() {
            this.trigger('unload');
        }

        /**
         * Forward the window load event
         * @private
         */

    }, {
        key: '_loadHandler',
        value: function _loadHandler() {
            this.trigger('load');
        }
    }]);

    return WindowManagerClass;
}(_EventTarget3.default);

WindowManagerClass.defaultConfig = {
    scrollThrottle: 15, // number of ms between scroll events
    resizeThrottle: 50, // number of ms between resize events
    disableScrollClass: null, // class name to use for the disable scroll class. default is to apply styles directly
    disableUserInputClass: null // class name to use for the disable user input class. default is to apply styles directly
};

// Create our Singleton
exports.default = WindowManager = new WindowManagerClass();

// Export singleton by default and Class if introspection needed
exports.default = WindowManager;
exports.WindowManagerClass = WindowManagerClass;

},{"../core/EventTarget":257,"lodash/defaults":174,"lodash/find":179,"lodash/findLast":181,"lodash/isNumber":201,"lodash/isObject":202,"lodash/isString":205,"lodash/throttle":218}]},{},[245])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYW5pbWVqcy9hbmltZS5taW4uanMiLCJub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9jb252ZXJzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvcm91dGUuanMiLCJub2RlX21vZHVsZXMvY29sb3ItbmFtZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1zdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29sb3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZm9udGZhY2VvYnNlcnZlci9mb250ZmFjZW9ic2VydmVyLnN0YW5kYWxvbmUuanMiLCJub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcyIsIm5vZGVfbW9kdWxlcy9pcy1mdW5jdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FkZE1hcEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYWRkU2V0RW50cnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc2NpaVRvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xhbXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmFOLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTbGljZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFNsaWNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lTWFwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUNhc2VGaXJzdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUZpbmQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9sc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmljdEluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9hc3NpZ25JbldpdGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2NhcGl0YWxpemUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZGVib3VuY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9lbmRzV2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9maW5kTGFzdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZExhc3RJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZmlyc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ZvckVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2hlYWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzRWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNVbmRlZmluZWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFzdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbm93LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3RhcnRzV2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3Rocm90dGxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b0Zpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3VuemlwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91bnppcFdpdGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3VwcGVyRmlyc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3ZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvemlwV2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN3aXp6bGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN3aXp6bGUvbm9kZV9tb2R1bGVzL2lzLWFycmF5aXNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMveGhyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsIi4uL19zcmMvanMvYXBwL2NvbXBvbmVudHMvQWxwaGFWaWRlby5qcyIsIi4uL19zcmMvanMvYXBwL2NvbXBvbmVudHMvQ2FyZWVyU2xpZGVyLmpzIiwiLi4vX3NyYy9qcy9hcHAvY29tcG9uZW50cy9MaW5rU2VsZWN0LmpzIiwiLi4vX3NyYy9qcy9hcHAvY29tcG9uZW50cy9NZWRpYUdhbGxlcnkuanMiLCIuLi9fc3JjL2pzL2FwcC9jb21wb25lbnRzL1Byb2ZpbGVTbGlkZXIuanMiLCIuLi9fc3JjL2pzL2FwcC9jb21wb25lbnRzL1Byb2dyZXNzUGF0aC5qcyIsIi4uL19zcmMvanMvYXBwL2NvbXBvbmVudHMvWW91dHViZVBsYXllci5qcyIsIi4uL19zcmMvanMvYXBwL2NvbXBvbmVudHMvdmFsdWVzLXdoZWVsL1ZhbHVlc1doZWVsLmpzIiwiLi4vX3NyYy9qcy9hcHAvY29tcG9uZW50cy92YWx1ZXMtd2hlZWwvVmFsdWVzV2hlZWxTbWFsbC5qcyIsIi4uL19zcmMvanMvYXBwL2NvbXBvbmVudHMvdmFsdWVzLXdoZWVsL2dlbmVyYXRlUG9pbnRzLmpzIiwiLi4vX3NyYy9qcy9hcHAvY29tcG9uZW50cy92YWx1ZXMtd2hlZWwvcmVuZGVyQmFja2dyb3VuZC5qcyIsIi4uL19zcmMvanMvYXBwL21haW4uanMiLCIuLi9fc3JjL2pzL2FwcC9wYWdlcy9DYW5kaWRhdGVQYWdlLmpzIiwiLi4vX3NyYy9qcy9hcHAvcGFnZXMvQ2FyZWVyc1BhZ2UuanMiLCIuLi9fc3JjL2pzL2FwcC9wYWdlcy9Db250YWN0UGFnZS5qcyIsIi4uL19zcmMvanMvYXBwL3BhZ2VzL0hvbWVQYWdlLmpzIiwiLi4vX3NyYy9qcy9hcHAvcGFnZXMvSHVtYW5SZXNvdXJjZXNQYWdlLmpzIiwiLi4vX3NyYy9qcy9hcHAvcGFnZXMvUGFnZS5hYnN0cmFjdC5qcyIsIi4uL19zcmMvanMvYXBwL3BhZ2VzL1ZhbHVlc1BhZ2UuanMiLCIuLi9fc3JjL2pzL2FwcC9wYWdlcy9wYWdlTGlzdC5qcyIsIi4uL19zcmMvanMvYXBwL3VpL0Zvb3Rlci5qcyIsIi4uL19zcmMvanMvYXBwL3VpL0hlYWRlci5qcyIsIi4uL19zcmMvanMvYXBwL3VpL1BhZ2VEcmF3LmpzIiwiLi4vX3NyYy9qcy96aW1wbGlzdC9jb3JlL0V2ZW50VGFyZ2V0LmpzIiwiLi4vX3NyYy9qcy96aW1wbGlzdC9kaXNwbGF5L0Jhc2VWaWV3LmpzIiwiLi4vX3NyYy9qcy96aW1wbGlzdC9kaXNwbGF5L0NvbnRhaW5lclZpZXcuanMiLCIuLi9fc3JjL2pzL3ppbXBsaXN0L2Rpc3BsYXkvYW5pbWF0aW9uL1Nwcml0ZUFuaW1hdG9yLmpzIiwiLi4vX3NyYy9qcy96aW1wbGlzdC9kaXNwbGF5L2RvbS9lbXB0eS5qcyIsIi4uL19zcmMvanMvemltcGxpc3QvZGlzcGxheS9kb20vZ2V0U2Nyb2xsUGFyZW50LmpzIiwiLi4vX3NyYy9qcy96aW1wbGlzdC9kaXNwbGF5L2RvbS9pbmRleC5qcyIsIi4uL19zcmMvanMvemltcGxpc3QvZGlzcGxheS9kb20vcmVtb3ZlQ2xhc3Nlcy5qcyIsIi4uL19zcmMvanMvemltcGxpc3QvZGlzcGxheS9kb20vc3RyaW5nVG9FbGVtZW50LmpzIiwiLi4vX3NyYy9qcy96aW1wbGlzdC9kaXNwbGF5L2dldERvY3VtZW50UmVjdC5qcyIsIi4uL19zcmMvanMvemltcGxpc3QvZ2VvbWV0cnkvUG9pbnQuanMiLCIuLi9fc3JjL2pzL3ppbXBsaXN0L2lucHV0L0tleWJvYXJkLmpzIiwiLi4vX3NyYy9qcy96aW1wbGlzdC9pbnB1dC9Ub3VjaC5qcyIsIi4uL19zcmMvanMvemltcGxpc3QvbmV0L0ltYWdlTG9hZGVyLmpzIiwiLi4vX3NyYy9qcy96aW1wbGlzdC9uZXQvTG9hZGVyLmpzIiwiLi4vX3NyYy9qcy96aW1wbGlzdC91dGlscy9Db25maWcuanMiLCIuLi9fc3JjL2pzL3ppbXBsaXN0L3V0aWxzL1Njcm9sbGluZ1RyYWNrZXIuanMiLCIuLi9fc3JjL2pzL3ppbXBsaXN0L3V0aWxzL1N0eWxlLmpzIiwiLi4vX3NyYy9qcy96aW1wbGlzdC91dGlscy9XaW5kb3dNYW5hZ2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3MUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNmQTs7OztBQUNBOzs7Ozs7Ozs7OytlQUxBO0FBQ0E7O0FBRUE7OztBQUlBOzs7Ozs7Ozs7Ozs7OztBQWNBOztBQUVBOzs7SUFHTSxVOzs7QUFFRix3QkFBWSxFQUFaLEVBQWdCLE9BQWhCLEVBQXlCO0FBQUE7O0FBSXJCOzs7OztBQUpxQiw0SEFFZixFQUZlLEVBRVgsT0FGVzs7QUFTckIsY0FBSyxXQUFMLEdBQW1CLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsT0FBdEIsQ0FBbkI7O0FBRUE7QUFDQSxjQUFLLFdBQUwsR0FBbUIsRUFBRSxNQUFLLFdBQUwsQ0FBaUIsV0FBakIsQ0FBNkIsd0JBQTdCLE1BQTJELFVBQTdELENBQW5COztBQUVBOztBQUVBOzs7O0FBSUEsY0FBSyxPQUFMLEdBQWUsTUFBSyxXQUFMLENBQWlCLFlBQWpCLENBQThCLFVBQTlCLENBQWY7O0FBRUEsWUFBSSxNQUFLLFdBQVQsRUFBc0I7O0FBRWxCOzs7O0FBSUEsa0JBQUssYUFBTCxHQUFxQixXQUFZLE1BQUssV0FBTCxDQUFpQixZQUFqQixDQUE4QixxQkFBOUIsQ0FBWixLQUFxRSxDQUExRjs7QUFFQSxrQkFBSyxFQUFMLENBQVEsU0FBUixDQUFrQixHQUFsQixDQUFzQixVQUF0Qjs7QUFFQSxrQkFBSyxXQUFMLENBQWlCLEdBQWpCLEdBQXVCLE1BQUssT0FBTCxHQUFhLFlBQXBDOztBQUVBLGdCQUFJLE1BQUssV0FBTCxDQUFpQixVQUFqQixJQUErQixNQUFLLFdBQUwsQ0FBaUIsV0FBaEQsSUFBK0QsTUFBSyxXQUFMLENBQWlCLFFBQXBGLEVBQThGO0FBQzFGLHNCQUFLLGVBQUw7QUFDSCxhQUZELE1BRU87QUFDSCxzQkFBSyxXQUFMLENBQWlCLGdCQUFqQixFQUFtQyxNQUFLLDJCQUF4QyxFQUFxRSxNQUFLLFdBQTFFO0FBQ0g7O0FBR0Qsa0JBQUssV0FBTCxDQUFpQixTQUFqQixFQUE0QixNQUFLLDBCQUFqQyxFQUE2RCxNQUFLLFdBQWxFO0FBQ0Esa0JBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixNQUFLLHdCQUEvQixFQUF5RCxNQUFLLFdBQTlEOztBQUVBO0FBQ0EsZ0JBQUksQ0FBQyxNQUFLLFdBQUwsQ0FBaUIsTUFBdEIsRUFBOEI7QUFDMUIsc0JBQUssZUFBTDtBQUNBLHNCQUFLLGdCQUFMO0FBQ0g7QUFDSixTQTNCRCxNQTJCTzs7QUFFSCxrQkFBSyxXQUFMLENBQWlCLEdBQWpCLEdBQXVCLE1BQUssT0FBTCxHQUFhLFlBQXBDO0FBRUg7O0FBckRvQjtBQXVEeEI7O0FBRUQ7Ozs7OzswQ0FNa0IsVSxFQUFZLGtCLEVBQW9CO0FBQzlDLHNJQUF3QixVQUF4QixFQUFvQyxrQkFBcEM7QUFDSDs7QUFHRDs7Ozs7OzBDQUtrQjs7QUFFZCxnQkFBSSxDQUFDLEtBQUssYUFBVixFQUF5QjtBQUNyQixvQkFBSSxlQUFlLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUFuQjtBQUNBLDZCQUFhLEtBQWIsR0FBcUIsS0FBSyxXQUFMLENBQWlCLFVBQXRDO0FBQ0EsNkJBQWEsTUFBYixHQUFzQixLQUFLLFdBQUwsQ0FBaUIsV0FBakIsR0FBK0IsQ0FBckQ7O0FBRUEsb0JBQUksY0FBYyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBbEI7QUFDQSw0QkFBWSxLQUFaLEdBQW9CLEtBQUssV0FBTCxDQUFpQixVQUFyQztBQUNBLDRCQUFZLE1BQVosR0FBcUIsS0FBSyxXQUFMLENBQWlCLFdBQWpCLEdBQStCLENBQXBEOztBQUVBLHFCQUFLLGFBQUwsR0FBcUIsWUFBckI7QUFDQSxxQkFBSyxjQUFMLEdBQXNCLGFBQWEsVUFBYixDQUF3QixJQUF4QixDQUF0Qjs7QUFFQSxxQkFBSyxhQUFMLEdBQXFCLFdBQXJCO0FBQ0EscUJBQUssYUFBTCxHQUFxQixZQUFZLFVBQVosQ0FBdUIsSUFBdkIsQ0FBckI7O0FBR0E7QUFDQSxnQ0FBTSxHQUFOLENBQVcsS0FBSyxhQUFoQixFQUErQixFQUFDLHNCQUFxQixLQUFLLGFBQTFCLE1BQUQsRUFBL0I7O0FBRUEsZ0NBQU0sR0FBTixDQUFXLEtBQUssRUFBaEIsRUFBb0I7QUFDaEIsMkJBQU8sS0FBSyxXQUFMLENBQWlCLFVBQWpCLEdBQThCLEtBQUssYUFEMUI7QUFFaEIsNEJBQVMsS0FBSyxXQUFMLENBQWlCLFdBQWpCLEdBQStCLENBQWhDLEdBQXFDLEtBQUs7QUFGbEMsaUJBQXBCOztBQUtBLHFCQUFLLEVBQUwsQ0FBUSxXQUFSLENBQW9CLFlBQXBCO0FBQ0g7QUFFSjs7O2tDQUVTOztBQUVOLGdCQUFJLGFBQWEsS0FBSyxXQUFMLENBQWlCLFVBQWxDO0FBQ0EsZ0JBQUksY0FBYyxLQUFLLFdBQUwsQ0FBaUIsV0FBakIsR0FBK0IsQ0FBakQ7O0FBRUE7QUFDQSxpQkFBSyxjQUFMLENBQW9CLFNBQXBCLENBQThCLEtBQUssV0FBbkMsRUFBZ0QsQ0FBaEQsRUFBbUQsQ0FBbkQsRUFBc0QsVUFBdEQsRUFBa0UsV0FBbEUsRUFBK0UsQ0FBL0UsRUFBa0YsQ0FBbEYsRUFBcUYsVUFBckYsRUFBaUcsV0FBakc7O0FBRUE7QUFDQSxpQkFBSyxhQUFMLENBQW1CLFNBQW5CLENBQTZCLEtBQUssV0FBbEMsRUFBK0MsQ0FBL0MsRUFBa0QsV0FBbEQsRUFBK0QsVUFBL0QsRUFBMkUsV0FBM0UsRUFBd0YsQ0FBeEYsRUFBMkYsQ0FBM0YsRUFBOEYsVUFBOUYsRUFBMEcsV0FBMUc7O0FBRUEsZ0JBQUksVUFBVSxLQUFLLGNBQUwsQ0FBb0IsWUFBcEIsQ0FBaUMsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUMsVUFBdkMsRUFBbUQsV0FBbkQsQ0FBZDtBQUNBLGdCQUFJLFlBQVksS0FBSyxhQUFMLENBQW1CLFlBQW5CLENBQWdDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDLFVBQXRDLEVBQWtELFdBQWxELENBQWhCOztBQUVBLGdCQUFJLGFBQWEsUUFBUSxJQUFSLENBQWEsTUFBOUI7O0FBRUE7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFLLGFBQWEsQ0FBbEMsRUFBc0MsS0FBSyxDQUEzQyxFQUE4Qzs7QUFFMUMsb0JBQUksS0FBSyxVQUFVLElBQVYsQ0FBZSxDQUFmLENBQVQ7QUFDQSxvQkFBSSxLQUFLLFVBQVUsSUFBVixDQUFlLElBQUksQ0FBbkIsQ0FBVDtBQUNBLG9CQUFJLEtBQUssVUFBVSxJQUFWLENBQWUsSUFBSSxDQUFuQixDQUFUOztBQUVBO0FBQ0Esd0JBQVEsSUFBUixDQUFhLElBQUksQ0FBakIsSUFBc0IsQ0FBQyxLQUFLLEVBQUwsR0FBVSxFQUFYLElBQWlCLENBQXZDLENBUDBDLENBT0E7QUFDN0M7O0FBRUQsaUJBQUssY0FBTCxDQUFvQixZQUFwQixDQUFpQyxPQUFqQyxFQUEwQyxDQUExQyxFQUE2QyxDQUE3QztBQUNIOzs7MkNBRWtCO0FBQUE7O0FBQ2YsZ0JBQUksQ0FBQyxLQUFLLFlBQVYsRUFBd0I7QUFDcEIscUJBQUssWUFBTCxHQUFvQixPQUFPLHFCQUFQLENBQTZCLFlBQU07QUFDbkQsMkJBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLDJCQUFLLE9BQUw7QUFDQSwyQkFBSyxnQkFBTDtBQUVILGlCQUxtQixDQUFwQjtBQU1IO0FBQ0o7OzswQ0FFaUI7QUFDZCxvQkFBUSxHQUFSLENBQVksYUFBWjtBQUNBLGdCQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNuQix1QkFBTyxvQkFBUCxDQUE0QixLQUFLLFdBQWpDO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7O29EQUs0QixLLEVBQU87QUFDL0IsaUJBQUssZUFBTDtBQUNIOzs7bURBRTBCLEssRUFBTztBQUM5QixnQkFBSSxLQUFLLFdBQVQsRUFBc0I7QUFDbEIscUJBQUssZ0JBQUw7QUFDSDtBQUNKOzs7aURBRXdCLEssRUFBTztBQUM1QixnQkFBSSxLQUFLLFdBQVQsRUFBc0I7QUFDbEIscUJBQUssZUFBTDtBQUNIO0FBQ0o7Ozs7OztrQkFLVSxVOzs7Ozs7Ozs7Ozs7O0FDMU1mOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OztBQUpBOzs7QUFNQTs7SUFFTSxZOzs7QUFFRiwwQkFBWSxFQUFaLEVBQWdCLE9BQWhCLEVBQXlCO0FBQUE7O0FBQUEsZ0lBRWYsRUFGZSxFQUVYLEVBQUUsYUFBYyxDQUFDLEtBQUQsRUFBUSxHQUFSLEVBQWEsR0FBYixDQUFoQixFQUZXOztBQUlyQixjQUFLLGFBQUwsR0FBcUIsTUFBSyxFQUFMLENBQVEsYUFBUixDQUFzQix3QkFBdEIsQ0FBckI7O0FBRUEsY0FBSyxLQUFMLEdBQWEsTUFBTSxJQUFOLENBQVksTUFBSyxFQUFMLENBQVEsZ0JBQVIsQ0FBeUIsY0FBekIsQ0FBWixDQUFiOztBQUVBLGNBQUssWUFBTCxHQUFvQixDQUFwQjtBQUNBLGNBQUssaUJBQUw7O0FBRUEsY0FBSyxRQUFMLENBQWMsQ0FBZDs7QUFFQTtBQUNBLGNBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixNQUFLLGdCQUEvQixFQUFpRCxRQUFqRDs7QUFFQTtBQUNBLGNBQUssYUFBTCxHQUFxQixvQkFBVyxNQUFLLEVBQWhCLENBQXJCOztBQUVBLGNBQUssYUFBTCxDQUFtQixFQUFuQixDQUFzQixPQUF0QixFQUErQixVQUFDLEtBQUQsRUFBVztBQUN0QyxnQkFBSSxZQUFZLE1BQUssWUFBTCxJQUFzQixNQUFNLFFBQU4sQ0FBZSxDQUFmLEdBQW1CLENBQXBCLEdBQXlCLENBQUMsQ0FBMUIsR0FBOEIsQ0FBbkQsQ0FBaEI7QUFDQSx3QkFBWSxLQUFLLEdBQUwsQ0FBVSxDQUFWLEVBQWEsS0FBSyxHQUFMLENBQVMsTUFBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixDQUE3QixFQUFnQyxTQUFoQyxDQUFiLENBQVo7O0FBRUEsa0JBQUssUUFBTCxDQUFlLFNBQWY7QUFDSCxTQUxEOztBQW5CcUI7QUEwQnhCOzs7OzRDQUVtQjtBQUNoQixvQkFBUSxLQUFLLGlCQUFMLENBQXVCLElBQS9CO0FBQ0kscUJBQUssS0FBTDtBQUNJLHlCQUFLLFlBQUwsR0FBb0IsQ0FBcEI7QUFDQTtBQUNKLHFCQUFLLEdBQUw7QUFDSSx5QkFBSyxZQUFMLEdBQW9CLENBQXBCO0FBQ0E7QUFDSixxQkFBSyxHQUFMO0FBQ0kseUJBQUssWUFBTCxHQUFvQixDQUFwQjtBQUNBO0FBVFI7QUFXSDs7O2lDQUVROztBQUVMO0FBQ0EsaUJBQUssU0FBTCxHQUFpQixLQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsVUFBL0I7QUFFSDs7OzBDQUdpQixVLEVBQVksa0IsRUFBb0I7QUFDOUMsMElBQXdCLFVBQXhCLEVBQW9DLGtCQUFwQztBQUNBLGlCQUFLLGlCQUFMO0FBQ0EsaUJBQUssUUFBTCxDQUFjLEtBQUssWUFBbkI7QUFDSDs7O2lDQUVRLFMsRUFBVztBQUFBOztBQUVoQiw0QkFBTSxHQUFOLENBQVUsS0FBSyxhQUFmLEVBQThCO0FBQzFCLDRDQUEyQixZQUFZLEtBQUssU0FBNUM7QUFEMEIsYUFBOUI7O0FBSUE7QUFDQSxpQkFBSyxLQUFMLENBQVcsT0FBWCxDQUFvQixVQUFDLElBQUQsRUFBTyxDQUFQLEVBQWE7QUFDN0Isb0JBQUksS0FBSyxTQUFMLElBQWtCLEtBQUssWUFBWSxPQUFLLFlBQWpCLEdBQWdDLENBQTNELEVBQStEO0FBQzNELHlCQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLFNBQW5CO0FBQ0gsaUJBRkQsTUFFTztBQUNILHlCQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXNCLFNBQXRCO0FBQ0g7QUFDSixhQU5EOztBQVFBO0FBQ0EsZ0JBQUksY0FBYyxDQUFsQixFQUFxQjtBQUNqQixxQkFBSyxFQUFMLENBQVEsU0FBUixDQUFrQixHQUFsQixDQUFzQixXQUF0QjtBQUNBLHFCQUFLLEVBQUwsQ0FBUSxTQUFSLENBQWtCLE1BQWxCLENBQXlCLFdBQXpCO0FBQ0gsYUFIRCxNQUdPLElBQUksY0FBYyxLQUFLLEtBQUwsQ0FBVyxNQUFYLEdBQW9CLEtBQUssWUFBM0MsRUFBeUQ7QUFDNUQscUJBQUssRUFBTCxDQUFRLFNBQVIsQ0FBa0IsTUFBbEIsQ0FBeUIsV0FBekI7QUFDQSxxQkFBSyxFQUFMLENBQVEsU0FBUixDQUFrQixHQUFsQixDQUFzQixXQUF0QjtBQUNILGFBSE0sTUFHQTtBQUNILHFCQUFLLEVBQUwsQ0FBUSxTQUFSLENBQWtCLE1BQWxCLENBQXlCLFdBQXpCO0FBQ0EscUJBQUssRUFBTCxDQUFRLFNBQVIsQ0FBa0IsTUFBbEIsQ0FBeUIsV0FBekI7QUFDSDs7QUFFRCxpQkFBSyxZQUFMLEdBQW9CLFNBQXBCO0FBRUg7O0FBRUQ7Ozs7Ozt5Q0FNaUIsSyxFQUFPO0FBQ3BCLGdCQUFJLGtCQUFKO0FBQ0EsZ0JBQUssTUFBTSxjQUFOLENBQXFCLFNBQXJCLENBQStCLFFBQS9CLENBQXdDLE1BQXhDLENBQUwsRUFBdUQ7QUFDbkQsNEJBQVksS0FBSyxHQUFMLENBQVUsQ0FBVixFQUFhLEtBQUssWUFBTCxHQUFvQixDQUFqQyxDQUFaO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsNEJBQVksS0FBSyxHQUFMLENBQVUsS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixLQUFLLFlBQW5DLEVBQWlELEtBQUssWUFBTCxHQUFvQixDQUFyRSxDQUFaO0FBQ0g7QUFDRCxpQkFBSyxRQUFMLENBQWUsU0FBZjtBQUNIOzs7Ozs7a0JBSVUsWTs7Ozs7Ozs7Ozs7QUNqSGY7Ozs7Ozs7Ozs7K2VBSEE7O0FBRUE7OztBQUdBOzs7QUFHQTs7O0lBR00sVTs7O0FBRUYsd0JBQVksRUFBWixFQUFnQixPQUFoQixFQUF5QjtBQUFBOztBQUFBLDRIQUVmLEVBRmUsRUFFWCxPQUZXOztBQUlyQixjQUFLLFdBQUwsQ0FBaUIsT0FBakIsRUFBMEIsTUFBSyxrQkFBL0IsRUFBbUQsUUFBbkQ7QUFKcUI7QUFLeEI7O0FBRUQ7Ozs7QUFPQTs7OztBQU1BOzs7Ozs7OzJDQUttQixLLEVBQU87O0FBR3RCLGdCQUFLLEtBQUssRUFBTCxDQUFRLFNBQVIsQ0FBa0IsUUFBbEIsQ0FBMkIsVUFBM0IsQ0FBTCxFQUE4Qzs7QUFFMUMscUJBQUssRUFBTCxDQUFRLFNBQVIsQ0FBa0IsTUFBbEIsQ0FBeUIsVUFBekI7QUFDQSxxQkFBSyxPQUFMLENBQWEsT0FBYixFQUFzQixFQUF0QjtBQUVILGFBTEQsTUFLTzs7QUFFSCxxQkFBSyxFQUFMLENBQVEsU0FBUixDQUFrQixHQUFsQixDQUFzQixVQUF0QjtBQUNBLHFCQUFLLE9BQUwsQ0FBYSxNQUFiLEVBQXFCLEVBQXJCO0FBQ0g7QUFFSjs7Ozs7O2tCQUtVLFU7Ozs7Ozs7Ozs7O0FDeERmOzs7O0FBQ0E7Ozs7QUFHQTs7OztBQUNBOzs7O0FBR0E7Ozs7Ozs7Ozs7K2VBVEE7OztBQUlBOzs7QUFJQTs7O0FBR0E7O0FBRUE7OztJQUdNLFk7OztBQUVGLDBCQUFZLEVBQVosRUFBZ0IsT0FBaEIsRUFBeUI7QUFBQTs7QUFBQSxnSUFFZixFQUZlLEVBRVgsT0FGVzs7QUFJckIsY0FBSyxlQUFMLEdBQTBCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsMEJBQXRCLENBQTFCO0FBQ0EsY0FBSyxhQUFMLEdBQTBCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsdUJBQXRCLENBQTFCOztBQUVBLGNBQUssV0FBTCxHQUFtQixNQUFNLElBQU4sQ0FBWSxNQUFLLGVBQUwsQ0FBcUIsZ0JBQXJCLENBQXNDLGVBQXRDLENBQVosQ0FBbkI7QUFDQSxjQUFLLFNBQUwsR0FBaUIsTUFBTSxJQUFOLENBQVksTUFBSyxhQUFMLENBQW1CLGdCQUFuQixDQUFvQyxvQkFBcEMsQ0FBWixDQUFqQjs7QUFFQSxjQUFLLE9BQUwsR0FBZSxNQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLDhCQUF0QixDQUFmOztBQUVBO0FBQ0EsY0FBSyxLQUFMLEdBQWEsdUJBQVMsTUFBSyxXQUFkLEVBQTJCLE1BQUssU0FBaEMsRUFBMkMsVUFBQyxNQUFELEVBQVMsSUFBVCxFQUFtQjtBQUN2RSxtQkFBTyxTQUFQLENBQWlCLEdBQWpCLENBQXFCLFNBQXJCO0FBQ0EsbUJBQU8sRUFBQyxRQUFRLE1BQVQsRUFBaUIsTUFBTSxJQUF2QixFQUFQO0FBQ0gsU0FIWSxDQUFiOztBQUtBLGNBQUssWUFBTCxHQUFvQixDQUFwQjs7QUFFQSxjQUFLLFNBQUwsQ0FBZ0IsTUFBSyxZQUFyQixFQUFvQyxTQUFwQyxDQUE4QyxHQUE5QyxDQUFrRCxTQUFsRDs7QUFFQSxjQUFLLFdBQUwsQ0FBaUIsT0FBakIsRUFBMEIsTUFBSyxnQkFBL0IsRUFBaUQscUJBQWpEOztBQUVBLGNBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixNQUFLLHNCQUEvQixFQUF1RCwwQkFBdkQ7O0FBRUEsY0FBSyxNQUFMO0FBMUJxQjtBQTJCeEI7O0FBRUQ7Ozs7OzswQ0FNa0IsVSxFQUFZLGtCLEVBQW9CLENBRWpEOzs7aUNBR1E7O0FBRUw7QUFDQSxpQkFBSyxXQUFMLENBQWlCLE9BQWpCLENBQTBCLFVBQUMsSUFBRCxFQUFPLENBQVAsRUFBYTs7QUFFbkMsZ0NBQU0sR0FBTixDQUFXLElBQVgsRUFBaUIsRUFBQyxNQUFTLElBQUUsR0FBWCxNQUFELEVBQWpCO0FBRUgsYUFKRDtBQU1IOzs7aUNBRVEsUyxFQUFXO0FBQ2hCLGdCQUFJLGNBQWMsS0FBSyxZQUF2QixFQUFxQztBQUNqQyxvQkFBTSxjQUFjLEtBQUssS0FBTCxDQUFZLEtBQUssWUFBakIsQ0FBcEI7QUFDQSxvQkFBTSxhQUFhLEtBQUssS0FBTCxDQUFZLFNBQVosQ0FBbkI7O0FBRUE7QUFDQSxvQkFBTSxZQUFhLFlBQVksS0FBSyxZQUFsQixHQUFrQyxDQUFDLENBQW5DLEdBQXVDLENBQXpELENBTGlDLENBSzJCOztBQUU1RCxvQkFBTSxXQUFXLEtBQUssR0FBTCxDQUFVLFlBQVksS0FBSyxZQUEzQixJQUEyQyxHQUE1RDs7QUFFQSx1Q0FBTTtBQUNGLDZCQUFVLEtBQUssZUFEYjtBQUVGLDhCQUFXLFFBRlQ7QUFHRixnQ0FBaUIsRUFBRSxZQUFZLEdBQWQsQ0FBakIsTUFIRTtBQUlGLDRCQUFTO0FBSlAsaUJBQU47O0FBT0E7QUFDQSxxQkFBSyxTQUFMLENBQWdCLEtBQUssWUFBckIsRUFBb0MsU0FBcEMsQ0FBOEMsTUFBOUMsQ0FBcUQsU0FBckQ7QUFDQSxxQkFBSyxTQUFMLENBQWdCLFNBQWhCLEVBQTRCLFNBQTVCLENBQXNDLEdBQXRDLENBQTBDLFNBQTFDOztBQUVBO0FBQ0EscUJBQUssT0FBTCxDQUFhLFdBQWIsR0FBOEIsWUFBVSxDQUF4QyxXQUErQyxLQUFLLEtBQUwsQ0FBVyxNQUExRDs7QUFFQTtBQUNBLG9CQUFJLEtBQUssa0JBQVQsRUFBNkI7QUFDekIseUJBQUssa0JBQUwsQ0FBd0IsTUFBeEI7QUFDQSx5QkFBSyxrQkFBTCxHQUEwQixJQUExQjtBQUNIOztBQUVEO0FBQ0EscUJBQUssWUFBTCxHQUFvQixTQUFwQjtBQUNIO0FBQ0o7O0FBRUQ7Ozs7QUFRQTs7Ozs7O3lDQUtpQixLLEVBQU87QUFDcEIsZ0JBQUksYUFBZSxNQUFNLGNBQU4sQ0FBcUIsU0FBckIsQ0FBK0IsUUFBL0IsQ0FBd0MsTUFBeEMsQ0FBRixHQUFzRCxLQUFLLFlBQUwsR0FBb0IsQ0FBMUUsR0FBNkUsS0FBSyxZQUFMLEdBQW9CLENBQWxIOztBQUVBO0FBQ0EseUJBQWEsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUssR0FBTCxDQUFTLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsQ0FBN0IsRUFBZ0MsVUFBaEMsQ0FBWixDQUFiOztBQUVBLGlCQUFLLFFBQUwsQ0FBZSxVQUFmO0FBQ0g7OzsrQ0FFc0IsSyxFQUFPOztBQUUxQixnQkFBTSxpQkFBaUIsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQXZCO0FBQ0EsMkJBQWUsU0FBZixHQUEyQixnQkFBM0I7O0FBRUEsZ0JBQU0sZ0JBQWdCLDRCQUFtQixjQUFuQixFQUFtQztBQUNyRCx5QkFBUyxNQUFNLGNBQU4sQ0FBcUIsWUFBckIsQ0FBa0MsZUFBbEMsQ0FENEM7QUFFckQsMEJBQVU7QUFGMkMsYUFBbkMsQ0FBdEI7O0FBS0EsaUJBQUssa0JBQUwsR0FBMEIsYUFBMUI7O0FBRUE7QUFDQSxrQkFBTSxjQUFOLENBQXFCLFdBQXJCLENBQWtDLGNBQWMsRUFBaEQ7QUFFSDs7Ozs7O2tCQUtVLFk7Ozs7Ozs7Ozs7O0FDakpmOzs7O0FBR0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBUEE7OztBQUdBOzs7QUFNQTs7O0FBR0E7QUFDQSxJQUFNLG1CQUFtQixJQUF6Qjs7QUFHQTs7OztJQUdNLGE7OztBQUVGLDJCQUFZLEVBQVosRUFBZ0IsT0FBaEIsRUFBeUI7QUFBQTs7QUFJckI7QUFKcUIsa0lBRWYsRUFGZSxFQUVYLEVBQUMsYUFBYyxDQUFDLEtBQUQsRUFBUSxHQUFSLENBQWYsRUFGVzs7QUFLckIsY0FBSyxjQUFMLEdBQXNCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsaUJBQXRCLENBQXRCO0FBQ0EsY0FBSyxNQUFMLEdBQWMsTUFBTSxJQUFOLENBQVksTUFBSyxjQUFMLENBQW9CLGdCQUFwQixDQUFxQyxpQkFBckMsQ0FBWixDQUFkOztBQUVBO0FBQ0EsY0FBSyxZQUFMLEdBQW9CLENBQXBCO0FBQ0EsY0FBSyxhQUFMLEdBQXFCLENBQXJCOztBQUVBO0FBQ0EsY0FBSyxhQUFMLEdBQXFCLG9CQUFVLE1BQUssRUFBZixDQUFyQjs7QUFFQSxjQUFLLFFBQUwsQ0FBYyxNQUFLLGFBQW5CLEVBQWtDLE1BQWxDLEVBQTBDLE1BQUssaUJBQS9DO0FBQ0EsY0FBSyxRQUFMLENBQWMsTUFBSyxhQUFuQixFQUFrQyxLQUFsQyxFQUF5QyxNQUFLLGdCQUE5Qzs7QUFFQSxjQUFLLE1BQUw7O0FBbEJxQjtBQW9CeEI7O0FBRUQ7Ozs7OzswQ0FNa0IsVSxFQUFZLGlCLEVBQW1COztBQUU3QyxnQkFBSyxXQUFXLElBQVgsS0FBb0IsR0FBekIsRUFBOEIsQ0FFN0IsQ0FGRCxNQUVPLENBRU47QUFFSjs7O2lDQUVROztBQUVMLGdCQUFLLENBQUMsS0FBSyxRQUFMLENBQWMsR0FBZCxDQUFOLEVBQTJCO0FBQ3ZCLHFCQUFLLFVBQUwsR0FBa0IsS0FBSyxNQUFMLENBQVksQ0FBWixFQUFlLFdBQWpDO0FBQ0EscUJBQUssV0FBTCxHQUFtQixLQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsVUFBZixHQUE0QixLQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsVUFBM0MsR0FBd0QsS0FBSyxVQUFoRjs7QUFFQSxxQkFBSyxXQUFMLEdBQW1CLEtBQUssVUFBTCxHQUFrQixLQUFLLFdBQTFDOztBQUVBO0FBQ0Esb0JBQUksU0FBUyxDQUFDLHdCQUFjLEtBQWQsR0FBc0IsS0FBSyxVQUE1QixJQUEwQyxDQUF2RDtBQUNBLGdDQUFNLEdBQU4sQ0FBVyxLQUFLLGNBQWhCLEVBQWdDLEVBQUUsTUFBTSxNQUFSLEVBQWhDO0FBRUgsYUFWRCxNQVVPOztBQUVILGdDQUFNLEdBQU4sQ0FBVyxLQUFLLGNBQWhCLEVBQWdDLEVBQUMsTUFBTSxJQUFQLEVBQWEsV0FBVyxJQUF4QixFQUFoQzs7QUFFQTtBQUVIO0FBRUo7OztpQ0FFUSxTLEVBQTJCO0FBQUEsZ0JBQWhCLE9BQWdCLHVFQUFOLElBQU07OztBQUVoQztBQUNBLGdCQUFJLFNBQVMsRUFBRSxZQUFZLEtBQUssV0FBbkIsQ0FBYjs7QUFFQTtBQUNBLGdCQUFJLFdBQVcsS0FBSyxHQUFMLENBQVUsR0FBVixFQUFlLEtBQUssR0FBTCxDQUFVLFNBQVMsS0FBSyxhQUF4QixJQUF5QyxnQkFBeEQsQ0FBZixDQU5nQyxDQU0wRDs7QUFFMUYsZ0JBQUksT0FBSixFQUFhO0FBQ1QsdUNBQU07QUFDRiw2QkFBVSxLQUFLLGNBRGI7QUFFRiw4QkFBVyxRQUZUO0FBR0YsZ0NBQWEsTUFIWDtBQUlGLDRCQUFTO0FBSlAsaUJBQU47QUFNSCxhQVBELE1BT087QUFDSCxnQ0FBTSxHQUFOLENBQVcsS0FBSyxjQUFoQixFQUFnQyxFQUFFLDJCQUEwQixNQUExQixRQUFGLEVBQWhDO0FBQ0g7O0FBRUQ7QUFDQSxpQkFBSyxhQUFMLEdBQXFCLE1BQXJCO0FBQ0EsaUJBQUssWUFBTCxHQUFvQixTQUFwQjtBQUNIOztBQUdEOzs7O0FBT0E7Ozs7Ozs0Q0FLb0I7O0FBRWhCLGdCQUFJLEtBQUssUUFBTCxDQUFjLEdBQWQsQ0FBSixFQUF3Qjs7QUFFeEIsZ0JBQU0sWUFBWSxLQUFLLGFBQUwsQ0FBbUIsU0FBckM7QUFDQSxnQkFBTSxZQUFZLEtBQUssYUFBTCxDQUFtQixTQUFyQzs7QUFFQSxnQkFBSSxLQUFLLEdBQUwsQ0FBUyxTQUFULElBQXNCLEtBQUssR0FBTCxDQUFTLFNBQVQsQ0FBMUIsRUFBK0M7QUFDM0Msb0JBQUksU0FBUyxLQUFLLGFBQUwsR0FBcUIsU0FBbEM7QUFDQSxnQ0FBTSxHQUFOLENBQVUsS0FBSyxjQUFmLEVBQStCLEVBQUMsMkJBQXlCLE1BQXpCLFFBQUQsRUFBL0I7QUFDSDtBQUNKOzs7MkNBRWtCOztBQUVmLGdCQUFJLEtBQUssUUFBTCxDQUFjLEdBQWQsQ0FBSixFQUF3Qjs7QUFFeEIsZ0JBQU0sWUFBWSxLQUFLLGFBQUwsQ0FBbUIsU0FBckM7QUFDQSxnQkFBTSxZQUFZLEtBQUssYUFBTCxDQUFtQixTQUFyQzs7QUFFQSxnQkFBSSxLQUFLLEdBQUwsQ0FBUyxTQUFULElBQXNCLEVBQXRCLElBQTRCLEtBQUssR0FBTCxDQUFTLFNBQVQsSUFBc0IsS0FBSyxHQUFMLENBQVMsU0FBVCxDQUF0RCxFQUEyRTs7QUFFdkUsb0JBQUksY0FBZSxZQUFZLENBQWIsR0FBa0IsS0FBSyxZQUFMLEdBQW9CLENBQXRDLEdBQTBDLEtBQUssWUFBTCxHQUFvQixDQUFoRjs7QUFFQTtBQUNBLDhCQUFjLEtBQUssR0FBTCxDQUFVLENBQVYsRUFBYSxLQUFLLEdBQUwsQ0FBVSxLQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLENBQS9CLEVBQWtDLFdBQWxDLENBQWIsQ0FBZDs7QUFFQSxxQkFBSyxRQUFMLENBQWUsV0FBZjtBQUVILGFBVEQsTUFTTztBQUFFO0FBQ0wscUJBQUssUUFBTCxDQUFlLEtBQUssWUFBcEI7QUFDSDtBQUNKOzs7Ozs7a0JBTVUsYTs7Ozs7Ozs7Ozs7OztBQzNKZjs7OztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVBBOzs7QUFHQTs7O0FBTUE7OztBQUdBO0FBQ0EsSUFBTSxtQkFBbUIsSUFBekI7QUFDQSxJQUFNLHdCQUF3QixHQUE5QixDLENBQW1DO0FBQ25DLElBQU0saUJBQWlCLEVBQXZCO0FBQ0EsSUFBTSxpQkFBaUIsTUFBTyxPQUFPLFdBQVAsR0FBcUIsR0FBbkQsQyxDQUF5RDtBQUN6RCxJQUFNLGFBQWEsR0FBbkI7O0FBRUE7Ozs7SUFHTSxZOzs7QUFFRiwwQkFBWSxFQUFaLEVBQWdCLE9BQWhCLEVBQXlCO0FBQUE7O0FBSXJCO0FBSnFCLGdJQUVmLEVBRmUsRUFFWCxPQUZXOztBQUtyQixjQUFLLFNBQUwsR0FBaUIsUUFBUSxTQUF6Qjs7QUFFQTtBQUNBLGNBQUssT0FBTCxHQUFlLFFBQVEsT0FBdkI7O0FBRUE7QUFDQSxjQUFLLGlCQUFMLEdBQXlCLENBQXpCOztBQUVBLGNBQUssZUFBTDtBQUNBLGNBQUssT0FBTDs7QUFFQTtBQUNBLGNBQUssUUFBTCwwQkFBOEIsUUFBOUIsRUFBd0MsTUFBSyxjQUE3Qzs7QUFFQSxjQUFLLGlCQUFMO0FBbkJxQjtBQW9CeEI7O0FBRUQ7Ozs7OzswQ0FNa0IsVSxFQUFZLGtCLEVBQW9CO0FBQzlDLDBJQUF3QixVQUF4QixFQUFvQyxrQkFBcEM7O0FBRUEsZ0JBQUssS0FBSyxRQUFMLENBQWMsR0FBZCxDQUFMLEVBQTBCO0FBQ3RCLHFCQUFLLGlCQUFMLEdBQXlCLEtBQUssR0FBTCxDQUFVLEtBQUssaUJBQWYsRUFBa0Msd0JBQWMsY0FBZCxDQUE2QixHQUE3QixHQUFvQyx3QkFBYyxNQUFkLEdBQXVCLEdBQTdGLENBQXpCOztBQUVBLGdDQUFNLEdBQU4sQ0FBVyxLQUFLLGNBQWhCLEVBQWdDO0FBQzVCLDRCQUFRLEtBQUssaUJBRGUsRUFDSSxVQUFVLFFBRGQ7QUFFNUIsd0NBQW9CLEtBQUssaUJBQUwsR0FBeUI7O0FBRmpCLGlCQUFoQztBQUtILGFBUkQsTUFRTztBQUNILGdDQUFNLEdBQU4sQ0FBVyxLQUFLLGNBQWhCLEVBQWdDLEVBQUMsUUFBUSxNQUFULEVBQWlCLFVBQVUsU0FBM0IsRUFBaEM7QUFDSDtBQUVKOzs7aUNBRVE7QUFDTCxpQkFBSyxPQUFMO0FBQ0g7O0FBRUQ7Ozs7OzswQ0FLa0I7QUFDZCxnQkFBSSxnQkFBZ0IsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQXBCO0FBQ0EsMEJBQWMsU0FBZCxHQUEwQixvQkFBMUI7O0FBRUEsZ0JBQUksWUFBWSxFQUFoQjs7QUFFQTtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxTQUFMLENBQWUsTUFBZixHQUF3QixDQUE1QyxFQUErQyxHQUEvQyxFQUFvRDtBQUNoRCxvQkFBSSxlQUFlLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUFuQjtBQUNBLDhCQUFjLFdBQWQsQ0FBMEIsWUFBMUI7QUFDQSwwQkFBVSxJQUFWLENBQWUsWUFBZjtBQUNIOztBQUVEO0FBQ0EsaUJBQUssY0FBTCxHQUFzQixhQUF0QjtBQUNBLGlCQUFLLGNBQUwsR0FBc0IsU0FBdEI7O0FBRUEsaUJBQUssRUFBTCxDQUFRLFdBQVIsQ0FBb0IsS0FBSyxjQUF6QjtBQUNIOzs7a0NBRVM7QUFBQTs7QUFDTixnQkFBSSxlQUFlLCtCQUFnQixLQUFLLEVBQXJCLEVBQXlCLEdBQTVDOztBQUVBO0FBQ0EsZ0JBQUksa0JBQWtCLEtBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUI7QUFBQSx1QkFBWSwrQkFBZ0IsUUFBaEIsQ0FBWjtBQUFBLGFBQW5CLENBQXRCOztBQUVBO0FBQ0EsZ0JBQUksY0FBYyxLQUFLLE9BQUwsQ0FBYSxHQUFiLENBQWlCLGtCQUFVO0FBQ3pDO0FBQ0EsdUJBQU8sTUFBTSxJQUFOLENBQVcsT0FBTyxjQUFQLEVBQVgsRUFBb0MsR0FBcEMsQ0FBd0MsZ0JBQVE7QUFDbkQsMkJBQU87QUFDSCw2QkFBSyxLQUFLLEdBQUwsR0FBVyx3QkFBYyxjQUFkLENBQTZCLEdBQXhDLEdBQThDLGNBRGhEO0FBRUgsOEJBQU0sS0FBSyxJQUFMLEdBQVksd0JBQWMsY0FBZCxDQUE2QixJQUF6QyxHQUFnRCxjQUZuRDtBQUdILCtCQUFPLEtBQUssS0FBTCxHQUFjLElBQUksY0FIdEI7QUFJSCxnQ0FBUSxLQUFLLE1BQUwsR0FBZSxJQUFJO0FBSnhCLHFCQUFQO0FBTUgsaUJBUE0sQ0FBUDtBQVFILGFBVmlCLENBQWxCOztBQVlBO0FBQ0EsMEJBQWMsdUJBQVEsV0FBUixDQUFkOztBQXBCTSx1Q0FzQkcsQ0F0Qkg7QUF1QkYsb0JBQUksV0FBVyxPQUFLLGNBQUwsQ0FBb0IsQ0FBcEIsQ0FBZjtBQUNBLG9CQUFJLGtCQUFrQixnQkFBZ0IsQ0FBaEIsQ0FBdEI7QUFDQSxvQkFBSSxlQUFlLGdCQUFnQixJQUFJLENBQXBCLENBQW5COztBQUVBO0FBQ0Esb0JBQUksWUFBYSxJQUFJLENBQUosS0FBVSxDQUFYLEdBQWdCLENBQUMsQ0FBakIsR0FBcUIsQ0FBckM7O0FBRUE7QUFDQSxvQkFBSSxpQkFBaUIsYUFBYSxHQUFiLEdBQW1CLGdCQUFnQixHQUFuQyxHQUEwQyxnQkFBZ0IsTUFBaEIsR0FBeUIscUJBQXhGO0FBQ0Esb0JBQUksZ0JBQWdCLGlCQUFpQixnQkFBckM7QUFDQSxvQkFBSSxlQUFnQixZQUFZLENBQWIsR0FBa0IsQ0FBQyx3QkFBYyxLQUFkLEdBQXNCLGdCQUFnQixLQUF2QyxJQUFnRCxDQUFsRSxHQUF1RSx3QkFBYyxLQUFkLEdBQXNCLENBQXZCLElBQThCLGdCQUFpQixnQkFBZ0IsS0FBaEIsR0FBd0IsQ0FBdkUsQ0FBekY7QUFDQSxvQkFBSSxjQUFjLGdCQUFnQixHQUFoQixHQUFzQixnQkFBZ0IsTUFBeEQ7O0FBRUE7QUFDQSxnQ0FBTSxHQUFOLENBQVUsUUFBVixFQUFvQjtBQUNoQiwyQkFBTyxhQURTO0FBRWhCLDRCQUFRLGNBRlE7QUFHaEIseUJBQUssY0FBYyxZQUhIO0FBSWhCLDBCQUFNO0FBSlUsaUJBQXBCO0FBTUEseUJBQVMsS0FBVCxHQUFpQixhQUFqQjtBQUNBLHlCQUFTLE1BQVQsR0FBa0IsY0FBbEI7O0FBRUE7QUFDQSxvQkFBSSxNQUFNLFNBQVMsVUFBVCxDQUFvQixJQUFwQixDQUFWO0FBQ0Esb0JBQUksU0FBSixDQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0IsYUFBcEIsRUFBbUMsY0FBbkM7QUFDQSxvQkFBSSxTQUFKO0FBQ0Esb0JBQUksU0FBSixHQUFnQixDQUFoQjtBQUNBLG9CQUFJLFdBQUosR0FBa0Isa0JBQWxCO0FBQ0Esb0JBQUksV0FBSixDQUFnQixPQUFLLFFBQUwsQ0FBYyxHQUFkLElBQXFCLENBQUMsQ0FBRCxFQUFJLEVBQUosQ0FBckIsR0FBK0IsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUEvQyxFQXBERSxDQW9Ec0Q7QUFDeEQsb0JBQUksWUFBWSxDQUFoQixFQUFtQjtBQUNmLHdCQUFJLE1BQUosQ0FBVyxDQUFYLEVBQWMsQ0FBZDtBQUNBLHdCQUFJLGFBQUosQ0FDSSxnQkFBZ0IsSUFEcEIsRUFFSSxpQkFBaUIsSUFGckIsRUFHSSxnQkFBZ0IsSUFIcEIsRUFJSSxpQkFBaUIsSUFKckIsRUFLSSxDQUxKLEVBTUksY0FOSjtBQVFILGlCQVZELE1BVU87QUFDSCx3QkFBSSxNQUFKLENBQVcsYUFBWCxFQUEwQixDQUExQjtBQUNBLHdCQUFJLGFBQUosQ0FDSSxnQkFBaUIsZ0JBQWdCLElBRHJDLEVBRUksaUJBQWlCLElBRnJCLEVBR0ksZ0JBQWlCLGdCQUFnQixJQUhyQyxFQUlJLGlCQUFpQixJQUpyQixFQUtJLGFBTEosRUFNSSxjQU5KO0FBUUg7QUFDRCxvQkFBSSxNQUFKOztBQUVBO0FBQ0EsNEJBQVksT0FBWixDQUFxQixrQkFBVTs7QUFFM0Isd0JBQUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxPQUFPLElBQWhCLEVBQXNCLFlBQXRCLENBQVQ7QUFDQSx3QkFBSSxLQUFLLEtBQUssR0FBTCxDQUFTLE9BQU8sR0FBaEIsRUFBcUIsV0FBckIsQ0FBVDs7QUFFQSx3QkFBSSxLQUFLLEtBQUssR0FBTCxDQUFTLE9BQU8sSUFBUCxHQUFjLE9BQU8sS0FBOUIsRUFBcUMsZUFBZSxhQUFwRCxDQUFUO0FBQ0Esd0JBQUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxPQUFPLEdBQVAsR0FBYSxPQUFPLE1BQTdCLEVBQXFDLGNBQWMsY0FBbkQsQ0FBVDs7QUFFQTtBQUNBLHdCQUFLLEVBQUUsTUFBTSxFQUFOLElBQVksTUFBTSxFQUFwQixDQUFMLEVBQStCO0FBQzNCLDRCQUFJLFNBQUosQ0FBYyxPQUFPLElBQVAsR0FBYyxZQUE1QixFQUEwQyxPQUFPLEdBQVAsR0FBYSxXQUF2RCxFQUFvRSxPQUFPLEtBQTNFLEVBQWtGLE9BQU8sTUFBekY7QUFDSDtBQUVKLGlCQWJEO0FBN0VFOztBQXNCTixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssY0FBTCxDQUFvQixNQUF4QyxFQUFnRCxHQUFoRCxFQUFxRDtBQUFBLHNCQUE1QyxDQUE0QztBQXNFcEQ7QUFFSjs7QUFHRDs7Ozs7O3lDQUtpQjs7QUFFYjtBQUNBLGdCQUFLLEtBQUssUUFBTCxDQUFjLEdBQWQsQ0FBTCxFQUEwQjtBQUN0QixvQkFBSSxnQkFBZ0IsS0FBSyxHQUFMLENBQVUsS0FBSyxpQkFBZixFQUFrQyx3QkFBYyxjQUFkLENBQTZCLEdBQTdCLEdBQW1DLHdCQUFjLE1BQWpELEdBQTBELGNBQTVGLENBQXBCOztBQUVBLG9CQUFJLFdBQVcsZ0JBQWdCLEtBQUssaUJBQXBDOztBQUVBLHFCQUFLLGlCQUFMLEdBQXlCLGFBQXpCO0FBQ0EsZ0NBQU0sR0FBTixDQUFXLEtBQUssY0FBaEIsRUFBZ0M7QUFDNUIsNEJBQVMsS0FBSztBQUNkO0FBRjRCLGlCQUFoQztBQUlIO0FBQ0o7Ozs7OztrQkFLVSxZOzs7Ozs7Ozs7Ozs7O0FDMU5mOzs7O0FBQ0E7Ozs7QUFHQTs7Ozs7Ozs7OzsrZUFMQTs7O0FBSUE7OztBQUdBOzs7QUFHQTs7O0FBR0E7Ozs7O0FBS0EsSUFBTSxrQkFBa0Isb0NBQXhCO0FBQ0EsSUFBSSxzQkFBSjtBQUNBLElBQUksa0JBQWtCLEVBQXRCOztBQUVBLFNBQVMsT0FBVCxDQUFpQixRQUFqQixFQUEyQjs7QUFFdkI7QUFDQSxvQkFBZ0IsSUFBaEIsQ0FBcUIsUUFBckI7O0FBRUE7QUFDQSxXQUFPLHVCQUFQLEdBQWlDLFlBQVU7QUFDdkMsZ0JBQVEsR0FBUixDQUFZLE1BQVosRUFBb0IsT0FBTyxFQUEzQjtBQUNBO0FBQ0EsZUFBUSxnQkFBZ0IsTUFBaEIsR0FBeUIsQ0FBakMsRUFBcUM7QUFDakMsZ0JBQU0sT0FBTyxnQkFBZ0IsS0FBaEIsRUFBYjtBQUNBLGdCQUFJLEtBQUssT0FBTCxDQUFhLFFBQWpCLEVBQTJCO0FBQ3ZCLHFCQUFLLGFBQUwsQ0FBbUIsSUFBbkIsQ0FBd0IsSUFBeEI7QUFDSDtBQUNKO0FBQ0osS0FURDs7QUFXQTtBQUNBLFFBQUssQ0FBQyxhQUFOLEVBQXNCOztBQUVsQjtBQUNBLHdCQUFnQixTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBaEI7O0FBRUEsWUFBTSxjQUFjLFNBQVMsb0JBQVQsQ0FBOEIsUUFBOUIsRUFBd0MsQ0FBeEMsQ0FBcEI7QUFDQSxvQkFBWSxVQUFaLENBQXVCLFlBQXZCLENBQXFDLGFBQXJDLEVBQW9ELFdBQXBEOztBQUVBLHNCQUFjLEtBQWQsR0FBc0IsS0FBdEI7QUFDQSxzQkFBYyxHQUFkLEdBQW9CLGVBQXBCO0FBRUg7QUFDSjs7QUFFRCxJQUFNLGlCQUFpQjtBQUNuQixjQUFXO0FBRFEsQ0FBdkI7O0FBSUE7Ozs7SUFHTSxhOzs7QUFFRiwyQkFBWSxFQUFaLEVBQWdCLE9BQWhCLEVBQXlCO0FBQUE7O0FBQUEsa0lBRWYsRUFGZSxFQUVYLHdCQUFTLE9BQVQsRUFBa0IsY0FBbEIsQ0FGVzs7QUFJckIsY0FBSyxPQUFMLEdBQWlCLGFBQWEsT0FBZixHQUEwQixRQUFRLE9BQWxDLEdBQTRDLE1BQUssRUFBTCxDQUFRLFlBQVIsQ0FBcUIsZUFBckIsQ0FBM0Q7O0FBRUEsY0FBSyxlQUFMLEdBQXVCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsbUJBQXRCLENBQXZCOztBQUVBLFlBQUssQ0FBQyxNQUFLLGVBQVgsRUFBNkI7QUFDekIsa0JBQUssZUFBTCxHQUF1QixTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBdkI7QUFDQSxrQkFBSyxlQUFMLENBQXFCLFNBQXJCLEdBQWlDLGtCQUFqQztBQUNBLGtCQUFLLEVBQUwsQ0FBUSxXQUFSLENBQXFCLE1BQUssZUFBMUI7QUFDSDs7QUFFRDtBQUNBLFlBQUssT0FBTyxFQUFQLElBQWEsTUFBSyxPQUFMLENBQWEsUUFBL0IsRUFBMEM7QUFDdEMsa0JBQUssYUFBTDtBQUNILFNBRkQsTUFFTztBQUNIO0FBQ0g7O0FBbkJvQjtBQXFCeEI7O0FBRUQ7Ozs7OzswQ0FNa0IsVSxFQUFZLGtCLEVBQW9CLENBRWpEOzs7K0JBRU07QUFDSCxnQkFBSSxLQUFLLE9BQVQsRUFBa0I7QUFDZCxvQkFBSSxLQUFLLFlBQVQsRUFBdUI7QUFDbkIseUJBQUssT0FBTCxDQUFhLFNBQWI7QUFDSCxpQkFGRCxNQUVPO0FBQ0gseUJBQUssaUJBQUwsR0FBeUIsSUFBekI7QUFDSDtBQUNKLGFBTkQsTUFNTztBQUNILHFCQUFLLGlCQUFMLEdBQXlCLElBQXpCO0FBQ0EscUJBQUssYUFBTDtBQUNIO0FBQ0o7OztnQ0FFTztBQUNKLGdCQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkLHFCQUFLLE9BQUwsQ0FBYSxVQUFiO0FBQ0g7QUFDSjs7OytCQUVNO0FBQ0gsZ0JBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2QscUJBQUssT0FBTCxDQUFhLFNBQWI7QUFDSDtBQUNKOzs7a0NBRVM7QUFDTixpQkFBSyxPQUFMLENBQWEsT0FBYjtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozt3Q0FLZ0I7QUFDWixpQkFBSyxPQUFMLEdBQWUsSUFBSSxHQUFHLE1BQVAsQ0FBZSxLQUFLLGVBQXBCLEVBQXFDO0FBQ2hELHVCQUFVLE1BRHNDO0FBRWhELHdCQUFVLE1BRnNDO0FBR2hELHlCQUFVLEtBQUssT0FIaUM7QUFJaEQsNEJBQWE7QUFDVCxvQ0FBa0IsS0FEVDtBQUVULHlCQUFrQixLQUZULEVBRWdCO0FBQ3pCLDhCQUFrQixLQUhUO0FBSVQsMkJBQWtCLE9BSlQ7QUFLVCw0QkFBa0IsT0FBTyxRQUFQLENBQWdCO0FBTHpCLGlCQUptQztBQVdoRCx3QkFBVTtBQUNOLDZCQUFnQixLQUFLLG1CQUFMLENBQXlCLElBQXpCLENBQThCLElBQTlCLENBRFY7QUFFTixtQ0FBZ0IsS0FBSyx5QkFBTCxDQUErQixJQUEvQixDQUFvQyxJQUFwQztBQUZWO0FBWHNDLGFBQXJDLENBQWY7O0FBaUJBO0FBQ0EsZ0JBQUssQ0FBQyxLQUFLLE9BQUwsQ0FBYSxRQUFuQixFQUE4QjtBQUMxQixxQkFBSyxZQUFMLENBQW1CLGNBQWMsS0FBZCxDQUFvQixPQUF2QztBQUNIOztBQUVELGdCQUFLLEtBQUssT0FBTCxDQUFhLFFBQWxCLEVBQTZCO0FBQ3pCLHFCQUFLLElBQUw7QUFDSDtBQUVKOzs7cUNBRVksUSxFQUFVO0FBQUE7O0FBQ25CO0FBQ0EsZ0JBQUksYUFBYSxXQUFXLFFBQTVCOztBQUVBO0FBQ0EsbUNBQVEsY0FBYyxLQUF0QixFQUE2QixVQUFDLEtBQUQsRUFBVztBQUNwQyxvQkFBSSxVQUFVLFFBQWQsRUFBd0I7QUFDcEIsMkJBQUssRUFBTCxDQUFRLFNBQVIsQ0FBa0IsTUFBbEIsQ0FBeUIsV0FBVyxLQUFwQztBQUNIO0FBQ0osYUFKRDs7QUFNQSxpQkFBSyxFQUFMLENBQVEsU0FBUixDQUFrQixHQUFsQixDQUFzQixVQUF0Qjs7QUFFQTtBQUNBLGlCQUFLLEtBQUwsR0FBYSxRQUFiOztBQUVBO0FBQ0EsaUJBQUssT0FBTCxDQUFhLFFBQWI7QUFDSDs7QUFFRDs7Ozs7OzRDQUtvQixLLEVBQU87QUFDdkI7QUFDQSxpQkFBSyxlQUFMLEdBQXVCLEtBQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsbUJBQXRCLENBQXZCOztBQUVBLGlCQUFLLFlBQUwsR0FBb0IsSUFBcEI7O0FBRUE7QUFDQSxnQkFBSSxLQUFLLGlCQUFULEVBQTRCO0FBQ3hCLHFCQUFLLE9BQUwsQ0FBYSxTQUFiO0FBQ0EscUJBQUssaUJBQUwsR0FBeUIsS0FBekI7QUFDSDs7QUFFRCxpQkFBSyxPQUFMLENBQWEsT0FBYjtBQUNIOzs7a0RBRXlCLEssRUFBTzs7QUFFN0Isb0JBQVEsTUFBTSxJQUFkO0FBQ0kscUJBQUssR0FBRyxXQUFILENBQWUsT0FBcEI7O0FBRUc7Ozs7O0FBTUMseUJBQUssWUFBTCxDQUFrQixjQUFjLEtBQWQsQ0FBb0IsT0FBdEM7QUFDQTs7QUFFSixxQkFBSyxHQUFHLFdBQUgsQ0FBZSxTQUFwQjtBQUNJO0FBQ0E7QUFDQSx5QkFBSyxZQUFMLENBQWtCLGNBQWMsS0FBZCxDQUFvQixPQUF0QztBQUNBOztBQUVKLHFCQUFLLEdBQUcsV0FBSCxDQUFlLE1BQXBCO0FBQ0k7QUFDQSx5QkFBSyxZQUFMLENBQWtCLGNBQWMsS0FBZCxDQUFvQixNQUF0QztBQUNBOztBQUVKLHFCQUFLLEdBQUcsV0FBSCxDQUFlLEtBQXBCO0FBQ0k7QUFDQSx5QkFBSyxZQUFMLENBQWtCLGNBQWMsS0FBZCxDQUFvQixLQUF0QztBQUNBO0FBMUJSO0FBNEJIOzs7Ozs7QUFLTCxjQUFjLEtBQWQsR0FBc0I7QUFDbEIsYUFBUyxTQURTO0FBRWxCLGFBQVMsU0FGUztBQUdsQixhQUFTLFNBSFM7QUFJbEIsWUFBUSxRQUpVO0FBS2xCLFdBQU87QUFMVyxDQUF0Qjs7a0JBUWUsYTs7Ozs7Ozs7Ozs7QUNsUGY7Ozs7QUFDQTs7OztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUdBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBZEE7OztBQUlBOzs7QUFRQTs7O0FBSUE7QUFDQSxJQUFNLGVBQWUsR0FBckI7QUFDQSxJQUFNLGNBQWMsR0FBcEI7O0FBRUE7Ozs7SUFHTSxXOzs7QUFFRix5QkFBWSxFQUFaLEVBQWdCLE9BQWhCLEVBQXlCO0FBQUE7O0FBSXJCO0FBSnFCLDhIQUVmLEVBRmUsRUFFWCxPQUZXOztBQUtyQixjQUFLLFVBQUwsR0FBa0IsTUFBSyxFQUFMLENBQVEsYUFBUixDQUFzQixjQUF0QixDQUFsQjtBQUNBLGNBQUssWUFBTCxHQUFvQixNQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLGdCQUF0QixDQUFwQjs7QUFFQSxjQUFLLFVBQUwsR0FBa0IsTUFBTSxJQUFOLENBQVksTUFBSyxFQUFMLENBQVEsZ0JBQVIsQ0FBeUIsaUNBQXpCLENBQVosQ0FBbEI7QUFDQSxjQUFLLE1BQUwsR0FBYyxNQUFLLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBcUI7QUFBQSxtQkFBUyxNQUFNLFlBQU4sQ0FBbUIsWUFBbkIsQ0FBVDtBQUFBLFNBQXJCLENBQWQ7O0FBRUEsY0FBSyxhQUFMLEdBQXFCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsMkNBQXRCLENBQXJCOztBQUVBOzs7O0FBSUEsY0FBSyxZQUFMLEdBQW9CLEVBQXBCOztBQUVBO0FBQ0EsY0FBSyxZQUFMLEdBQW9CLEVBQXBCOztBQUVBLGNBQUssVUFBTCxDQUFnQixHQUFoQixDQUFxQjtBQUFBLG1CQUFTLE1BQU0sWUFBTixDQUFtQixlQUFuQixDQUFUO0FBQUEsU0FBckIsRUFBb0UsT0FBcEUsQ0FBNkU7QUFBQSxtQkFBVyxNQUFLLFlBQUwsQ0FBbUIsT0FBbkIsSUFBK0IsQ0FBMUM7QUFBQSxTQUE3RTs7QUFFQSxjQUFLLGNBQUwsR0FBc0IsTUFBSyxFQUFMLENBQVEsYUFBUixDQUFzQixvREFBdEIsQ0FBdEI7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FBVUEsY0FBSyxXQUFMLEdBQW1CLDhCQUFnQixNQUFLLFVBQUwsQ0FBZ0IsTUFBaEMsRUFBd0MsWUFBeEMsQ0FBbkI7O0FBRUEsY0FBSyxZQUFMLEdBQW9CLE1BQUssVUFBTCxDQUFnQixHQUFoQixDQUFxQixVQUFDLEtBQUQsRUFBVztBQUNoRCxnQkFBSSxlQUFlLE1BQU0sYUFBTixDQUFvQixTQUFwQixDQUFuQjtBQUNBLG1CQUFPLDZCQUFvQixZQUFwQixFQUFrQyxFQUFDLEtBQUssRUFBTixFQUFVLFVBQVUsS0FBcEIsRUFBMkIsTUFBTSxLQUFqQyxFQUF3QyxXQUFXLEVBQW5ELEVBQXVELEtBQUssYUFBYSxZQUFiLENBQTBCLFVBQTFCLENBQTVELEVBQWxDLENBQVA7QUFDSCxTQUhtQixDQUFwQjs7QUFLQTtBQUNBLGNBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixNQUFLLHNCQUEvQixFQUF1RCxhQUF2RDs7QUFFQSxjQUFLLGlCQUFMOztBQS9DcUI7QUFtRHhCOztBQUVEOzs7Ozs7eUNBTWlCO0FBQUE7O0FBRWI7O0FBRUEsdUJBQVksWUFBTTtBQUNkLHVCQUFLLFVBQUwsQ0FBZ0IsU0FBaEIsQ0FBMEIsTUFBMUIsQ0FBaUMsUUFBakM7QUFDQSxvQkFBSSxZQUFZLE9BQUssYUFBTCxDQUFtQixhQUFuQixDQUFpQyxzQkFBakMsQ0FBaEI7O0FBRUE7QUFDQSx1Q0FBTTtBQUNGLDZCQUFVLFNBRFI7QUFFRiw2QkFBVSxDQUFDLENBQUQsRUFBSSxDQUFKLENBRlI7QUFHRiw0QkFBUyxhQUhQO0FBSUYsOEJBQVU7QUFKUixpQkFBTjtBQU9ILGFBWkQsRUFZRyxXQVpIOztBQWNBLGlCQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsQ0FBeUIsVUFBQyxLQUFELEVBQVEsQ0FBUixFQUFjO0FBQ25DLDJCQUFZLFlBQU07QUFDZCwwQkFBTSxTQUFOLENBQWdCLE1BQWhCLENBQXVCLFFBQXZCO0FBQ0gsaUJBRkQsRUFFSSxDQUFDLElBQUksQ0FBTCxJQUFVLEdBQVgsR0FBa0IsV0FGckI7QUFHSCxhQUpEO0FBTUg7O0FBRUQ7Ozs7Ozs0Q0FNb0I7QUFBQTs7QUFDaEI7QUFDQSxnQkFBSSxNQUFNLEtBQUssVUFBTCxDQUFnQixVQUFoQixDQUEyQixJQUEzQixDQUFWOztBQUVBLDRDQUFpQixHQUFqQixFQUFzQixLQUFLLE1BQTNCLEVBQW1DLEtBQUssV0FBeEMsRUFBcUQsWUFBckQ7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDQTtBQUNBLGlCQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsQ0FBeUIsVUFBQyxLQUFELEVBQVEsQ0FBUixFQUFjO0FBQ25DLG9CQUFJLFFBQVEsT0FBSyxXQUFMLENBQWlCLENBQWpCLENBQVo7O0FBRUEsZ0NBQU0sR0FBTixDQUFXLEtBQVgsRUFBa0I7QUFDZCx5QkFBTSxNQUFNLENBREU7QUFFZCwwQkFBTSxNQUFNO0FBRkUsaUJBQWxCO0FBSUgsYUFQRDtBQVNIOzs7dUNBRWM7QUFBQTs7QUFDWCxnQkFBSSxNQUFNLEtBQUssWUFBTCxDQUFrQixVQUFsQixDQUE2QixJQUE3QixDQUFWOztBQUVBO0FBQ0EsZ0JBQUksU0FBSixDQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0IsZUFBZSxDQUFuQyxFQUFzQyxlQUFlLENBQXJEOztBQUVBLGlCQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBMkIsVUFBQyxLQUFELEVBQVc7O0FBRWxDO0FBQ0Esb0JBQUksVUFBVSxNQUFNLFlBQU4sQ0FBbUIsZUFBbkIsQ0FBZDtBQUNBLG9CQUFJLGFBQWEsT0FBSyxVQUFMLENBQWdCLE9BQWhCLENBQXlCLEtBQXpCLENBQWpCO0FBQ0Esb0JBQUksYUFBYSxPQUFLLFdBQUwsQ0FBa0IsVUFBbEIsQ0FBakI7O0FBRUE7QUFDQSxvQkFBSSxTQUFKO0FBQ0Esb0JBQUksU0FBSixHQUFnQixDQUFoQjtBQUNBLG9CQUFJLFdBQUosR0FBa0Isa0JBQWxCO0FBQ0Esb0JBQUksV0FBSixDQUFnQixDQUFDLENBQUQsRUFBSSxFQUFKLENBQWhCOztBQUVBO0FBQ0Esb0JBQUksZUFBZSxDQUFmLElBQW9CLGVBQWUsQ0FBdkMsRUFBMEM7O0FBRXRDLHdCQUFJLGFBQWEsT0FBSyxXQUFMLENBQWtCLFVBQWxCLENBQWpCOztBQUVBLHdCQUFJLE9BQU8sWUFBWDtBQUNBLHdCQUFJLE9BQU8sZUFBZ0IsQ0FBQyxXQUFXLENBQVgsR0FBZSxZQUFoQixLQUFpQyxJQUFJLE9BQUssWUFBTCxDQUFrQixPQUFsQixDQUFyQyxDQUEzQjs7QUFFQSx3QkFBSSxNQUFKLENBQVksV0FBVyxDQUF2QixFQUEwQixXQUFXLENBQXJDO0FBQ0Esd0JBQUksTUFBSixDQUFZLElBQVosRUFBa0IsSUFBbEI7QUFFSCxpQkFWRCxNQVVPO0FBQ0g7QUFDQSx3QkFBSSxzQkFBSjs7QUFFQTtBQUNBLHdCQUFJLHFCQUFKOztBQUVBLDRCQUFRLFVBQVI7QUFDSSw2QkFBSyxDQUFMO0FBQ0ksNENBQWdCLE9BQUssV0FBTCxDQUFpQixhQUFhLENBQTlCLENBQWhCO0FBQ0EsMkNBQWUsS0FBZjtBQUNBO0FBQ0osNkJBQUssQ0FBTDtBQUNJLDRDQUFnQixPQUFLLFdBQUwsQ0FBaUIsYUFBYSxDQUE5QixDQUFoQjtBQUNBLDJDQUFlLElBQWY7QUFDQTtBQUNKLDZCQUFLLENBQUw7QUFDSSw0Q0FBZ0IsT0FBSyxXQUFMLENBQWlCLGFBQWEsQ0FBOUIsQ0FBaEI7QUFDQSwyQ0FBZSxLQUFmO0FBQ0E7QUFDSiw2QkFBSyxDQUFMO0FBQ0ksNENBQWdCLE9BQUssV0FBTCxDQUFpQixhQUFhLENBQTlCLENBQWhCO0FBQ0EsMkNBQWUsSUFBZjtBQUNBOztBQUVKO0FBQ0ksNENBQWdCLE9BQUssV0FBTCxDQUFpQixDQUFqQixDQUFoQjtBQW5CUjs7QUFzQkE7QUFDQTtBQUNBLHdCQUFJLGNBQWMsb0JBQVcsQ0FBQyxlQUFlLFdBQVcsQ0FBMUIsR0FBOEIsY0FBYyxDQUE3QyxJQUFrRCxDQUE3RCxFQUFnRSxDQUFDLGVBQWUsV0FBVyxDQUExQixHQUE4QixjQUFjLENBQTdDLElBQWtELENBQWxILENBQWxCO0FBQ0Esd0JBQUksY0FBYSxvQkFBVyxZQUFYLEVBQXlCLFlBQXpCLENBQWpCLENBaENHLENBZ0N1RDs7QUFFMUQ7QUFDQSx3QkFBSSxZQUFZLGVBQWUsS0FBSyxJQUFMLENBQVcsQ0FBWCxDQUEvQjs7QUFFQTtBQUNBO0FBQ0Esd0JBQUksUUFBUSxnQkFBTSxRQUFOLENBQWdCLFVBQWhCLEVBQTRCLFdBQTVCLENBQVo7QUFDQSx3QkFBSSxRQUFRLGdCQUFNLFFBQU4sQ0FBZ0IsVUFBaEIsRUFBNEIsV0FBNUIsQ0FBWjtBQUNBLHdCQUFJLFFBQVEsZ0JBQU0sUUFBTixDQUFnQixXQUFoQixFQUE0QixXQUE1QixDQUFaOztBQUVBO0FBQ0Esd0JBQUksV0FBVyxLQUFLLElBQUwsQ0FBVyxDQUFFLFFBQVEsS0FBVCxHQUFtQixRQUFRLEtBQTNCLEdBQXFDLFFBQVEsS0FBOUMsS0FBeUQsSUFBSSxLQUFKLEdBQVksS0FBckUsQ0FBWCxDQUFmO0FBQ0Esd0JBQUksVUFBVyxLQUFLLEVBQUwsR0FBVSxDQUFYLEdBQWdCLE9BQUssVUFBTCxDQUFnQixNQUE5QyxDQTdDRyxDQTZDbUQ7O0FBRXRELHdCQUFJLG1CQUFKO0FBQUEsd0JBQWdCLGlCQUFoQjs7QUFFQTtBQUNBLHdCQUFJLGNBQWMsV0FBVyxPQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBN0I7O0FBRUEsNEJBQVEsVUFBUjtBQUNJLDZCQUFLLENBQUw7QUFDSSx5Q0FBYSxLQUFLLEVBQUwsR0FBVSxRQUF2QixDQURKLENBQ3FDO0FBQ2pDLHVDQUFXLGFBQWEsV0FBeEI7QUFDQTtBQUNKLDZCQUFLLENBQUw7QUFDSSx5Q0FBYSxLQUFLLEVBQUwsR0FBVyxVQUFXLFVBQW5DO0FBQ0EsdUNBQVcsYUFBYSxXQUF4QjtBQUNBO0FBQ0osNkJBQUssQ0FBTDtBQUNJLHlDQUFhLFVBQVUsQ0FBdkI7QUFDQSx1Q0FBVyxhQUFhLFdBQXhCO0FBQ0E7QUFDSiw2QkFBSyxDQUFMO0FBQ0kseUNBQWEsS0FBSyxFQUFMLEdBQVcsVUFBVyxVQUFuQztBQUNBLHVDQUFXLGFBQWEsV0FBeEI7QUFDQTtBQWhCUjs7QUFtQkEsd0JBQUksR0FBSixDQUFTLFlBQVksQ0FBckIsRUFBd0IsWUFBWSxDQUFwQyxFQUF1QyxTQUF2QyxFQUFrRCxVQUFsRCxFQUE4RCxRQUE5RCxFQUF3RSxDQUFDLFlBQXpFO0FBQ0g7O0FBRUQsb0JBQUksTUFBSjtBQUNBLG9CQUFJLFNBQUo7QUFFSCxhQXJHRDs7QUF1R0E7QUFDQTtBQUNBLGdCQUFJLFNBQUosQ0FDSSxLQUFLLGNBQUwsQ0FBb0IsVUFEeEIsRUFFSSxLQUFLLGNBQUwsQ0FBb0IsU0FGeEIsRUFHSSxLQUFLLGNBQUwsQ0FBb0IsV0FIeEIsRUFJSSxLQUFLLGNBQUwsQ0FBb0IsWUFKeEI7QUFNSDs7QUFFRDs7Ozs7Ozs7dUNBS2dCLEssRUFBUTtBQUNwQjtBQUNBLGdCQUFLLEtBQUssWUFBTCxDQUFrQixNQUFsQixLQUE2QixDQUFsQyxFQUFxQztBQUNqQztBQUNBLHFCQUFLLGdCQUFMLENBQXVCLEtBQUssWUFBTCxDQUFrQixDQUFsQixDQUF2QjtBQUNIOztBQUVEO0FBQ0EsZ0JBQUksYUFBYSxxQkFBTyxLQUFQLENBQWpCOztBQUVBLGdCQUFJLFNBQVMsTUFBTSxhQUFOLENBQW9CLFFBQXBCLENBQWI7QUFDQSxnQkFBSSxXQUFXLE9BQU8sYUFBUCxDQUFxQixhQUFyQixDQUFmOztBQUVBLGtCQUFNLFNBQU4sQ0FBZ0IsR0FBaEIsQ0FBb0IsUUFBcEI7QUFDQSw0QkFBTSxHQUFOLENBQVcsUUFBWCxFQUFxQixFQUFDLGlCQUFpQixLQUFLLE1BQUwsQ0FBWSxVQUFaLENBQWxCLEVBQXJCOztBQUVBO0FBQ0EsaUJBQUssWUFBTCxDQUFrQixJQUFsQixDQUF3QixLQUF4Qjs7QUFFQSxnQkFBSSxjQUFjLEtBQUssWUFBTCxDQUFtQixVQUFuQixDQUFsQjtBQUNBLHdCQUFZLEVBQVosQ0FBZSxLQUFmLENBQXFCLE9BQXJCLEdBQStCLENBQS9CO0FBQ0Esd0JBQVksSUFBWjs7QUFFQSxpQkFBSyxrQkFBTDtBQUNIOzs7eUNBRWlCLEssRUFBUTtBQUN0QjtBQUNBLGdCQUFJLGFBQWEscUJBQU8sS0FBUCxDQUFqQjtBQUNBLGdCQUFJLFVBQVUsTUFBTSxZQUFOLENBQW1CLGVBQW5CLENBQWQ7QUFDQSxnQkFBSSxTQUFTLE1BQU0sYUFBTixDQUFvQixRQUFwQixDQUFiO0FBQ0EsZ0JBQUksV0FBVyxPQUFPLGFBQVAsQ0FBcUIsYUFBckIsQ0FBZjs7QUFFQSxpQkFBSyxZQUFMLENBQWtCLE1BQWxCLENBQTBCLEtBQUssWUFBTCxDQUFrQixPQUFsQixDQUEwQixLQUExQixDQUExQixFQUE0RCxDQUE1RDtBQUNBLGtCQUFNLFNBQU4sQ0FBZ0IsTUFBaEIsQ0FBdUIsUUFBdkI7QUFDQSw0QkFBTSxHQUFOLENBQVcsUUFBWCxFQUFxQixFQUFDLGlCQUFpQixJQUFsQixFQUFyQjs7QUFFQTtBQUNBLGlCQUFLLFlBQUwsQ0FBbUIsT0FBbkIsSUFBK0IsQ0FBL0I7O0FBRUE7QUFDQSxtQ0FBTTtBQUNGLHlCQUFVLEtBQUssWUFBTCxDQUFtQixVQUFuQixFQUFnQyxFQUR4QztBQUVGLDBCQUFXLElBRlQ7QUFHRix5QkFBVTtBQUhSLGFBQU47O0FBTUEsaUJBQUssa0JBQUw7QUFDSDs7OzhDQUVxQixRLEVBQVU7O0FBRTVCLGdCQUFLLEtBQUssY0FBVixFQUEyQjtBQUN2Qix1Q0FBTTtBQUNGLDZCQUFjLEtBQUssY0FEakI7QUFFRiw2QkFBYyxDQUZaO0FBR0YsOEJBQWMsR0FIWjtBQUlGLDRCQUFjLGNBSlo7QUFLRiw4QkFBYyxvQkFBTTtBQUNoQjtBQUNIO0FBUEMsaUJBQU47QUFTSCxhQVZELE1BVU87QUFDSDtBQUNIO0FBRUo7O0FBRUQ7Ozs7Ozs7NkNBSXFCO0FBQUE7O0FBRWpCO0FBQ0EsZ0JBQUksZ0JBQUo7O0FBRUEsZ0JBQUksS0FBSyxZQUFMLENBQWtCLE1BQWxCLEtBQTZCLENBQWpDLEVBQW9DO0FBQ2hDLDBCQUFVLEtBQUssWUFBTCxDQUFrQixDQUFsQixFQUFxQixZQUFyQixDQUFrQyxlQUFsQyxDQUFWO0FBQ0gsYUFGRCxNQUVPLElBQUksS0FBSyxZQUFMLENBQWtCLE1BQWxCLEtBQTZCLENBQWpDLEVBQW9DOztBQUV2QyxvQkFBSSxTQUFTLEtBQUssWUFBTCxDQUFrQixDQUFsQixDQUFiO0FBQ0Esb0JBQUksU0FBUyxLQUFLLFlBQUwsQ0FBa0IsQ0FBbEIsQ0FBYjs7QUFFQSxvQkFBSSxTQUFTLHFCQUFNLE1BQU4sQ0FBYjtBQUNBLG9CQUFJLFNBQVMscUJBQU0sTUFBTixDQUFiOztBQUVBO0FBQ0EsMEJBQVksU0FBUyxNQUFYLEdBQXlCLE9BQU8sWUFBUCxDQUFvQixlQUFwQixDQUF6QixTQUFpRSxPQUFPLFlBQVAsQ0FBb0IsZUFBcEIsQ0FBakUsR0FBNkcsT0FBTyxZQUFQLENBQW9CLGVBQXBCLENBQTdHLFNBQXFKLE9BQU8sWUFBUCxDQUFvQixlQUFwQixDQUEvSjs7QUFFQTtBQUNBO0FBQ0E7O0FBR0gsYUFoQk0sTUFnQkE7QUFDSDtBQUNBLHFCQUFLLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBNkIsSUFBN0IsRUFBbUMsU0FBbkMsQ0FBNkMsQ0FBN0MsRUFBZ0QsQ0FBaEQsRUFBbUQsZUFBZSxDQUFsRSxFQUFxRSxlQUFlLENBQXBGO0FBQ0g7O0FBRUQ7QUFDQSxnQkFBSSxPQUFKLEVBQWE7O0FBRVQ7QUFDQSxvQkFBSSxZQUFZLEtBQUssRUFBTCxDQUFRLGFBQVIsMkRBQThFLE9BQTlFLFNBQTJGLFNBQTNGLENBQXFHLElBQXJHLENBQWhCOztBQUVBLHFCQUFLLHFCQUFMLENBQTRCLFlBQU07QUFDOUIseUNBQU8sT0FBSyxhQUFaOztBQUVBO0FBQ0EsMkJBQUssY0FBTCxHQUFzQixTQUF0Qjs7QUFFQSw4QkFBVSxLQUFWLENBQWdCLE9BQWhCLEdBQTBCLENBQTFCO0FBQ0EsMkNBQU07QUFDRixpQ0FBYyxTQURaO0FBRUYsaUNBQWMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUZaO0FBR0Ysa0NBQWMsR0FIWjtBQUlGLGdDQUFjO0FBSloscUJBQU47O0FBT0EsMkJBQUssYUFBTCxDQUFtQixXQUFuQixDQUFnQyxTQUFoQztBQUNILGlCQWZEOztBQWlCQTtBQUNBLHdCQUFRLEtBQVIsQ0FBYyxHQUFkLEVBQW1CLE9BQW5CLENBQTRCLHFCQUFhOztBQUVyQyx3QkFBSSxlQUFlLE9BQUssWUFBTCxDQUFtQixTQUFuQixDQUFuQjs7QUFFQTtBQUNBLHdCQUFJLGVBQWUsQ0FBbkIsRUFBc0I7QUFDbEI7QUFDQSw0QkFBSSxZQUFZO0FBQ1oscUNBQVUsT0FBSyxZQURIO0FBRVosc0NBQVcsSUFGQztBQUdaLG9DQUFTLGVBSEc7QUFJWixvQ0FBUyxrQkFBTTtBQUNYLHVDQUFLLFlBQUw7QUFDSDtBQU5XLHlCQUFoQjs7QUFTQTtBQUNBLGtDQUFXLFNBQVgsSUFBeUIsQ0FBQyxZQUFELEVBQWUsQ0FBZixDQUF6Qjs7QUFFQTtBQUNBLCtDQUFNLFNBQU47QUFDSDtBQUVKLGlCQXZCRDtBQXlCSDs7QUFFRDtBQUNBLGlCQUFLLFlBQUw7QUFFSDs7QUFJRDs7Ozs7OytDQUt1QixLLEVBQU87O0FBRTFCLGdCQUFLLE1BQU0sY0FBTixDQUFxQixTQUFyQixDQUErQixRQUEvQixDQUF3QyxRQUF4QyxDQUFMLEVBQXlEO0FBQ3JELHFCQUFLLGdCQUFMLENBQXVCLE1BQU0sY0FBN0I7QUFDSCxhQUZELE1BRU87QUFDSCxxQkFBSyxjQUFMLENBQXFCLE1BQU0sY0FBM0I7QUFDSDtBQUVKOzs7Ozs7a0JBS1UsVzs7Ozs7Ozs7Ozs7QUNqZGY7Ozs7QUFHQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFHQTs7OztBQUNBOzs7Ozs7Ozs7OytlQWJBOzs7QUFHQTs7O0FBUUE7OztBQUlBO0FBQ0EsSUFBTSxlQUFlLEdBQXJCLEMsQ0FBMEI7QUFDMUIsSUFBTSxvQkFBb0IsTUFBTSxLQUFLLEVBQUwsR0FBVSxHQUFoQixDQUExQjs7QUFFQTs7OztJQUdNLGdCOzs7QUFFRiw4QkFBWSxFQUFaLEVBQWdCLE9BQWhCLEVBQXlCO0FBQUE7O0FBSXJCO0FBSnFCLHdJQUVmLEVBRmUsRUFFWCxPQUZXOztBQUtyQixjQUFLLFdBQUwsQ0FBaUIsT0FBakIsRUFBMEIsTUFBSyxpQkFBL0IsRUFBa0QsaUNBQWxEOztBQUVBO0FBQ0EsY0FBSyxTQUFMLEdBQWlCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsY0FBdEIsQ0FBakI7QUFDQSxjQUFLLGFBQUwsR0FBc0IsTUFBTSxJQUFOLENBQVksTUFBSyxTQUFMLENBQWUsZ0JBQWYsQ0FBZ0MsYUFBaEMsQ0FBWixDQUF0Qjs7QUFFQSxjQUFLLFVBQUwsR0FBa0IsTUFBSyxTQUFMLENBQWUsU0FBZixDQUF5QixJQUF6QixDQUFsQjtBQUNBLGNBQUssVUFBTCxHQUFrQixNQUFLLFNBQUwsQ0FBZSxTQUFmLENBQXlCLElBQXpCLENBQWxCOztBQUVBO0FBQ0Esd0JBQU0sR0FBTixDQUFXLE1BQUssU0FBaEIsRUFBMkIsRUFBQyxTQUFTLE1BQVYsRUFBM0I7O0FBRUEsY0FBSyxlQUFMLEdBQXVCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0Isb0NBQXRCLENBQXZCO0FBQ0EsY0FBSyxlQUFMLEdBQXVCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsbUNBQXRCLENBQXZCOztBQUVBO0FBQ0EsY0FBSyxXQUFMLEdBQW1CLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsdURBQXRCLENBQW5CO0FBQ0EsY0FBSyxXQUFMLEdBQW1CLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0Isc0RBQXRCLENBQW5COztBQUVBLGNBQUssZUFBTCxDQUFxQixXQUFyQixDQUFrQyxNQUFLLFVBQXZDO0FBQ0EsY0FBSyxlQUFMLENBQXFCLFdBQXJCLENBQWtDLE1BQUssVUFBdkM7O0FBRUEsY0FBSyxjQUFMLEdBQXNCLENBQXRCO0FBQ0EsY0FBSyxjQUFMLEdBQXNCLENBQXRCOztBQUVBLGNBQUssYUFBTCxHQUFxQjtBQUNqQixlQUFJLElBRGE7QUFFakIsZUFBSTtBQUZhLFNBQXJCOztBQUtBLGNBQUssYUFBTCxHQUFxQixNQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLDZCQUF0QixDQUFyQjs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBV0E7QUFDQSxjQUFLLE1BQUwsR0FBYyxNQUFLLGFBQUwsQ0FBbUIsR0FBbkIsQ0FBd0I7QUFBQSxtQkFBTSxHQUFHLFlBQUgsQ0FBZ0IsWUFBaEIsQ0FBTjtBQUFBLFNBQXhCLENBQWQ7O0FBRUE7QUFDQTs7QUFFQSxjQUFLLFdBQUwsR0FBbUIsRUFBbkI7O0FBRUEsWUFBSSxtQkFBb0IsSUFBSyxLQUFLLEtBQUwsQ0FBWSxJQUFJLENBQWhCLElBQXNCLGlCQUFuRDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFLLGFBQUwsQ0FBbUIsTUFBdkMsRUFBK0MsR0FBL0MsRUFBcUQ7O0FBRWpEO0FBQ0EsZ0JBQUksUUFBUSxtQkFBb0IsSUFBSSxpQkFBcEM7QUFDQSxnQkFBSSxJQUFJLGVBQWUsS0FBSyxHQUFMLENBQVMsS0FBVCxJQUFrQixZQUF6QztBQUNBLGdCQUFJLElBQUksZUFBZSxLQUFLLEdBQUwsQ0FBUyxLQUFULElBQWtCLFlBQXpDOztBQUVBLGtCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBdUIsb0JBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsS0FBaEIsRUFBdUIsWUFBdkIsQ0FBdkI7QUFFSDs7QUFFRCxjQUFLLGlCQUFMOztBQUVBLGNBQUssZUFBTDtBQXpFcUI7QUEwRXhCOztBQUVEOzs7Ozs7O3lDQUtpQjs7QUFFYixrQkFBTSxJQUFOLENBQVksS0FBSyxVQUFMLENBQWdCLGdCQUFoQixDQUFpQyxvQkFBakMsQ0FBWixFQUFxRSxPQUFyRSxDQUE4RTtBQUFBLHVCQUFRLEtBQUssU0FBTCxDQUFlLE1BQWYsQ0FBc0IsUUFBdEIsQ0FBUjtBQUFBLGFBQTlFO0FBQ0Esa0JBQU0sSUFBTixDQUFZLEtBQUssVUFBTCxDQUFnQixnQkFBaEIsQ0FBaUMsb0JBQWpDLENBQVosRUFBcUUsT0FBckUsQ0FBOEU7QUFBQSx1QkFBUSxLQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXNCLFFBQXRCLENBQVI7QUFBQSxhQUE5RTtBQUVIOztBQUVEOzs7Ozs7dUNBTWUsVSxFQUF5QjtBQUFBLGdCQUFiLEtBQWEsdUVBQUwsR0FBSzs7O0FBRXBDLGlCQUFLLGtCQUFnQixNQUFNLFdBQU4sRUFBckIsSUFBNEMsVUFBNUM7O0FBRUEsaUJBQUssYUFBTCxDQUFtQixLQUFuQixJQUE0QixVQUE1Qjs7QUFFQSxpQkFBSyxjQUFZLE1BQU0sV0FBTixFQUFqQixFQUFzQyxRQUF0QyxDQUErQyxVQUEvQyxFQUEyRCxTQUEzRCxDQUFxRSxHQUFyRSxDQUF5RSxRQUF6RTtBQUVIOzs7eUNBRWdCLFUsRUFBeUI7QUFBQSxnQkFBYixLQUFhLHVFQUFMLEdBQUs7O0FBQ3RDLGlCQUFLLGFBQUwsQ0FBbUIsS0FBbkIsSUFBNEIsSUFBNUI7O0FBRUEsaUJBQUssY0FBWSxNQUFNLFdBQU4sRUFBakIsRUFBc0MsUUFBdEMsQ0FBK0MsVUFBL0MsRUFBMkQsU0FBM0QsQ0FBcUUsTUFBckUsQ0FBNEUsUUFBNUU7O0FBRUE7QUFDQTtBQUNIOzs7MENBRWlCO0FBQUE7O0FBRWQ7Ozs7QUFNQSxnQkFBSSxpQkFBaUIsRUFBckI7QUFDQSxnQkFBSSxjQUFjLElBQUksS0FBSyxjQUEzQixDQVRjLENBUzZCO0FBQzNDLDBCQUFlLGNBQWMsQ0FBZixHQUFvQixjQUFjLEtBQUssYUFBTCxDQUFtQixNQUFyRCxHQUE4RCxXQUE1RTs7QUFFQSxnQkFBSSxVQUFVLE1BQU0sSUFBTixDQUFZLEtBQUssVUFBTCxDQUFnQixnQkFBaEIsQ0FBaUMsYUFBakMsQ0FBWixDQUFkOztBQUVBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyxvQkFBSSxlQUFlLFFBQVEsQ0FBUixDQUFuQjs7QUFFQTtBQUNBLDZDQUFlLFlBQWYsRUFBNkIsU0FBN0I7QUFDQSxvQkFBSyxnQkFBZ0IsQ0FBckIsRUFBeUI7QUFDckIsaUNBQWEsU0FBYixDQUF1QixHQUF2QixDQUEyQixnQkFBM0I7QUFDSCxpQkFGRCxNQUVPLElBQUssRUFBRSxnQkFBZ0IsQ0FBaEIsSUFBcUIsZ0JBQWdCLENBQXZDLENBQUwsRUFBaUQ7QUFDcEQsaUNBQWEsU0FBYixDQUF1QixHQUF2QixDQUEyQixXQUEzQjtBQUNIOztBQUVELCtCQUFnQixhQUFoQixJQUFrQyxZQUFsQztBQUNBLDhCQUFnQixjQUFjLFFBQVEsTUFBeEIsR0FBa0MsV0FBbEMsR0FBZ0QsQ0FBOUQ7QUFDSDs7QUFFRCwyQkFBZSxPQUFmLENBQXdCLFVBQUMsSUFBRCxFQUFPLENBQVAsRUFBYTtBQUNqQyxnQ0FBTSxHQUFOLENBQVUsSUFBVixFQUFnQjtBQUNaLHlCQUFNLE9BQUssV0FBTCxDQUFrQixDQUFsQixFQUFzQixDQURoQjtBQUVaLDBCQUFNLE9BQUssV0FBTCxDQUFrQixDQUFsQixFQUFzQjtBQUZoQixpQkFBaEI7QUFJSCxhQUxEOztBQVFBOzs7QUFLQSxnQkFBSSxpQkFBaUIsRUFBckI7QUFDQSxnQkFBSSxjQUFjLElBQUksS0FBSyxjQUEzQixDQTNDYyxDQTJDNkI7QUFDM0MsMEJBQWUsY0FBYyxDQUFmLEdBQW9CLGNBQWMsS0FBSyxhQUFMLENBQW1CLE1BQXJELEdBQThELFdBQTVFOztBQUVBLGdCQUFJLFVBQVUsTUFBTSxJQUFOLENBQVksS0FBSyxVQUFMLENBQWdCLGdCQUFoQixDQUFpQyxhQUFqQyxDQUFaLENBQWQ7O0FBRUEsaUJBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxRQUFRLE1BQTVCLEVBQW9DLElBQXBDLEVBQXlDO0FBQ3JDLG9CQUFJLGdCQUFlLFFBQVEsRUFBUixDQUFuQjs7QUFFQTtBQUNBLDZDQUFlLGFBQWYsRUFBNkIsU0FBN0I7QUFDQSxvQkFBSyxnQkFBZ0IsQ0FBckIsRUFBeUI7QUFDckIsa0NBQWEsU0FBYixDQUF1QixHQUF2QixDQUEyQixnQkFBM0I7QUFDSCxpQkFGRCxNQUVPLElBQUssRUFBRSxnQkFBZ0IsQ0FBaEIsSUFBcUIsZ0JBQWdCLENBQXZDLENBQUwsRUFBaUQ7QUFDcEQsa0NBQWEsU0FBYixDQUF1QixHQUF2QixDQUEyQixXQUEzQjtBQUNIOztBQUVELCtCQUFnQixhQUFoQixJQUFrQyxhQUFsQztBQUNBLDhCQUFnQixjQUFjLFFBQVEsTUFBeEIsR0FBa0MsV0FBbEMsR0FBZ0QsQ0FBOUQ7QUFDSDs7QUFHRCwyQkFBZSxPQUFmLENBQXdCLFVBQUMsSUFBRCxFQUFPLENBQVAsRUFBYTs7QUFFakMsb0JBQUksSUFBSSxPQUFLLFdBQUwsQ0FBa0IsQ0FBbEIsRUFBc0IsQ0FBOUI7QUFDQSxvQkFBSSxJQUFJLE9BQUssV0FBTCxDQUFrQixDQUFsQixFQUFzQixDQUE5Qjs7QUFFQSxvQkFBSSxnQkFBZ0IsSUFBSSxZQUFwQixDQUFKOztBQUVBLGdDQUFNLEdBQU4sQ0FBVyxJQUFYLEVBQWlCO0FBQ2IseUJBQU0sQ0FETztBQUViLDBCQUFNO0FBRk8saUJBQWpCO0FBSUgsYUFYRDtBQWFIOzs7OENBRXFCLFEsRUFBVTs7QUFFNUIsZ0JBQUssS0FBSyxjQUFWLEVBQTJCO0FBQ3ZCLHVDQUFNO0FBQ0YsNkJBQWMsS0FBSyxjQURqQjtBQUVGLDZCQUFjLENBRlo7QUFHRiw4QkFBYyxHQUhaO0FBSUYsNEJBQWMsY0FKWjtBQUtGLDhCQUFjLG9CQUFNO0FBQ2hCO0FBQ0g7QUFQQyxpQkFBTjtBQVNILGFBVkQsTUFVTztBQUNIO0FBQ0g7QUFFSjs7OzZDQUVvQjtBQUFBOztBQUVqQjtBQUNBLGdCQUFJLGdCQUFKOztBQUVBO0FBQ0EsZ0JBQUksS0FBSyxhQUFMLENBQW1CLENBQW5CLEtBQXlCLElBQTdCLEVBQW1DOztBQUUvQixvQkFBSSxLQUFLLGFBQUwsQ0FBbUIsQ0FBbkIsS0FBeUIsSUFBekIsSUFBaUMsS0FBSyxhQUFMLENBQW1CLENBQW5CLEtBQXlCLEtBQUssYUFBTCxDQUFtQixDQUFqRixFQUFvRjtBQUNoRix3QkFBSSxTQUFTLEtBQUssYUFBTCxDQUFtQixDQUFoQztBQUNBLHdCQUFJLFNBQVMsS0FBSyxhQUFMLENBQW1CLENBQWhDOztBQUVBLHdCQUFJLFNBQVMsS0FBSyxhQUFMLENBQW1CLE1BQW5CLEVBQTJCLFlBQTNCLENBQXdDLGVBQXhDLENBQWI7QUFDQSx3QkFBSSxTQUFTLEtBQUssYUFBTCxDQUFtQixNQUFuQixFQUEyQixZQUEzQixDQUF3QyxlQUF4QyxDQUFiOztBQUVBLDhCQUFXLFNBQVMsTUFBVixHQUFvQixTQUFPLEdBQVAsR0FBVyxNQUEvQixHQUF3QyxTQUFPLEdBQVAsR0FBVyxNQUE3RDtBQUNILGlCQVJELE1BUU87QUFDSCw4QkFBVSxLQUFLLGFBQUwsQ0FBbUIsS0FBSyxhQUFMLENBQW1CLENBQXRDLEVBQXlDLFlBQXpDLENBQXNELGVBQXRELENBQVY7QUFDSDtBQUNKOztBQUVEO0FBQ0EsZ0JBQUksWUFBWSxLQUFLLEVBQUwsQ0FBUSxhQUFSLDJEQUE4RSxPQUE5RSxTQUEyRixTQUEzRixDQUFxRyxJQUFyRyxDQUFoQjs7QUFFQSxnQkFBSSxTQUFKLEVBQWU7QUFDWCxxQkFBSyxxQkFBTCxDQUE0QixZQUFNO0FBQzlCLHlDQUFPLE9BQUssYUFBWjs7QUFFQTtBQUNBLDJCQUFLLGNBQUwsR0FBc0IsU0FBdEI7O0FBRUEsOEJBQVUsS0FBVixDQUFnQixPQUFoQixHQUEwQixDQUExQjtBQUNBLDJDQUFNO0FBQ0YsaUNBQWMsU0FEWjtBQUVGLGlDQUFjLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FGWjtBQUdGLGtDQUFjLEdBSFo7QUFJRixnQ0FBYztBQUpaLHFCQUFOOztBQU9BLDJCQUFLLGFBQUwsQ0FBbUIsV0FBbkIsQ0FBZ0MsU0FBaEM7QUFDSCxpQkFmRDtBQWdCSDtBQUVKOzs7NENBRW1COztBQUVoQiw0Q0FBa0IsS0FBSyxXQUFMLENBQWlCLFVBQWpCLENBQTRCLElBQTVCLENBQWxCLEVBQXFELEtBQUssTUFBMUQsRUFBa0UsS0FBSyxXQUF2RSxFQUFvRixZQUFwRjtBQUNBLDRDQUFrQixLQUFLLFdBQUwsQ0FBaUIsVUFBakIsQ0FBNEIsSUFBNUIsQ0FBbEIsRUFBcUQsS0FBSyxNQUExRCxFQUFrRSxLQUFLLFdBQXZFLEVBQW9GLFlBQXBGO0FBRUg7O0FBR0Q7Ozs7OzsyQ0FLbUIsSyxFQUFPO0FBQ3RCLGlCQUFLLGNBQUw7O0FBRUEsZ0JBQUksS0FBSyxjQUFMLElBQXVCLEtBQUssYUFBTCxDQUFtQixNQUE5QyxFQUF1RDtBQUNuRCxxQkFBSyxjQUFMLEdBQXNCLENBQXRCO0FBQ0g7O0FBRUQsaUJBQUssY0FBTDs7QUFFQSxnQkFBSSxLQUFLLGNBQUwsSUFBdUIsS0FBSyxhQUFMLENBQW1CLE1BQTlDLEVBQXVEO0FBQ25ELHFCQUFLLGNBQUwsR0FBc0IsQ0FBdEI7QUFDSDs7QUFFRCxpQkFBSyxlQUFMO0FBQ0g7OzswQ0FFaUIsSyxFQUFPOztBQUVyQixnQkFBSSxZQUFjLEtBQUssVUFBTCxDQUFnQixRQUFoQixDQUEwQixNQUFNLGNBQWhDLENBQUYsR0FBdUQsR0FBdkQsR0FBNkQsR0FBN0U7QUFDQSxnQkFBSSxTQUFTLE1BQU0sY0FBTixDQUFxQixZQUFyQixDQUFrQyxlQUFsQyxDQUFiO0FBQ0EsZ0JBQUksWUFBWSxxQkFBTyxNQUFNLGNBQWIsQ0FBaEI7O0FBRUE7O0FBRUE7QUFDQTs7cUJBRVMsSUFBSSxLQUFLLGFBQUwsQ0FBbUIsU0FBbkIsTUFBa0MsSUFBdEMsRUFBNEM7QUFDakQscUJBQUssZ0JBQUwsQ0FBdUIsS0FBSyxhQUFMLENBQW1CLFNBQW5CLENBQXZCLEVBQXNELFNBQXREO0FBQ0g7O0FBRUQsaUJBQUssY0FBTCxDQUFvQixTQUFwQixFQUErQixTQUEvQjs7QUFFQSxpQkFBSyxlQUFMO0FBQ0EsaUJBQUssa0JBQUw7QUFFSDs7Ozs7O2tCQUtVLGdCOzs7Ozs7Ozs7QUM3VWY7Ozs7OztBQUVBLFNBQVMsY0FBVCxDQUF3QixNQUF4QixFQUFnQyxNQUFoQyxFQUF3Qzs7QUFFcEMsUUFBSSxVQUFXLEtBQUssRUFBTCxHQUFVLENBQVgsR0FBZ0IsTUFBOUI7QUFDQSxRQUFJLFlBQWEsS0FBSyxFQUFMLEdBQVUsQ0FBWCxHQUFnQixDQUFoQzs7QUFFQSxRQUFJLFNBQVMsRUFBYjs7QUFFQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBcEIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDN0IsWUFBSSxRQUFTLFVBQVUsQ0FBWCxHQUFnQixTQUE1QjtBQUNBLFlBQUksSUFBSSxTQUFTLEtBQUssR0FBTCxDQUFVLEtBQVYsQ0FBVCxHQUE2QixNQUFyQztBQUNBLFlBQUksSUFBSSxTQUFTLEtBQUssR0FBTCxDQUFVLEtBQVYsQ0FBVCxHQUE2QixNQUFyQzs7QUFFQSxlQUFPLElBQVAsQ0FBYSxvQkFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixLQUFqQixFQUF3QixNQUF4QixDQUFiO0FBQ0g7O0FBRUQsV0FBTyxNQUFQO0FBQ0g7O2tCQUVjLGM7Ozs7Ozs7OztBQ3BCZjs7Ozs7O0FBRUEsU0FBUyxnQkFBVCxDQUEwQixHQUExQixFQUErQixNQUEvQixFQUF1QyxXQUF2QyxFQUFvRCxNQUFwRCxFQUE0RDs7QUFFeEQ7QUFDQSxRQUFJLFNBQUosQ0FBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLElBQUksTUFBeEIsRUFBZ0MsSUFBSSxNQUFwQztBQUNBLFFBQUksU0FBSjtBQUNBLFFBQUksR0FBSixDQUFTLE1BQVQsRUFBaUIsTUFBakIsRUFBeUIsTUFBekIsRUFBaUMsQ0FBakMsRUFBb0MsS0FBSyxFQUFMLEdBQVMsQ0FBN0MsRUFBZ0QsS0FBaEQ7QUFDQSxRQUFJLElBQUo7QUFDQSxRQUFJLHdCQUFKLEdBQStCLFFBQS9COztBQUVBO0FBQ0EsV0FBTyxPQUFQLENBQWdCLFVBQUMsS0FBRCxFQUFRLENBQVIsRUFBYzs7QUFFMUIsWUFBSSxhQUFhLFlBQVksQ0FBWixDQUFqQjs7QUFFQSxZQUFJLElBQUksV0FBVyxDQUFuQjtBQUNBLFlBQUksSUFBSSxXQUFXLENBQW5COztBQUVBLFlBQUksV0FBVyxJQUFJLG9CQUFKLENBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLE1BQXhDLENBQWY7QUFDQSxpQkFBUyxZQUFULENBQXNCLENBQXRCLEVBQXlCLEtBQXpCO0FBQ0EsaUJBQVMsWUFBVCxDQUFzQixDQUF0QixFQUF5QixxQkFBTSxLQUFOLEVBQWEsSUFBYixDQUFrQixDQUFsQixDQUF6QjtBQUNBLFlBQUksU0FBSixHQUFnQixRQUFoQjtBQUNBLFlBQUksUUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsU0FBUyxDQUE1QixFQUErQixTQUFTLENBQXhDO0FBRUgsS0FiRDs7QUFnQkE7QUFDQSxRQUFJLHdCQUFKLEdBQStCLGFBQS9CO0FBQ0EsUUFBSSxnQkFBZ0IsSUFBSSxvQkFBSixDQUF5QixNQUF6QixFQUFpQyxNQUFqQyxFQUF5QyxDQUF6QyxFQUE0QyxNQUE1QyxFQUFvRCxNQUFwRCxFQUE0RCxNQUE1RCxDQUFwQjs7QUFFQSxrQkFBYyxZQUFkLENBQTJCLENBQTNCLEVBQThCLDBCQUE5QjtBQUNBLGtCQUFjLFlBQWQsQ0FBMkIsQ0FBM0IsRUFBOEIsdUJBQTlCOztBQUVBLFFBQUksU0FBSixHQUFnQixhQUFoQjtBQUNBLFFBQUksUUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsU0FBUyxDQUE1QixFQUErQixTQUFTLENBQXhDO0FBQ0g7O2tCQUdjLGdCOzs7OztBQ3hDZjs7OztBQUNBOzs7O0FBR0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBO0FBQ0EsSUFBTSxNQUFNO0FBQ1IsU0FEUSxtQkFDQTs7QUFFSjtBQUNBLFlBQUksa0JBQWtCLE9BQU8sVUFBN0I7O0FBRUEsWUFBSyxDQUFDLGVBQU4sRUFBd0I7QUFDcEIsb0JBQVEsSUFBUixDQUFhLDhCQUFiO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsNkJBQU8sVUFBUCxDQUFtQixlQUFuQjtBQUNIOztBQUVEO0FBQ0EsZ0NBQWMsVUFBZCxDQUF5QjtBQUNyQix5QkFBYyxDQUNWLEVBQUMsTUFBTSxLQUFQLEVBQWdCLE9BQU8sQ0FBdkIsRUFEVSxFQUNvQjtBQUM5QixjQUFDLE1BQU0sSUFBUCxFQUFnQixPQUFPLEdBQXZCLEVBRlUsRUFHVixFQUFDLE1BQU0sR0FBUCxFQUFnQixPQUFPLEdBQXZCLEVBSFUsRUFJVixFQUFDLE1BQU0sR0FBUCxFQUFnQixPQUFPLEdBQXZCLEVBSlUsRUFLVixFQUFDLE1BQU0sR0FBUCxFQUFnQixPQUFPLElBQXZCLEVBTFUsRUFNVixFQUFDLE1BQU0sSUFBUCxFQUFnQixPQUFPLElBQXZCLEVBTlUsRUFPVixFQUFDLE1BQU0sS0FBUCxFQUFnQixPQUFPLElBQXZCLEVBUFU7QUFETyxTQUF6Qjs7QUFZQTtBQUNBLGFBQUsscUJBQUw7O0FBRUE7QUFDQSxhQUFLLGFBQUw7O0FBRUE7QUFDQSxhQUFLLE1BQUwsR0FBYyxxQkFBWSxTQUFTLGNBQVQsQ0FBd0IsYUFBeEIsQ0FBWixDQUFkOztBQUVBLGFBQUssTUFBTCxHQUFjLHFCQUFZLFNBQVMsY0FBVCxDQUF3QixhQUF4QixDQUFaLENBQWQ7O0FBRUEsYUFBSyxRQUFMLEdBQWdCLHVCQUFjLFNBQVMsY0FBVCxDQUF3QixXQUF4QixDQUFkLENBQWhCOztBQUVBO0FBQ0E7QUFDQSxZQUFJLE9BQU8sS0FBSyxRQUFMLENBQWUsU0FBUyxhQUFULENBQXVCLE9BQXZCLENBQWYsQ0FBWDs7QUFFQTs7QUFFQSxlQUFPLE9BQVAsQ0FBZSxZQUFmLENBQTRCLEVBQUMsUUFBUSxLQUFLLEVBQWQsRUFBNUIsRUFBK0MsT0FBTyxLQUF0RCxFQUE2RCxPQUFPLFFBQVAsQ0FBZ0IsSUFBN0U7O0FBRUE7OztBQUtBO0FBQ0E7QUFDQSxhQUFLLGFBQUwsR0FBcUIsSUFBSSxNQUFKLFVBQWtCLE9BQU8sUUFBUCxDQUFnQixNQUFsQyxVQUFyQjs7QUFFQSxlQUFPLGdCQUFQLENBQXdCLFVBQXhCLEVBQW9DLEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsQ0FBMkIsSUFBM0IsQ0FBcEM7O0FBRUE7QUFDQSxlQUFPLFFBQVAsQ0FBZ0IsZ0JBQWhCLENBQWlDLE9BQWpDLEVBQTBDLEtBQUssbUJBQUwsQ0FBeUIsSUFBekIsQ0FBOEIsSUFBOUIsQ0FBMUM7O0FBRUE7QUFDQSxnQ0FBYyxFQUFkLENBQWlCLE1BQWpCLEVBQXlCLFlBQU07QUFDM0Isb0NBQWMsT0FBZCxDQUFzQixRQUF0QjtBQUNILFNBRkQ7QUFJSCxLQWpFTztBQW1FUix5QkFuRVEsbUNBbUVnQjtBQUNwQixZQUFJLDZCQUFrQywrQkFBcUIsZ0JBQXJCLEVBQXVDLEVBQUMsUUFBUSxHQUFULEVBQXZDLENBQXRDO0FBQ0EsWUFBSSw2QkFBa0MsK0JBQXFCLGdCQUFyQixFQUF1QyxFQUFDLFFBQVEsR0FBVCxFQUF2QyxDQUF0Qzs7QUFFQSxZQUFJLCtCQUFrQywrQkFBcUIsV0FBckIsRUFBa0MsRUFBQyxRQUFRLEdBQVQsRUFBbEMsQ0FBdEM7QUFDQSxZQUFJLDhCQUFrQywrQkFBcUIsV0FBckIsRUFBa0MsRUFBQyxRQUFRLEdBQVQsRUFBYyxPQUFPLFFBQXJCLEVBQWxDLENBQXRDO0FBQ0EsWUFBSSw0QkFBa0MsK0JBQXFCLFdBQXJCLEVBQWtDLEVBQUMsUUFBUSxHQUFULEVBQWxDLENBQXRDOztBQUVBO0FBQ0EsWUFBSSxlQUFlLFFBQVEsR0FBUixDQUFZLENBQzNCLDZCQUE2QixJQUE3QixFQUQyQixFQUUzQiw0QkFBNEIsSUFBNUIsRUFGMkIsRUFHM0IsMEJBQTBCLElBQTFCLEVBSDJCLENBQVosRUFJaEIsSUFKZ0IsQ0FJVjtBQUFBLG1CQUFNLFNBQVMsZUFBVCxDQUF5QixTQUF6QixDQUFtQyxHQUFuQyxDQUF1Qyx1QkFBdkMsQ0FBTjtBQUFBLFNBSlUsQ0FBbkI7O0FBTUE7QUFDQSxZQUFJLGdCQUFnQixRQUFRLEdBQVIsQ0FBWSxDQUM1QiwyQkFBMkIsSUFBM0IsRUFENEIsRUFFNUIsMkJBQTJCLElBQTNCLEVBRjRCLENBQVosRUFHakIsSUFIaUIsQ0FHWDtBQUFBLG1CQUFNLFNBQVMsZUFBVCxDQUF5QixTQUF6QixDQUFtQyxHQUFuQyxDQUF1Qyx3QkFBdkMsQ0FBTjtBQUFBLFNBSFcsQ0FBcEI7O0FBS0E7QUFDQSxnQkFBUSxHQUFSLENBQVksQ0FBRSxZQUFGLEVBQWdCLGFBQWhCLENBQVosRUFBNkMsSUFBN0MsQ0FBbUQsWUFBTTtBQUNyRCxvQ0FBYyxPQUFkLENBQXNCLFFBQXRCO0FBQ0EsbUJBQU8sY0FBUCxDQUFzQixPQUF0QixDQUE4QixhQUE5QixFQUE2QyxJQUE3QyxFQUZxRCxDQUVEO0FBQ3ZELFNBSEQ7QUFLSCxLQTlGTztBQWdHUixpQkFoR1EsMkJBZ0dROztBQUVaLFlBQUksVUFBVSxPQUFPLGNBQVAsQ0FBc0IsT0FBdEIsQ0FBOEIsWUFBOUIsQ0FBZDtBQUNBLFlBQUksV0FBVyxRQUFRLE1BQW5CLElBQTZCLGlCQUFPLEdBQVAsS0FBZSxhQUFoRCxFQUFnRTtBQUM1RDtBQUNBLGdCQUFJLFNBQVMsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWI7QUFDQSxtQkFBTyxTQUFQLEdBQW1CLE9BQW5CO0FBQ0EscUJBQVMsSUFBVCxDQUFjLFlBQWQsQ0FBNEIsT0FBTyxVQUFuQyxFQUErQyxTQUFTLElBQVQsQ0FBYyxVQUE3RDtBQUNILFNBTEQsTUFLUTtBQUNKLGdCQUFJLFlBQVksTUFBUyxpQkFBTyxTQUFoQiw2QkFBaEI7QUFDQSxzQkFDSyxJQURMLENBQ1c7QUFBQSx1QkFBWSxTQUFTLElBQVQsRUFBWjtBQUFBLGFBRFgsRUFFSyxJQUZMLENBRVcsd0JBQWdCOztBQUVuQixvQkFBSSxnQkFBZ0IsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQXBCO0FBQ0EsOEJBQWMsU0FBZCxHQUEwQixZQUExQjs7QUFFQSxvQkFBSSxVQUFVLGNBQWMsVUFBNUI7O0FBRUE7QUFDQSx1QkFBTyxjQUFQLENBQXNCLE9BQXRCLENBQThCLFlBQTlCLEVBQTRDLFlBQTVDOztBQUVBO0FBQ0EseUJBQVMsSUFBVCxDQUFjLFlBQWQsQ0FBMkIsT0FBM0IsRUFBb0MsU0FBUyxJQUFULENBQWMsVUFBbEQ7QUFFSCxhQWZMO0FBZ0JIO0FBR0osS0E3SE87QUErSFIsWUEvSFEsb0JBK0hDLEdBL0hELEVBK0hNO0FBQUE7O0FBRVY7O0FBRUEsY0FBTSxHQUFOLEVBQVc7QUFDUCx5QkFBYztBQURQLFNBQVgsRUFFRyxJQUZILENBRVMsVUFBQyxRQUFELEVBQWM7QUFDbkI7QUFDQSxtQkFBUyxTQUFTLE9BQVQsQ0FBaUIsR0FBakIsQ0FBcUIsY0FBckIsS0FBd0MsU0FBUyxPQUFULENBQWlCLEdBQWpCLENBQXFCLGNBQXJCLEVBQXFDLFFBQXJDLENBQThDLGtCQUE5QyxDQUExQyxHQUFnSCxTQUFTLElBQVQsRUFBaEgsR0FBa0ksU0FBUyxJQUFULEVBQXpJO0FBQ0gsU0FMRCxFQUtHLElBTEgsQ0FLUyxVQUFDLFlBQUQsRUFBa0I7QUFDdkIsZ0JBQUksYUFBYSwrQkFBaUIsWUFBakIsQ0FBakI7O0FBRUE7QUFDQSxnQkFBSSxTQUFTLFdBQVcsYUFBWCxDQUF5QixPQUF6QixDQUFiOztBQUVBLGdCQUFJLE9BQU8sTUFBSyxRQUFMLENBQWUsTUFBZixDQUFYOztBQUVBO0FBQ0EsbUJBQU8sT0FBUCxDQUFlLFNBQWYsQ0FBeUIsRUFBQyxRQUFRLEtBQUssRUFBZCxFQUF6QixFQUE0QyxPQUFPLEtBQW5ELEVBQTBELEdBQTFEO0FBRUgsU0FoQkQ7QUFpQkgsS0FwSk87QUFzSlIsWUF0SlEsb0JBc0pDLE1BdEpELEVBc0pTOztBQUViO0FBQ0EsWUFBSSxTQUFTLE9BQU8sWUFBUCxDQUFvQixjQUFwQixDQUFiOztBQUVBO0FBQ0EsWUFBSSxXQUFXLE1BQWYsRUFBdUI7QUFDbkIsaUJBQUssUUFBTCxDQUFjLFlBQWQsQ0FBNEIsTUFBNUI7QUFDSDs7QUFFRDtBQUNBLFlBQUksZ0JBQUo7QUFDQSxZQUFLLG1CQUFTLE1BQVQsQ0FBTCxFQUF3QjtBQUNwQixzQkFBVSxJQUFJLG1CQUFTLE1BQVQsQ0FBSixDQUFzQixNQUF0QixDQUFWO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsc0JBQVUsSUFBSSxtQkFBUyxTQUFULENBQUosQ0FBeUIsTUFBekIsQ0FBVjtBQUNBLG9CQUFRLEtBQVIsb0NBQStDLE1BQS9DO0FBQ0g7O0FBRUQsWUFBSyxXQUFXLE1BQWhCLEVBQXdCO0FBQ3BCLGlCQUFLLFdBQUwsR0FBbUIsT0FBbkI7QUFDQSxpQkFBSyxhQUFMO0FBQ0gsU0FIRCxNQUdPO0FBQ0gsaUJBQUssZUFBTCxHQUF1QixPQUF2QjtBQUNBLGlCQUFLLFlBQUw7QUFDSDs7QUFFRCxlQUFPLE9BQVA7QUFDSCxLQWxMTztBQXFMUixnQkFyTFEsMEJBcUxPO0FBQ1g7O0FBRUEsYUFBSyxRQUFMLENBQWMsSUFBZDtBQUNILEtBekxPO0FBMkxSLGlCQTNMUSwyQkEyTFE7O0FBRVo7O0FBRUEsWUFBSSxLQUFLLGVBQVQsRUFBMEI7QUFDdEIsaUJBQUssUUFBTCxDQUFjLEtBQWQ7QUFDQSxpQkFBSyxlQUFMLENBQXFCLE1BQXJCLEdBRnNCLENBRVM7QUFDL0IsaUJBQUssZUFBTCxHQUF1QixJQUF2QjtBQUNIOztBQUdEOztBQUVBO0FBRUgsS0ExTU87QUE0TVIsb0JBNU1RLDRCQTRNUyxLQTVNVCxFQTRNZ0I7O0FBRXBCLGdCQUFRLEdBQVIsQ0FBYSxPQUFPLFFBQVAsQ0FBZ0IsSUFBN0I7O0FBRUEsWUFBSSxNQUFNLEtBQU4sQ0FBWSxNQUFaLElBQXNCLE1BQU0sS0FBTixDQUFZLE1BQVosS0FBdUIsTUFBakQsRUFBeUQ7QUFDckQsaUJBQUssYUFBTDtBQUNILFNBRkQsTUFFTztBQUNIO0FBQ0EsaUJBQUssUUFBTCxDQUFlLE9BQU8sUUFBUCxDQUFnQixJQUEvQjtBQUNIO0FBRUosS0F2Tk87QUF5TlIsdUJBek5RLCtCQXlOWSxLQXpOWixFQXlObUI7QUFDdkI7QUFDQSxZQUFJLG1CQUFKO0FBQ0EsWUFBSSxVQUFVLE1BQU0sTUFBcEI7QUFDQSxlQUFPLFlBQVksU0FBUyxlQUE1QixFQUE4QztBQUMxQyxnQkFBSSxXQUFXLFFBQVEsT0FBbkIsSUFBOEIsUUFBUSxPQUFSLENBQWdCLFdBQWhCLE9BQWtDLEdBQXBFLEVBQXlFO0FBQ3JFLDZCQUFhLE9BQWI7QUFDQTtBQUNILGFBSEQsTUFHTztBQUNILDBCQUFVLFFBQVEsVUFBbEI7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFLLGNBQWMsQ0FBQyxNQUFNLE9BQXJCLElBQWdDLENBQUMsTUFBTSxPQUF2QyxJQUFrRCxXQUFXLE9BQVgsQ0FBbUIsV0FBbkIsT0FBcUMsR0FBdkYsSUFBOEYsV0FBVyxZQUFYLENBQXdCLE1BQXhCLENBQTlGLElBQWlJLENBQUMsV0FBVyxTQUFYLENBQXFCLFFBQXJCLENBQThCLGNBQTlCLENBQXZJLEVBQXVMOztBQUVuTCxnQkFBSyxXQUFXLFNBQVgsQ0FBcUIsUUFBckIsQ0FBOEIsaUJBQTlCLENBQUwsRUFBd0Q7O0FBRXBEO0FBQ0Esb0JBQUksS0FBSyxXQUFULEVBQXNCO0FBQ2xCLDBCQUFNLGNBQU47QUFDQSx5QkFBSyxhQUFMO0FBQ0EsMkJBQU8sT0FBUCxDQUFlLFNBQWYsQ0FBeUIsRUFBQyxRQUFRLEtBQUssV0FBTCxDQUFpQixFQUExQixFQUF6QixFQUF3RCxPQUFPLEtBQS9ELEVBQXNFLFdBQVcsWUFBWCxDQUF3QixNQUF4QixDQUF0RTtBQUNILGlCQUpELE1BSU87QUFDSDtBQUNIO0FBRUosYUFYRCxNQVdPO0FBQ0gsb0JBQUksV0FBVyxXQUFXLFlBQVgsQ0FBd0IsTUFBeEIsQ0FBZjtBQUNBLG9CQUFLLE9BQU8sUUFBUCxDQUFnQixJQUFoQixLQUF5QixRQUF6QixJQUFxQyxLQUFLLGFBQUwsQ0FBbUIsSUFBbkIsQ0FBeUIsUUFBekIsQ0FBMUMsRUFBK0U7QUFDM0UsMEJBQU0sY0FBTjs7QUFFQSx3QkFBSyxLQUFLLGVBQVYsRUFBNEI7QUFDeEIsK0NBQU07QUFDRixxQ0FBVSxLQUFLLGVBQUwsQ0FBcUIsRUFEN0I7QUFFRixzQ0FBVyxJQUZUO0FBR0YscUNBQVM7QUFIUCx5QkFBTjtBQUtIOztBQUVEO0FBQ0EseUJBQUssUUFBTCxDQUFjLE9BQWQ7O0FBRUEseUJBQUssUUFBTCxDQUFlLFFBQWY7QUFDSDtBQUNKO0FBRUo7QUFDSjtBQTdRTyxDQUFaOztBQWlSQTs7O0FBNVJBO0FBNlJBLElBQUksS0FBSjs7Ozs7Ozs7Ozs7QUM1UkE7Ozs7QUFHQTs7Ozs7Ozs7OzsrZUFQQTtBQUNBOzs7QUFLQTs7O0FBSUE7O0FBRUE7OztJQUdNLGE7OztBQUVGLDJCQUFZLEVBQVosRUFBZ0IsT0FBaEIsRUFBeUI7QUFBQTs7QUFBQSxrSUFFZixFQUZlLEVBRVgsT0FGVzs7QUFJckIsWUFBSSxPQUFPLFNBQVAsSUFBb0IsaUJBQU8sR0FBUCxLQUFlLGFBQXZDLEVBQXNEO0FBQ2xELG9CQUFRLEdBQVIsQ0FBWSxlQUFaO0FBQ0Esa0JBQUssZ0JBQUw7QUFDSDs7QUFQb0I7QUFTeEI7O0FBRUQ7Ozs7OzswQ0FNa0IsVSxFQUFZLGtCLEVBQW9CLENBRWpEOztBQUdEOzs7Ozs7MkNBS21CO0FBQ2YsaUJBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixVQUFDLEtBQUQsRUFBVztBQUNqQyxvQkFBSSxTQUFTLE1BQU0sY0FBbkI7O0FBRUEsb0JBQUksV0FBVyxPQUFPLFlBQVAsQ0FBb0IsZ0JBQXBCLENBQWY7QUFDQSxvQkFBSSxtQkFBbUIsT0FBTyxZQUFQLENBQW9CLHdCQUFwQixDQUF2Qjs7QUFFQSx1QkFBTyxTQUFQLENBQWlCLElBQWpCLENBQXNCO0FBQ2xCLDZCQUFTLGVBRFM7QUFFbEIsMENBQXNCLGlCQUZKO0FBR2xCLGdDQUFZLFFBSE07QUFJbEIsd0NBQW9CLGdCQUpGO0FBS2xCLG9DQUFpQixTQUFTLGVBQVQsQ0FBeUIsSUFMeEI7QUFNbEIsMkJBQVMsT0FBTyxRQUFQLENBQWdCLFFBQWhCLEdBQTJCLE9BQU8sUUFBUCxDQUFnQixNQUEzQyxHQUFvRCxPQUFPLFFBQVAsQ0FBZ0I7QUFOM0QsaUJBQXRCO0FBU0gsYUFmRCxFQWVHLFNBZkg7QUFnQkg7O0FBR0Q7Ozs7OzsyQ0FLbUIsSyxFQUFPLENBRXpCOzs7Ozs7a0JBS1UsYTs7Ozs7Ozs7Ozs7QUN6RWY7Ozs7QUFHQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBUkE7QUFDQTs7QUFJQTs7O0FBS0E7O0FBRUE7OztJQUdNLFc7OztBQUVGLHlCQUFZLEVBQVosRUFBZ0IsT0FBaEIsRUFBeUI7QUFBQTs7QUFBQSw4SEFFZixFQUZlLEVBRVgsT0FGVzs7QUFJckIsWUFBSSxZQUFZLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0Isa0JBQXRCLENBQWhCO0FBQ0EsWUFBSSxTQUFKLEVBQWU7QUFDWCxrQkFBSyxjQUFMLEdBQXNCLDRCQUFvQixTQUFwQixDQUF0QjtBQUNBLGtCQUFLLGdCQUFMLENBQXVCLE1BQUssY0FBNUI7O0FBRUEsZ0JBQUksaUJBQWlCLE1BQUssYUFBTCxDQUFtQixZQUFuQixDQUFpQyxTQUFqQyxFQUE0QyxDQUE1QyxDQUFyQjs7QUFFQSxnQkFBSyxlQUFlLEtBQWYsS0FBeUIsMkJBQWlCLEtBQWpCLENBQXVCLEdBQXJELEVBQTBEO0FBQ3RELHNCQUFLLGdCQUFMO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsK0JBQWUsRUFBZixDQUFrQixPQUFsQixFQUEyQixVQUFDLEtBQUQsRUFBVztBQUNsQyx3QkFBSSxNQUFNLEtBQU4sS0FBZ0IsMkJBQWlCLEtBQWpCLENBQXVCLEdBQTNDLEVBQWdEO0FBQzVDLDhCQUFLLGdCQUFMO0FBQ0EsdUNBQWUsR0FBZixDQUFtQixPQUFuQjtBQUNIO0FBQ0osaUJBTEQ7QUFNSDtBQUdKOztBQUVELFlBQUksaUJBQWlCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsZ0JBQXRCLENBQXJCO0FBQ0EsWUFBSSxjQUFKLEVBQW9CO0FBQ2hCLGtCQUFLLFlBQUwsR0FBb0IsMkJBQWtCLGNBQWxCLENBQXBCO0FBQ0Esa0JBQUssZ0JBQUwsQ0FBdUIsTUFBSyxZQUE1QjtBQUNIOztBQUVELFlBQUksT0FBTyxTQUFYLEVBQXNCO0FBQ2xCLGtCQUFLLGdCQUFMO0FBQ0g7O0FBakNvQjtBQW1DeEI7O0FBRUQ7Ozs7QUFPQTs7Ozs7OzJDQU1tQjs7QUFFZixpQkFBSyxXQUFMLENBQWlCLE9BQWpCLEVBQTBCLFVBQUMsS0FBRCxFQUFXO0FBQ2pDLHVCQUFPLFNBQVAsQ0FBaUIsSUFBakIsQ0FBc0I7QUFDbEIsNkJBQVMsV0FEUztBQUVsQiwwQ0FBMEIsaUJBRlI7QUFHbEIsb0NBQWlCLFNBQVMsZUFBVCxDQUF5QjtBQUh4QixpQkFBdEI7QUFLSCxhQU5ELEVBTUcsa0NBTkg7QUFRSDs7OzJDQUVrQjtBQUNmLGtCQUFNLElBQU4sQ0FBWSxLQUFLLGNBQUwsQ0FBb0IsRUFBcEIsQ0FBdUIsZ0JBQXZCLENBQXdDLGlCQUF4QyxDQUFaLEVBQXlFLE9BQXpFLENBQWtGO0FBQUEsdUJBQVEsS0FBSyxTQUFMLENBQWUsTUFBZixDQUFzQixRQUF0QixDQUFSO0FBQUEsYUFBbEY7QUFDSDs7QUFHRDs7Ozs7OzJDQUttQixLLEVBQU8sQ0FFekI7Ozs7OztrQkFLVSxXOzs7Ozs7Ozs7OztBQy9GZjs7OztBQUdBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBTEE7OztBQUdBOzs7QUFJQTtBQUNBLElBQU0sb0JBQW9CLHlDQUExQjs7QUFFQSxJQUFJLFlBQVksRUFBaEI7O0FBRUEsU0FBUyxnQkFBVCxDQUEwQixRQUExQixFQUFvQztBQUNoQyxRQUFLLENBQUMsT0FBTyxVQUFiLEVBQTBCOztBQUV0QixrQkFBVSxJQUFWLENBQWdCLFFBQWhCOztBQUVBLFlBQUksV0FBVyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtBQUNBLGlCQUFTLFlBQVQsQ0FBc0IsT0FBdEIsRUFBK0IsT0FBTyxVQUFQLENBQWtCLGlCQUFqRDtBQUNBLGlCQUFTLEtBQVQsR0FBaUIsSUFBakI7QUFDQSxpQkFBUyxLQUFULEdBQWlCLElBQWpCO0FBQ0EsaUJBQVMsR0FBVCxHQUFlLG9CQUFrQiw2Q0FBbEIsR0FBZ0UsU0FBUyxlQUFULENBQXlCLElBQXhHO0FBQ0EsaUJBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMkIsUUFBM0I7QUFJSDtBQUNKOztBQUVELE9BQU8sZUFBUCxHQUF5QixZQUFXO0FBQ2hDLFdBQU8sVUFBVSxNQUFqQixFQUEwQjtBQUN0QixrQkFBVSxLQUFWLEdBQWtCLFlBQWxCO0FBQ0g7QUFDSixDQUpEOztBQU1BOzs7Ozs7SUFLTSxXOzs7QUFFRix5QkFBWSxFQUFaLEVBQWdCLE9BQWhCLEVBQXlCO0FBQUE7O0FBQUEsOEhBQ2YsRUFEZSxFQUNYLE9BRFc7O0FBR3JCLGNBQUssV0FBTCxHQUFtQixNQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLE1BQXRCLENBQW5COztBQUVBLFlBQUssT0FBTyxVQUFaLEVBQXdCO0FBQ3BCLGtCQUFLLFlBQUw7QUFDSCxTQUZELE1BRU87QUFDSDtBQUNIOztBQUVEO0FBQ0EsY0FBSyxXQUFMLENBQWlCLFFBQWpCLEVBQTJCLE1BQUssa0JBQWhDLEVBQW9ELE1BQUssV0FBekQ7QUFacUI7QUFheEI7Ozs7dUNBRWM7QUFDWCxpQkFBSyxjQUFMLEdBQXNCLElBQXRCOztBQUVBLGdCQUFJLFlBQVksS0FBSyxFQUFMLENBQVEsYUFBUixDQUFzQixjQUF0QixDQUFoQjs7QUFFQSxpQ0FBTSxTQUFOOztBQUVBLGdCQUFJLGtCQUFrQixTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBdEI7QUFDQSxzQkFBVSxXQUFWLENBQXVCLGVBQXZCO0FBQ0EsbUJBQU8sVUFBUCxDQUFrQixNQUFsQixDQUEwQixlQUExQixFQUEyQztBQUN2Qyx5QkFBVSxVQUFVLFlBQVYsQ0FBdUIsY0FBdkIsQ0FENkI7QUFFdkMsc0JBQVMsS0FBSyxRQUFMLENBQWMsR0FBZCxJQUFxQixRQUFyQixHQUFnQztBQUZGLGFBQTNDO0FBS0g7OzttQ0FFVTtBQUFBOztBQUNQLGdCQUFJLE9BQU8sSUFBWDtBQUNBLGdCQUFJLFdBQVcsSUFBSSxRQUFKLENBQWEsS0FBSyxXQUFsQixDQUFmO0FBQ0EsZ0JBQUksU0FBUyxLQUFLLFdBQUwsQ0FBaUIsTUFBOUI7QUFDQSxnQkFBSSxTQUFTLEtBQUssV0FBTCxDQUFpQixNQUE5Qjs7QUFFQSwrQkFBSTtBQUNBLHNCQUFNLFFBRE47QUFFQSxxQkFBSyxNQUZMO0FBR0Esd0JBQVE7QUFIUixhQUFKLEVBSUcsVUFBQyxHQUFELEVBQU0sSUFBTixFQUFZLElBQVosRUFBcUI7QUFDcEIsb0JBQUksVUFBVSxLQUFLLEtBQUwsQ0FBWSxJQUFaLENBQWQ7QUFDQSxvQkFBSSxTQUFTLFFBQVEsTUFBckI7QUFDQSxvQkFBSSxTQUFTLFFBQVEsT0FBckI7QUFDQSxvQkFBSSx3QkFBd0IsS0FBSyxFQUFMLENBQVEsYUFBUixDQUFzQixnQkFBdEIsQ0FBNUI7O0FBRUEsb0JBQUksQ0FBQyxNQUFMLEVBQWE7O0FBRVQsMkJBQUssWUFBTDs7QUFFQSwwQ0FBc0IsU0FBdEIsQ0FBZ0MsR0FBaEMsQ0FBb0MsU0FBcEM7QUFDQSx5QkFBSyxJQUFJLEtBQVQsSUFBa0IsTUFBbEIsRUFBMEI7QUFDdEIsNEJBQUksWUFBWSxTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsQ0FBaEI7O0FBRUEsNEJBQUssU0FBTCxFQUFpQjtBQUNiLHNDQUFVLFNBQVYsQ0FBb0IsTUFBcEIsQ0FBMkIsT0FBM0I7QUFDQSxzQ0FBVSxVQUFWLENBQXFCLFNBQXJCLENBQStCLE1BQS9CLENBQXNDLE9BQXRDOztBQUVBLGdDQUFJLE9BQU8sS0FBUCxLQUFpQixTQUFyQixFQUFnQztBQUM1QiwwQ0FBVSxTQUFWLENBQW9CLEdBQXBCLENBQXdCLE9BQXhCO0FBQ0EsMENBQVUsVUFBVixDQUFxQixTQUFyQixDQUErQixHQUEvQixDQUFtQyxPQUFuQztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBLHdCQUFJLG1CQUFtQixPQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLGtCQUF0QixDQUF2QjtBQUNBLHdCQUFLLE9BQU8sV0FBUCxDQUFMLEVBQTJCO0FBQ3ZCLHlDQUFpQixXQUFqQixHQUErQixPQUFPLFdBQVAsQ0FBL0I7QUFDQSx5Q0FBaUIsU0FBakIsQ0FBMkIsR0FBM0IsQ0FBK0IsU0FBL0I7QUFDSCxxQkFIRCxNQUdPO0FBQ0gseUNBQWlCLFNBQWpCLENBQTJCLE1BQTNCLENBQWtDLFNBQWxDO0FBQ0g7QUFHSixpQkE3QkQsTUE4Qks7QUFDRDtBQUNBLDBDQUFzQixTQUF0QixDQUFnQyxNQUFoQyxDQUF1QyxTQUF2Qzs7QUFFQTtBQUNBLHdCQUFJLGFBQWEsU0FBUyxvQkFBVCxDQUE4QixPQUE5QixDQUFqQjtBQUNBLHlCQUFLLElBQUksSUFBRSxDQUFYLEVBQWMsSUFBSSxXQUFXLE1BQTdCLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3RDLG1DQUFXLENBQVgsRUFBYyxTQUFkLENBQXdCLE1BQXhCLENBQStCLE9BQS9CO0FBQ0g7O0FBRUQ7QUFDQSx3QkFBSSxhQUFhLFNBQVMsb0JBQVQsQ0FBOEIsT0FBOUIsQ0FBakI7QUFDQSx5QkFBSyxJQUFJLEtBQUUsQ0FBWCxFQUFjLEtBQUksV0FBVyxNQUE3QixFQUFxQyxJQUFyQyxFQUEwQztBQUN0QyxtQ0FBVyxFQUFYLEVBQWMsU0FBZCxDQUF3QixNQUF4QixDQUErQixPQUEvQjtBQUNBLG1DQUFXLEVBQVgsRUFBYyxLQUFkLEdBQXNCLEVBQXRCO0FBQ0g7O0FBRUQ7QUFDQSx3QkFBSSxnQkFBZ0IsU0FBUyxvQkFBVCxDQUE4QixVQUE5QixDQUFwQjtBQUNBLHlCQUFLLElBQUksTUFBRSxDQUFYLEVBQWMsTUFBSSxjQUFjLE1BQWhDLEVBQXdDLEtBQXhDLEVBQTZDO0FBQ3pDLHNDQUFjLEdBQWQsRUFBaUIsU0FBakIsQ0FBMkIsTUFBM0IsQ0FBa0MsT0FBbEM7QUFDQSxzQ0FBYyxHQUFkLEVBQWlCLEtBQWpCLEdBQXlCLEVBQXpCO0FBQ0g7O0FBRUQsd0JBQUksa0JBQWtCLE9BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsMkJBQXRCLENBQXRCO0FBQ0Esb0NBQWdCLFNBQWhCLENBQTBCLEdBQTFCLENBQThCLFVBQTlCO0FBQ0Esb0NBQWdCLGFBQWhCLENBQThCLHNCQUE5QixFQUFzRCxRQUF0RCxHQUFpRSxJQUFqRTs7QUFFQTtBQUNBLHdCQUFJLFVBQVUsT0FBSyxFQUFMLENBQVEsYUFBUixDQUFzQixVQUF0QixDQUFkO0FBQ0EsNEJBQVEsU0FBUixDQUFrQixHQUFsQixDQUFzQixTQUF0Qjs7QUFFQTtBQUNIO0FBQ0osYUExRUQ7QUE0RUg7O0FBR0Q7Ozs7QUFPQTs7Ozs7OzJDQUttQixDQUVsQjs7QUFHRDs7Ozs7OzZDQUtxQixDQUVwQjs7OzJDQUVrQixLLEVBQU87QUFDdEIsa0JBQU0sY0FBTjs7QUFFQSxpQkFBSyxRQUFMO0FBQ0g7Ozs7OztrQkFJVSxXOzs7Ozs7Ozs7Ozs7O0FDOUxmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFHQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFiQTtBQUNBOzs7QUFRQTs7O0FBTUE7QUFDQSxJQUFNLHVCQUF1QixHQUE3Qjs7QUFFQTs7OztJQUdNLFE7OztBQUVGLHNCQUFZLEVBQVosRUFBZ0IsT0FBaEIsRUFBeUI7QUFBQTs7QUFBQSx3SEFFZixFQUZlLEVBRVgsT0FGVzs7QUFJckIsY0FBSyxZQUFMLEdBQW9CLDJCQUFpQixNQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLFNBQXRCLENBQWpCLENBQXBCOztBQUVBLGNBQUssWUFBTCxHQUFvQiwyQkFBa0IsTUFBSyxFQUFMLENBQVEsYUFBUixDQUFzQixnQkFBdEIsQ0FBbEIsRUFBMkQ7QUFDM0UsdUJBQVksTUFBTSxJQUFOLENBQVcsTUFBSyxFQUFMLENBQVEsZ0JBQVIsQ0FBeUIsaUJBQXpCLENBQVgsQ0FEK0Q7QUFFM0UscUJBQVUsTUFBTSxJQUFOLENBQVcsTUFBSyxFQUFMLENBQVEsZ0JBQVIsQ0FBeUIsdUJBQXpCLENBQVg7QUFGaUUsU0FBM0QsQ0FBcEI7O0FBS0EsY0FBSyxXQUFMLEdBQW1CLE1BQU0sSUFBTixDQUFZLE1BQUssRUFBTCxDQUFRLGdCQUFSLENBQXlCLGNBQXpCLENBQVosRUFBdUQsR0FBdkQsQ0FBNEQsc0JBQWM7QUFDekYsbUJBQU8seUJBQWdCLFVBQWhCLENBQVA7QUFDSCxTQUZrQixDQUFuQjs7QUFJQTtBQUNBLGNBQUssV0FBTCxDQUFpQixnQkFBakIsRUFBbUMsWUFBTTtBQUFDLG9DQUFjLE9BQWQsQ0FBc0IsUUFBdEI7QUFBaUMsU0FBM0UsRUFBNkUsTUFBSyxFQUFMLENBQVEsYUFBUixDQUFzQixvQkFBdEIsQ0FBN0U7O0FBRUEsWUFBSSxPQUFPLFNBQVgsRUFBc0I7QUFDbEIsa0JBQUssZ0JBQUw7QUFDQSxrQkFBSyxxQkFBTCxHQUE2QixJQUE3QjtBQUNIOztBQUVELGNBQUssZ0JBQUwsQ0FBdUIsTUFBSyxZQUE1QjtBQUNBLGNBQUssZ0JBQUwsQ0FBdUIsTUFBSyxZQUE1Qjs7QUFFQSxjQUFLLGlCQUFMOztBQUVBLGNBQUsscUJBQUw7QUE1QnFCO0FBNkJ4Qjs7QUFFRDs7Ozs7OzRDQU1vQjs7QUFFaEIsZ0JBQUssS0FBSyxRQUFMLENBQWMsR0FBZCxDQUFMLEVBQTBCOztBQUV0QixvQkFBSyxDQUFDLEtBQUssYUFBWCxFQUEyQjtBQUN2Qix3QkFBSSxXQUFXLEtBQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsU0FBdEIsQ0FBZjtBQUNBLHlCQUFLLGFBQUwsR0FBcUIsNkJBQW1CLFFBQW5CLEVBQTZCLEVBQUMsS0FBTSxJQUFQLEVBQWEsV0FBVyxDQUF4QixFQUEyQixLQUFNLFNBQVMsWUFBVCxDQUFzQixVQUF0QixDQUFqQyxFQUE3QixDQUFyQjtBQUNBLHlCQUFLLGdCQUFMLENBQXVCLEtBQUssYUFBNUI7QUFDSDtBQUVKLGFBUkQsTUFRTztBQUNILG9CQUFLLEtBQUssYUFBVixFQUEwQjtBQUN0Qix5QkFBSyxhQUFMLENBQW1CLE9BQW5CO0FBQ0EseUJBQUssa0JBQUwsQ0FBeUIsS0FBSyxhQUE5QjtBQUNIO0FBQ0o7QUFFSjs7O2lDQUVRO0FBQ0w7O0FBRUE7QUFDQSxpQkFBSyxlQUFMLEdBQXVCLE1BQU0sSUFBTixDQUFZLEtBQUssRUFBTCxDQUFRLGdCQUFSLENBQXlCLGVBQXpCLENBQVosRUFBd0QsR0FBeEQsQ0FBNkQsbUJBQVc7QUFDM0YsdUJBQU87QUFDSCx3QkFBSSxPQUREO0FBRUgsNEJBQVEsK0JBQWdCLE9BQWhCLEVBQXlCLEdBQXpCLEdBQStCO0FBRnBDLGlCQUFQO0FBSUgsYUFMc0IsQ0FBdkI7QUFPSDs7QUFFRDs7OztBQU1BOzs7Ozs7OztnREFLd0I7QUFBQTs7QUFDcEI7O0FBRUE7QUFDQSxrQkFBTSxJQUFOLENBQVksS0FBSyxFQUFMLENBQVEsZ0JBQVIsQ0FBeUIsZ0NBQXpCLENBQVosRUFBeUUsT0FBekUsQ0FBa0YsVUFBQyxPQUFELEVBQWE7QUFDM0Ysb0JBQUksVUFBVSxPQUFLLGFBQUwsQ0FBbUIsWUFBbkIsQ0FBaUMsT0FBakMsQ0FBZDtBQUNBLHdCQUFRLEVBQVIsQ0FBVyxPQUFYLEVBQW9CLFVBQUMsS0FBRCxFQUFXO0FBQzNCLHdCQUFJLFFBQVEsUUFBUSxhQUFSLENBQXNCLE9BQXRCLENBQVo7QUFDQSx3QkFBSSxNQUFNLEtBQU4sS0FBZ0IsMkJBQWlCLEtBQWpCLENBQXVCLEdBQTNDLEVBQWdEO0FBQzVDLDhCQUFNLEtBQU47QUFDSCxxQkFGRCxNQUVPO0FBQ0gsOEJBQU0sSUFBTjtBQUNIO0FBQ0osaUJBUEQ7QUFRSCxhQVZEOztBQVlBO0FBQ0EsZ0JBQUksS0FBSyxhQUFULEVBQXdCO0FBQ3BCLG9CQUFJLHVCQUF1QixLQUFLLGFBQUwsQ0FBbUIsWUFBbkIsQ0FBZ0MsS0FBSyxhQUFMLENBQW1CLEVBQW5ELENBQTNCO0FBQ0EscUNBQXFCLEVBQXJCLENBQXdCLE9BQXhCLEVBQWlDLFVBQUMsS0FBRCxFQUFXO0FBQ3hDLHdCQUFJLE1BQU0sS0FBTixLQUFnQiwyQkFBaUIsS0FBakIsQ0FBdUIsT0FBdkMsSUFBa0QsTUFBTSxLQUFOLEtBQWdCLDJCQUFpQixLQUFqQixDQUF1QixFQUE3RixFQUFpRztBQUM3RiwrQkFBSyxhQUFMLENBQW1CLElBQW5CO0FBQ0gscUJBRkQsTUFFTztBQUNILCtCQUFLLGFBQUwsQ0FBbUIsS0FBbkI7QUFDSDtBQUNKLGlCQU5EOztBQVFBLG9CQUFJLHFCQUFxQixLQUFyQixLQUErQiwyQkFBaUIsS0FBakIsQ0FBdUIsRUFBdEQsSUFBNEQscUJBQXFCLEtBQXJCLEtBQStCLDJCQUFpQixLQUFqQixDQUF1QixPQUF0SCxFQUErSDtBQUMzSCx5QkFBSyxhQUFMLENBQW1CLElBQW5CO0FBQ0g7QUFDSjs7QUFHRDtBQUNBLGdCQUFJLGlCQUFpQixLQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLHlCQUF0QixDQUFyQjtBQUNBLGdCQUFJLHNCQUFzQixLQUFLLGFBQUwsQ0FBbUIsWUFBbkIsQ0FBaUMsY0FBakMsQ0FBMUI7O0FBRUEsZ0JBQUksb0JBQW9CLEtBQXBCLEtBQThCLDJCQUFpQixLQUFqQixDQUF1QixHQUF6RCxFQUE4RDtBQUMxRCxvQkFBSSxnQkFBZ0IsTUFBTSxJQUFOLENBQVksZUFBZSxnQkFBZixDQUFnQyxzQkFBaEMsQ0FBWixDQUFwQjtBQUNBLDhCQUFjLE9BQWQsQ0FBdUI7QUFBQSwyQkFBUyxNQUFNLFNBQU4sQ0FBZ0IsR0FBaEIsQ0FBb0IsU0FBcEIsQ0FBVDtBQUFBLGlCQUF2QjtBQUNBLG9DQUFvQixFQUFwQixDQUF1QixPQUF2QixFQUFnQyxVQUFVLEtBQVYsRUFBaUI7QUFDN0Msd0JBQUksTUFBTSxLQUFOLEtBQWdCLDJCQUFpQixLQUFqQixDQUF1QixHQUEzQyxFQUFnRDtBQUM1QztBQUNBLDRDQUFvQixHQUFwQixDQUF3QixPQUF4QjtBQUNBLHNDQUFjLE9BQWQsQ0FBdUIsVUFBQyxLQUFELEVBQVEsQ0FBUixFQUFjO0FBQ2pDLHVDQUFZO0FBQUEsdUNBQU0sTUFBTSxTQUFOLENBQWdCLE1BQWhCLENBQXVCLFNBQXZCLENBQU47QUFBQSw2QkFBWixFQUFxRCxNQUFPLElBQUksR0FBaEU7QUFDSCx5QkFGRDtBQUdIO0FBQ0osaUJBUkQ7QUFTSDs7QUFHRDtBQUNBLGdCQUFJLGFBQWEsS0FBSyxFQUFMLENBQVEsYUFBUixDQUFzQixjQUF0QixDQUFqQjtBQUNBLGdCQUFJLG9CQUFvQixLQUFLLGFBQUwsQ0FBbUIsWUFBbkIsQ0FBaUMsVUFBakMsRUFBNkMsSUFBN0MsQ0FBeEI7O0FBRUE7QUFDQSxnQkFBSSxrQkFBa0IsS0FBbEIsS0FBNEIsMkJBQWlCLEtBQWpCLENBQXVCLEVBQW5ELElBQXlELGtCQUFrQixLQUFsQixLQUE0QiwyQkFBaUIsS0FBakIsQ0FBdUIsT0FBaEgsRUFBeUg7QUFDckgsMkJBQVcsYUFBWCxDQUF5QixPQUF6QixFQUFrQyxJQUFsQztBQUNILGFBRkQsTUFFTztBQUNILGtDQUFrQixFQUFsQixDQUFxQixPQUFyQixFQUE4QixVQUFDLEtBQUQsRUFBVztBQUNyQyx3QkFBSSxNQUFNLEtBQU4sS0FBZ0IsMkJBQWlCLEtBQWpCLENBQXVCLE9BQXZDLElBQWtELE1BQU0sS0FBTixLQUFnQiwyQkFBaUIsS0FBakIsQ0FBdUIsRUFBN0YsRUFBaUc7QUFDN0YsbUNBQVk7QUFBQSxtQ0FBTSxXQUFXLGFBQVgsQ0FBeUIsT0FBekIsRUFBa0MsSUFBbEMsRUFBTjtBQUFBLHlCQUFaLEVBQTRELEdBQTVEO0FBQ0EsMENBQWtCLEdBQWxCLENBQXNCLE9BQXRCO0FBQ0gscUJBSEQsTUFHTztBQUNILG1DQUFXLGFBQVgsQ0FBeUIsT0FBekIsRUFBa0MsS0FBbEM7QUFDSDtBQUNKLGlCQVBEO0FBUUg7O0FBR0Q7QUFDQSxrQkFBTSxJQUFOLENBQVksS0FBSyxFQUFMLENBQVEsZ0JBQVIsQ0FBeUIsa0NBQXpCLENBQVosRUFBMkUsT0FBM0UsQ0FBb0YscUJBQWE7O0FBRTdGLG9CQUFJLFVBQVUsT0FBSyxhQUFMLENBQW1CLFlBQW5CLENBQWlDLFNBQWpDLENBQWQ7O0FBRUE7QUFDQSxvQkFBSSxRQUFRLEtBQVIsS0FBa0IsMkJBQWlCLEtBQWpCLENBQXVCLEVBQXpDLElBQStDLFFBQVEsS0FBUixLQUFrQiwyQkFBaUIsS0FBakIsQ0FBdUIsT0FBNUYsRUFBcUc7QUFDakcsOEJBQVUsU0FBVixDQUFvQixNQUFwQixDQUEyQixjQUEzQjtBQUNILGlCQUZELE1BRU87QUFDSCw0QkFBUSxFQUFSLENBQVcsT0FBWCxFQUFvQixVQUFDLEtBQUQsRUFBVztBQUMzQiw0QkFBSSxNQUFNLEtBQU4sS0FBZ0IsMkJBQWlCLEtBQWpCLENBQXVCLE9BQXZDLElBQWtELE1BQU0sS0FBTixLQUFnQiwyQkFBaUIsS0FBakIsQ0FBdUIsRUFBN0YsRUFBaUc7QUFDN0Ysc0NBQVUsU0FBVixDQUFvQixNQUFwQixDQUEyQixjQUEzQjtBQUNIO0FBQ0oscUJBSkQ7QUFLSDtBQUdKLGFBaEJEOztBQWtCQTtBQUNBLGdCQUFJLGlCQUFpQixLQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLCtCQUF0QixDQUFyQjtBQUNBLGdCQUFJLDBCQUEwQixLQUFLLGFBQUwsQ0FBbUIsWUFBbkIsQ0FBaUMsY0FBakMsRUFBaUQsSUFBakQsQ0FBOUI7O0FBRUEsZ0JBQUksd0JBQXdCLEtBQXhCLEtBQWtDLDJCQUFpQixLQUFqQixDQUF1QixFQUE3RCxFQUFpRTtBQUM3RCwrQkFBZSxTQUFmLENBQXlCLE1BQXpCLENBQWdDLFNBQWhDO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsd0NBQXdCLElBQXhCLENBQTZCLGVBQTdCLEVBQThDO0FBQUEsMkJBQU0sZUFBZSxTQUFmLENBQXlCLE1BQXpCLENBQWdDLFNBQWhDLENBQU47QUFBQSxpQkFBOUM7QUFDSDtBQUVKOzs7MkNBRWtCO0FBQUE7O0FBRWY7QUFDQSxpQkFBSyxXQUFMLENBQWlCLE9BQWpCLEVBQTBCLFVBQUMsS0FBRCxFQUFXO0FBQ2pDLHVCQUFPLFNBQVAsQ0FBaUIsSUFBakIsQ0FBc0I7QUFDbEIsNkJBQTBCLGdCQURSO0FBRWxCLDBDQUEwQixpQkFGUjtBQUdsQiwrQkFBMEIsY0FIUjtBQUlsQixrQ0FBMEIsY0FKUjtBQUtsQiwyQkFBMEIsTUFBTSxjQUFOLENBQXFCLFlBQXJCLENBQWtDLE1BQWxDLENBTFI7QUFNbEIsb0NBQTBCLFNBQVMsZUFBVCxDQUF5QjtBQU5qQyxpQkFBdEI7QUFTSCxhQVZELEVBVUcsOEJBVkg7O0FBWUEsaUJBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixVQUFDLEtBQUQsRUFBVzs7QUFFakMsb0JBQUksT0FBTyxNQUFNLGNBQU4sQ0FBcUIsYUFBckIsQ0FBbUMsaUJBQW5DLENBQVg7O0FBRUEsdUJBQU8sU0FBUCxDQUFpQixJQUFqQixDQUFzQjtBQUNsQiw2QkFBMEIsZ0JBRFI7QUFFbEIsMENBQTBCLGlCQUZSO0FBR2xCLCtCQUEwQixpQkFIUjtBQUlsQixrQ0FBMEIsS0FBSyxZQUFMLENBQWtCLGtCQUFsQixDQUpSO0FBS2xCLDJCQUEwQixLQUFLLFlBQUwsQ0FBa0IsTUFBbEIsQ0FMUjtBQU1sQixvQ0FBMEIsU0FBUyxlQUFULENBQXlCOztBQU5qQyxpQkFBdEI7QUFVSCxhQWRELEVBY0csdUJBZEg7O0FBZ0JBLGlCQUFLLFdBQUwsQ0FBaUIsT0FBakIsRUFBMEIsVUFBQyxLQUFELEVBQVc7O0FBRWpDLG9CQUFJLE9BQU8sTUFBTSxjQUFqQjs7QUFFQSx1QkFBTyxTQUFQLENBQWlCLElBQWpCLENBQXNCO0FBQ2xCLDZCQUEwQixnQkFEUjtBQUVsQiwwQ0FBMEIsaUJBRlI7QUFHbEIsK0JBQTBCLGlCQUhSO0FBSWxCLGtDQUEwQixLQUFLLFlBQUwsQ0FBa0Isa0JBQWxCLENBSlI7QUFLbEIsMkJBQTBCLEtBQUssWUFBTCxDQUFrQixNQUFsQixDQUxSO0FBTWxCLG9DQUEwQixTQUFTLGVBQVQsQ0FBeUI7QUFOakMsaUJBQXRCO0FBU0gsYUFiRCxFQWFHLHVDQWJIOztBQWVBLGlCQUFLLFdBQUwsQ0FBaUIsT0FBakIsRUFBMEIsVUFBQyxLQUFELEVBQVc7QUFDakMsdUJBQU8sU0FBUCxDQUFpQixJQUFqQixDQUFzQjtBQUNsQiw2QkFBMEIsZ0JBRFI7QUFFbEIsMENBQTBCLGlCQUZSO0FBR2xCLCtCQUEwQixXQUhSO0FBSWxCLGtDQUEwQixXQUpSO0FBS2xCLDJCQUEwQixNQUFNLGNBQU4sQ0FBcUIsWUFBckIsQ0FBa0MsTUFBbEMsQ0FMUjtBQU1sQixvQ0FBMEIsU0FBUyxlQUFULENBQXlCO0FBTmpDLGlCQUF0QjtBQVFILGFBVEQsRUFTRywyQkFUSDs7QUFZQSxpQkFBSyxRQUFMLDBCQUE4QixRQUE5QixFQUF3QyxVQUFDLEtBQUQsRUFBVzs7QUFFL0Msb0JBQUksVUFBVSx3QkFBVSxPQUFLLGVBQWYsRUFBZ0M7QUFBQSwyQkFBaUIsd0JBQWMsY0FBZCxDQUE2QixHQUE3QixJQUFvQyxjQUFjLE1BQW5FO0FBQUEsaUJBQWhDLENBQWQ7O0FBRUEsb0JBQUksV0FBVyxZQUFZLE9BQUsscUJBQWhDLEVBQXVEO0FBQ25ELHdCQUFJLGdCQUFnQixRQUFRLEVBQVIsQ0FBVyxhQUFYLENBQXlCLFNBQXpCLENBQXBCO0FBQ0Esd0JBQUksYUFBSixFQUFtQjs7QUFFZiwrQkFBTyxTQUFQLENBQWlCLElBQWpCLENBQXNCO0FBQ2xCLHFDQUEwQixnQkFEUjtBQUVsQixrREFBMEIsaUJBRlI7QUFHbEIsdUNBQTBCLGNBQWMsWUFBZCxDQUEyQixNQUEzQixDQUhSO0FBSWxCLG1DQUEwQixPQUFPLFFBQVAsQ0FBZ0IsUUFKeEI7QUFLbEIsNENBQTBCLFNBQVMsZUFBVCxDQUF5QjtBQUxqQyx5QkFBdEI7O0FBUUEsK0JBQUsscUJBQUwsR0FBNkIsT0FBN0I7QUFDSDtBQUVKO0FBRUosYUFyQkQ7QUF1Qkg7O0FBRUQ7Ozs7Ozs7OztrQkFVVyxROzs7Ozs7Ozs7OztBQ3ZTZjs7OztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTtBQUNBOztBQUlBOzs7QUFLQTs7QUFFQTs7O0lBR00sa0I7OztBQUVGLGdDQUFZLEVBQVosRUFBZ0IsT0FBaEIsRUFBeUI7QUFBQTs7QUFBQSw0SUFFZixFQUZlLEVBRVgsT0FGVzs7QUFJckIsWUFBSSxZQUFZLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0Isd0JBQXRCLENBQWhCO0FBQ0EsWUFBSSxTQUFKLEVBQWU7QUFDWCxrQkFBSyxjQUFMLEdBQXNCLDRCQUFvQixTQUFwQixDQUF0QjtBQUNBLGtCQUFLLGdCQUFMLENBQXVCLE1BQUssY0FBNUI7O0FBRUEsZ0JBQUksaUJBQWlCLE1BQUssYUFBTCxDQUFtQixZQUFuQixDQUFpQyxTQUFqQyxFQUE0QyxJQUE1QyxDQUFyQjs7QUFFQSxnQkFBSyxlQUFlLEtBQWYsS0FBeUIsMkJBQWlCLEtBQWpCLENBQXVCLEdBQXJELEVBQTBEO0FBQ3RELHNCQUFLLGdCQUFMO0FBQ0gsYUFGRCxNQUVPOztBQUVILCtCQUFlLEVBQWYsQ0FBa0IsT0FBbEIsRUFBMkIsVUFBQyxLQUFELEVBQVc7QUFDbEMsd0JBQUksTUFBTSxLQUFOLEtBQWdCLDJCQUFpQixLQUFqQixDQUF1QixPQUF2QyxJQUFrRCxNQUFNLEtBQU4sS0FBZ0IsMkJBQWlCLEtBQWpCLENBQXVCLEVBQTdGLEVBQWlHO0FBQzdGLDhCQUFLLGdCQUFMO0FBQ0EsdUNBQWUsR0FBZixDQUFtQixPQUFuQjtBQUNIO0FBQ0osaUJBTEQ7QUFPSDtBQUdKOztBQUVELFlBQUksaUJBQWlCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsZ0JBQXRCLENBQXJCO0FBQ0EsWUFBSSxjQUFKLEVBQW9CO0FBQ2hCLGtCQUFLLFlBQUwsR0FBb0IsMkJBQWtCLGNBQWxCLENBQXBCO0FBQ0Esa0JBQUssZ0JBQUwsQ0FBdUIsTUFBSyxZQUE1QjtBQUNIOztBQUVEO0FBQ0EsWUFBSSxPQUFPLFNBQVgsRUFBc0I7QUFDbEIsa0JBQUssZ0JBQUw7QUFDSDs7QUFwQ29CO0FBc0N4Qjs7QUFFRDs7OztBQU9BOzs7Ozs7MkNBTW1CO0FBQ2YsaUJBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixVQUFDLEtBQUQsRUFBVzs7QUFFakMsb0JBQUksU0FBUyxNQUFNLGNBQW5COztBQUVBLG9CQUFJLFdBQVcsT0FBTyxZQUFQLENBQW9CLGdCQUFwQixDQUFmO0FBQ0Esb0JBQUksbUJBQW1CLE9BQU8sWUFBUCxDQUFvQix3QkFBcEIsQ0FBdkI7O0FBRUEsb0JBQUksUUFBSixFQUFjO0FBQ1YsMkJBQU8sU0FBUCxDQUFpQixJQUFqQixDQUFzQjtBQUNsQixpQ0FBUyxlQURTO0FBRWxCLDhDQUFzQixpQkFGSjtBQUdsQixvQ0FBWSxRQUhNO0FBSWxCLHdDQUFpQixTQUFTLGVBQVQsQ0FBeUI7QUFKeEIscUJBQXRCO0FBTUgsaUJBUEQsTUFPTyxJQUFJLGdCQUFKLEVBQXNCO0FBQ3pCLDJCQUFPLFNBQVAsQ0FBaUIsSUFBakIsQ0FBc0I7QUFDbEIsaUNBQVMsZUFEUztBQUVsQiw4Q0FBc0IsaUJBRko7QUFHbEIsNENBQW9CLGdCQUhGO0FBSWxCLHdDQUFpQixTQUFTLGVBQVQsQ0FBeUI7QUFKeEIscUJBQXRCO0FBTUg7QUFFSixhQXZCRCxFQXVCRyxTQXZCSDs7QUF5QkEsaUJBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixZQUFNOztBQUU1Qix1QkFBTyxTQUFQLENBQWlCLElBQWpCLENBQXNCO0FBQ2xCLDZCQUFTLFdBRFM7QUFFbEIsNEJBQVE7QUFGVSxpQkFBdEI7QUFLSCxhQVBELEVBT0csa0NBUEg7QUFRSDs7OzJDQUVrQjtBQUNmLGtCQUFNLElBQU4sQ0FBWSxLQUFLLGNBQUwsQ0FBb0IsRUFBcEIsQ0FBdUIsZ0JBQXZCLENBQXdDLGlCQUF4QyxDQUFaLEVBQXlFLE9BQXpFLENBQWtGO0FBQUEsdUJBQVEsS0FBSyxTQUFMLENBQWUsTUFBZixDQUFzQixRQUF0QixDQUFSO0FBQUEsYUFBbEY7QUFDSDs7QUFHRDs7Ozs7OzJDQUttQixLLEVBQU8sQ0FFekI7Ozs7OztrQkFLVSxrQjs7Ozs7Ozs7Ozs7QUMxSGY7Ozs7QUFDQTs7OztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVJBOzs7QUFJQTs7O0FBTUE7OztBQUdBOztBQUVBOzs7SUFHTSxJOzs7QUFFRixrQkFBWSxFQUFaLEVBQWdCLE9BQWhCLEVBQXlCO0FBQUE7O0FBQUEsZ0hBQ2YsRUFEZSxFQUNYLE9BRFc7O0FBR3JCLGNBQUssUUFBTCwwQkFBNkIsUUFBN0IsRUFBdUMsTUFBSyxNQUE1Qzs7QUFFQTtBQUNBLFlBQUksYUFBYSxNQUFLLEVBQUwsQ0FBUSxVQUF6Qjs7QUFFQSxjQUFLLGFBQUwsR0FBcUIsK0JBQXVCLE1BQUssRUFBTCxLQUFZLE1BQWIsR0FBdUIsTUFBdkIsR0FBZ0MsVUFBdEQsQ0FBckI7O0FBRUEsWUFBSSxtQkFBbUIsTUFBSyxFQUFMLENBQVEsYUFBUixDQUFzQiwyQkFBdEIsQ0FBdkI7QUFDQSxZQUFJLGdCQUFKLEVBQXNCO0FBQ2xCLGtCQUFLLGdCQUFMLEdBQXdCLGdCQUF4QjtBQUNBLGtCQUFLLFdBQUwsQ0FBa0IsUUFBbEIsRUFBNEIsTUFBSyxjQUFqQyxFQUFpRCxNQUFLLGFBQUwsQ0FBbUIsZUFBcEU7QUFDSDs7QUFkb0I7QUFpQnhCOztBQUVEOzs7Ozs7dUNBVWUsSyxFQUFPO0FBQUE7O0FBRWxCLGdCQUFJLENBQUMsS0FBSyxXQUFWLEVBQXVCOztBQUVuQixxQkFBSyxXQUFMLEdBQW1CLHNCQUF1QixZQUFNO0FBQzVDLHdCQUFJLFlBQVksT0FBSyxhQUFMLENBQW1CLDRCQUFuQixFQUFoQjtBQUNBLG9DQUFNLEdBQU4sQ0FBVyxPQUFLLGdCQUFoQixFQUFrQyxFQUFDLDJCQUF5QixZQUFZLEdBQXJDLFFBQUQsRUFBbEM7QUFDQSwyQkFBSyxXQUFMLEdBQW1CLElBQW5CO0FBQ0gsaUJBSmtCLENBQW5CO0FBTUg7QUFDSjs7OzRCQWZRO0FBQ0wsbUJBQU8sS0FBSyxFQUFMLENBQVEsWUFBUixDQUFxQixjQUFyQixDQUFQO0FBQ0g7Ozs7OztrQkFpQlUsSTs7Ozs7Ozs7Ozs7QUM5RGY7Ozs7QUFFQTs7OztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFUQTtBQUNBOzs7QUFLQTs7O0FBS0E7O0FBRUE7OztJQUdNLFU7OztBQUVGLHdCQUFZLEVBQVosRUFBZ0IsT0FBaEIsRUFBeUI7QUFBQTs7QUFBQSw0SEFFZixFQUZlLEVBRVgsT0FGVzs7QUFJckIsY0FBSyxXQUFMLENBQWlCLE9BQWpCLEVBQTBCLE1BQUssOEJBQS9CLEVBQStELHNCQUEvRDs7QUFFQSxZQUFJLGdCQUFnQixNQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLGVBQXRCLENBQXBCOztBQUVBLFlBQUssTUFBSyxRQUFMLENBQWMsR0FBZCxDQUFMLEVBQTBCO0FBQ3RCLGtCQUFLLEtBQUwsR0FBYSwwQkFBaUIsYUFBakIsQ0FBYjtBQUNILFNBRkQsTUFFTztBQUNILGtCQUFLLEtBQUwsR0FBYSwrQkFBc0IsYUFBdEIsQ0FBYjtBQUNIOztBQUVELFlBQUksZUFBZSxNQUFLLGFBQUwsQ0FBbUIsWUFBbkIsQ0FBaUMsYUFBakMsQ0FBbkI7O0FBRUEsWUFBSSxhQUFhLEtBQWIsS0FBdUIsMkJBQWlCLEtBQWpCLENBQXVCLEdBQWxELEVBQXVEO0FBQ25ELGtCQUFLLEtBQUwsQ0FBVyxjQUFYO0FBQ0Esa0JBQUssYUFBTCxDQUFtQixjQUFuQixDQUFtQyxZQUFuQztBQUNILFNBSEQsTUFHTztBQUNILHlCQUFhLEVBQWIsQ0FBZ0IsT0FBaEIsRUFBeUIsVUFBQyxLQUFELEVBQVc7QUFDaEMsb0JBQUksTUFBTSxLQUFOLEtBQWdCLDJCQUFpQixLQUFqQixDQUF1QixFQUF2QyxJQUE2QyxNQUFNLEtBQU4sS0FBZ0IsMkJBQWlCLEtBQWpCLENBQXVCLE9BQXhGLEVBQWlHO0FBQzdGLDBCQUFLLEtBQUwsQ0FBVyxjQUFYO0FBQ0EsaUNBQWEsR0FBYixDQUFpQixPQUFqQjtBQUNBLDBCQUFLLGFBQUwsQ0FBbUIsY0FBbkIsQ0FBbUMsWUFBbkM7QUFDSDtBQUNKLGFBTkQ7QUFPSDs7QUFFRDtBQUNBLFlBQUksVUFBVSxNQUFLLEVBQUwsQ0FBUSxnQkFBUixDQUF5QixTQUF6QixDQUFkOztBQUVBLGdCQUFRLE9BQVIsQ0FBZ0Isa0JBQVU7QUFDdEIsa0JBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixZQUFNOztBQUU1QixvQkFBSSxXQUFXLE9BQU8sWUFBUCxDQUFvQixnQkFBcEIsQ0FBZjtBQUNBLG9CQUFJLG1CQUFtQixPQUFPLFlBQVAsQ0FBb0Isd0JBQXBCLENBQXZCOztBQUVBLG9CQUFJLFFBQUosRUFBYztBQUNWLDJCQUFPLFNBQVAsQ0FBaUIsSUFBakIsQ0FBc0I7QUFDbEIsaUNBQVMsZUFEUztBQUVsQiw4Q0FBc0IsaUJBRko7QUFHbEIsb0NBQVksUUFITTtBQUlsQix3Q0FBaUIsU0FBUyxlQUFULENBQXlCO0FBSnhCLHFCQUF0QjtBQU1ILGlCQVBELE1BT08sSUFBSSxnQkFBSixFQUFzQjtBQUN6QiwyQkFBTyxTQUFQLENBQWlCLElBQWpCLENBQXNCO0FBQ2xCLGlDQUFTLGVBRFM7QUFFbEIsOENBQXNCLGlCQUZKO0FBR2xCLDRDQUFvQixnQkFIRjtBQUlsQix3Q0FBaUIsU0FBUyxlQUFULENBQXlCO0FBSnhCLHFCQUF0QjtBQU1IO0FBRUosYUFyQkQsRUFxQkcsTUFyQkg7QUFzQkgsU0F2QkQ7O0FBaENxQjtBQXlEeEI7O0FBRUQ7Ozs7QUFPQTs7Ozs7OzsyQ0FLbUIsQ0FFbEI7O0FBR0Q7Ozs7Ozt1REFLK0IsSyxFQUFPOztBQUVsQyxnQkFBSSxPQUFPLEtBQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsbUJBQXRCLENBQVg7O0FBRUEsZ0JBQUssS0FBSyxTQUFMLENBQWUsUUFBZixDQUF3QixRQUF4QixDQUFMLEVBQXlDO0FBQ3JDLHVDQUFNO0FBQ0YsNkJBQVUsSUFEUjtBQUVGLDhCQUFXLElBRlQ7QUFHRiw0QkFBUyxDQUFDLENBQUQsRUFBSSxLQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLHNCQUF0QixFQUE4QyxZQUFsRCxDQUhQO0FBSUYsNEJBQVMsZ0JBSlA7QUFLRiw4QkFBVyxvQkFBTTtBQUNiLDZCQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXNCLFFBQXRCO0FBQ0g7QUFQQyxpQkFBTjs7QUFVQSxxQkFBSyxFQUFMLENBQVEsYUFBUixDQUFzQixvQkFBdEIsRUFBNEMsU0FBNUMsQ0FBc0QsR0FBdEQsQ0FBMEQsVUFBMUQ7QUFFSDtBQUVKOzs7Ozs7a0JBS1UsVTs7Ozs7Ozs7O0FDM0hmOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ0EsSUFBTSxXQUFXO0FBQ2IsNkJBRGE7QUFFYiw4QkFGYTtBQUdiLHNDQUhhO0FBSWIsb0NBSmE7QUFLYixtREFMYTtBQU1iLG9DQU5hO0FBT2Isd0NBUGE7QUFRYjtBQVJhLENBQWpCOztrQkFXZSxROzs7Ozs7Ozs7OztBQ3RCZjs7OztBQUVBOzs7Ozs7Ozs7Ozs7SUFFTSxNOzs7QUFFRixvQkFBWSxFQUFaLEVBQWdCLE9BQWhCLEVBQXlCO0FBQUE7O0FBSXJCO0FBSnFCLG9IQUVmLEVBRmUsRUFFWCxPQUZXOztBQUtyQixjQUFLLFVBQUwsR0FBa0IseUJBQWdCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsY0FBdEIsQ0FBaEIsQ0FBbEI7O0FBRUEsWUFBSSxPQUFPLFNBQVgsRUFBc0I7QUFDbEIsa0JBQUssZ0JBQUw7QUFDSDs7QUFUb0I7QUFXeEI7Ozs7MkNBRWtCO0FBQ2YsaUJBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixZQUFNO0FBQzVCLHVCQUFPLFNBQVAsQ0FBaUIsSUFBakIsQ0FBc0I7QUFDbEIsNkJBQVMsY0FEUztBQUVsQiwwQ0FBc0IsaUJBRko7QUFHbEIsb0NBQWlCLFNBQVMsZUFBVCxDQUF5QjtBQUh4QixpQkFBdEI7QUFNSCxhQVBELEVBT0csTUFQSDtBQVFIOzs7Ozs7a0JBSVUsTTs7Ozs7Ozs7Ozs7OztBQy9CZjs7OztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUlBOzs7Ozs7Ozs7OytlQVZBOzs7QUFHQTs7QUFJQTs7QUFFQTs7O0FBR0E7QUFDQSxJQUFNLHFCQUFxQixHQUEzQjtBQUNBLElBQU0scUJBQXFCLEdBQTNCOztBQUVBOzs7O0lBR00sTTs7O0FBRUYsb0JBQVksRUFBWixFQUFnQixPQUFoQixFQUF5QjtBQUFBOztBQUFBLG9IQUVmLEVBRmUsRUFFWCxPQUZXOztBQUlyQixjQUFLLFVBQUwsR0FBa0IseUJBQWdCLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsY0FBdEIsQ0FBaEIsQ0FBbEI7O0FBRUE7QUFDQSxjQUFLLFdBQUwsQ0FBaUIsZUFBakIsRUFBa0MsTUFBSyxxQkFBdkM7QUFDQSxjQUFLLFdBQUwsQ0FBaUIsT0FBakIsRUFBMEIsTUFBSyx1QkFBL0IsRUFBd0QsY0FBeEQsRUFScUIsQ0FRb0Q7QUFDekUsY0FBSyxXQUFMLENBQWlCLE9BQWpCLEVBQTBCLE1BQUsscUJBQS9CLEVBQXNELFNBQXREO0FBQ0EsY0FBSyxXQUFMLENBQWlCLE9BQWpCLEVBQTBCLE1BQUsscUJBQS9CLEVBQXNELGFBQXREOztBQUVBLGNBQUssUUFBTCwwQkFBOEIsUUFBOUIsRUFBd0MsTUFBSyxjQUE3Qzs7QUFFQSxjQUFLLFVBQUwsQ0FBZ0IsRUFBaEIsQ0FBbUIsTUFBbkIsRUFBMkIsVUFBQyxLQUFELEVBQVc7QUFDbEMsa0JBQUssRUFBTCxDQUFRLFNBQVIsQ0FBa0IsR0FBbEIsQ0FBc0IsYUFBdEI7QUFDSCxTQUZEOztBQUlBLGNBQUssVUFBTCxDQUFnQixFQUFoQixDQUFtQixPQUFuQixFQUE0QixVQUFDLEtBQUQsRUFBVztBQUNuQyxrQkFBSyxFQUFMLENBQVEsU0FBUixDQUFrQixNQUFsQixDQUF5QixhQUF6QjtBQUNILFNBRkQ7O0FBbEJxQjtBQXNCeEI7O0FBRUQ7Ozs7OzswQ0FNa0IsVSxFQUFZLGtCLEVBQW9CO0FBQzlDLDhIQUF3QixVQUF4QixFQUFvQyxrQkFBcEM7O0FBRUEsZ0JBQUssS0FBSyxRQUFMLENBQWMsR0FBZCxDQUFMLEVBQTBCO0FBQ3RCLHFCQUFLLEtBQUwsR0FEc0IsQ0FDUjtBQUNqQjtBQUVKOzs7K0JBRU07QUFDSCxpQkFBSyxNQUFMLEdBQWMsSUFBZDtBQUNBLGlCQUFLLEVBQUwsQ0FBUSxTQUFSLENBQWtCLEdBQWxCLENBQXNCLE1BQXRCOztBQUVBLHFCQUFTLElBQVQsQ0FBYyxTQUFkLENBQXdCLEdBQXhCLENBQTRCLGFBQTVCO0FBQ0g7OztnQ0FFTztBQUNKLGlCQUFLLE1BQUwsR0FBYyxLQUFkO0FBQ0EsaUJBQUssRUFBTCxDQUFRLFNBQVIsQ0FBa0IsTUFBbEIsQ0FBeUIsTUFBekI7O0FBRUEscUJBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBd0IsTUFBeEIsQ0FBK0IsYUFBL0I7QUFDSDs7QUFJRDs7Ozs7O29DQUtZLE0sRUFBUSxLLEVBQU87O0FBRXZCLG9CQUFRLEdBQVIsQ0FBYSxNQUFiOztBQUdBLGdCQUFLLEtBQUssUUFBTCxDQUFjLEdBQWQsQ0FBTCxFQUEwQjtBQUN0Qix1Q0FBTTtBQUNGLDZCQUFVLEVBQUU7O0FBRVIsNEJBQUksU0FBSixHQUFnQjtBQUNaLG1DQUFPLHdCQUFjLGNBQWQsQ0FBNkIsR0FBcEM7QUFDSCx5QkFKSzs7QUFNTiw0QkFBSSxTQUFKLENBQWMsS0FBZCxFQUFxQjtBQUNqQixvREFBYyxRQUFkLENBQXdCLFdBQVcsS0FBWCxDQUF4QixFQUEyQyxDQUEzQyxFQURpQixDQUM4QjtBQUNsRDs7QUFSSyxxQkFEUjtBQVlGLDhCQUFXLEtBWlQ7QUFhRiwrQkFBWSxNQWJWO0FBY0YsNEJBQVM7QUFkUCxpQkFBTjtBQWlCSCxhQWxCRCxNQWtCTztBQUNIO0FBQ0Esd0NBQWMsUUFBZCxDQUF3QixNQUF4QjtBQUNBLHFCQUFLLEtBQUw7QUFDSDtBQUNKOztBQUdEOzs7Ozs7a0RBSzBCO0FBQ3RCLGlCQUFLLE1BQUwsR0FBYyxLQUFLLEtBQUwsRUFBZCxHQUE2QixLQUFLLElBQUwsRUFBN0I7QUFDSDs7OzhDQUVxQixLLEVBQU87O0FBRXpCLGdCQUFJLE1BQU0sTUFBTixLQUFpQixLQUFLLEVBQTFCLEVBQThCO0FBQzFCLHdDQUFjLE9BQWQsQ0FBc0IsUUFBdEI7QUFDSDtBQUVKOzs7OENBRXFCLEssRUFBTzs7QUFFekIsZ0JBQUssRUFBRSxNQUFNLE9BQU4sSUFBaUIsTUFBTSxPQUF6QixDQUFMLEVBQXlDO0FBQ3JDLHNCQUFNLGNBQU47O0FBRUEsb0JBQUksY0FBYyxNQUFNLGNBQU4sQ0FBcUIsWUFBckIsQ0FBa0MsTUFBbEMsRUFBMEMsS0FBMUMsQ0FBZ0QsQ0FBaEQsQ0FBbEI7QUFDQSxvQkFBSSxnQkFBZ0IsU0FBUyxhQUFULGNBQWtDLFdBQWxDLFNBQW1ELFVBQXZFOztBQUVBLG9CQUFJLFlBQVksK0JBQWlCLGFBQWpCLENBQWhCO0FBQ0Esb0JBQUksU0FBVyxLQUFLLFFBQUwsQ0FBYyxHQUFkLENBQUYsR0FDVCxVQUFVLEdBQVYsR0FBZ0Isa0JBQWhCLEdBQXFDLENBRDVCLEdBQ2dDO0FBQ3pDLDBCQUFVLEdBQVYsR0FBZ0IsRUFGcEI7O0FBSUEsb0JBQUksV0FBWSxLQUFLLEdBQUwsQ0FBVSx3QkFBYyxjQUFkLENBQTZCLEdBQTdCLEdBQW1DLE1BQTdDLENBQWhCOztBQUVBLHFCQUFLLFdBQUwsQ0FBaUIsTUFBakIsRUFBeUIsV0FBVyxrQkFBcEM7QUFFSDtBQUVKOzs7OENBRXFCLEssRUFBTztBQUN6QixrQkFBTSxjQUFOO0FBQ0Esa0JBQU0sZUFBTjs7QUFFQSxpQkFBSyxXQUFMLENBQWlCLENBQWpCLEVBQW9CLHdCQUFjLGNBQWQsQ0FBNkIsR0FBN0IsR0FBbUMsa0JBQXZEO0FBQ0g7Ozt5Q0FFZ0I7O0FBRWIsZ0JBQUksd0JBQWMsY0FBZCxDQUE2QixHQUE3QixJQUFvQyxHQUF4QyxFQUE2QztBQUN6QyxxQkFBSyxFQUFMLENBQVEsU0FBUixDQUFrQixNQUFsQixDQUF5QixXQUF6QjtBQUNBLHlCQUFTLElBQVQsQ0FBYyxTQUFkLENBQXdCLE1BQXhCLENBQStCLGdCQUEvQjtBQUNILGFBSEQsTUFHTztBQUNILHFCQUFLLEVBQUwsQ0FBUSxTQUFSLENBQWtCLEdBQWxCLENBQXNCLFdBQXRCO0FBQ0EseUJBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBd0IsR0FBeEIsQ0FBNEIsZ0JBQTVCO0FBQ0g7QUFFSjs7Ozs7O2tCQUtVLE07Ozs7Ozs7Ozs7O0FDMUtmOzs7O0FBR0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBUkE7QUFDQTs7O0FBR0E7OztBQU1BOzs7QUFJQTs7QUFFQTs7O0lBR00sUTs7O0FBRUYsc0JBQVksRUFBWixFQUFnQixPQUFoQixFQUF5QjtBQUFBOztBQUFBLHdIQUVmLEVBRmUsRUFFWCxPQUZXOztBQUlyQixjQUFLLGFBQUwsR0FBcUIsTUFBSyxFQUFMLENBQVEsYUFBUixDQUFzQixpQkFBdEIsQ0FBckI7O0FBRUEsWUFBSSxlQUFlLE1BQUssRUFBTCxDQUFRLGFBQVIsQ0FBc0IsU0FBdEIsQ0FBbkI7QUFDQSxjQUFLLE1BQUwsR0FBYyw2QkFBbUIsWUFBbkIsRUFBaUMsRUFBQyxLQUFLLEVBQU4sRUFBVSxVQUFVLEtBQXBCLEVBQTJCLE1BQU0sS0FBakMsRUFBd0MsV0FBVyxFQUFuRCxFQUF1RCxLQUFLLGFBQWEsWUFBYixDQUEwQixVQUExQixDQUE1RCxFQUFqQyxDQUFkOztBQUVBLFlBQUksZUFBZSxTQUFTLElBQVQsQ0FBYyxhQUFkLENBQTRCLDBCQUE1QixDQUFuQjtBQUNBLGNBQUssTUFBTCxHQUFjLDZCQUFtQixZQUFuQixFQUFpQyxFQUFDLEtBQUssRUFBTixFQUFVLFVBQVUsS0FBcEIsRUFBMkIsTUFBTSxJQUFqQyxFQUF1QyxXQUFXLEVBQWxELEVBQXNELEtBQUssYUFBYSxZQUFiLENBQTBCLFVBQTFCLENBQTNELEVBQWpDLENBQWQ7O0FBRUEsY0FBSyxXQUFMLENBQWlCLGVBQWpCLEVBQWtDLE1BQUsscUJBQXZDLEVBWnFCLENBWTBDOztBQVoxQztBQWN4Qjs7QUFFRDs7Ozs7O3FDQU1hLE0sRUFBUTs7QUFFakIsZ0JBQUksS0FBSyxhQUFULEVBQXdCO0FBQ3BCLHFDQUFNLEtBQUssYUFBWDtBQUNBLHFCQUFLLGFBQUwsQ0FBbUIsU0FBbkIsR0FBK0IsQ0FBL0I7QUFDSDs7QUFFRCxpQkFBSyxhQUFMLEdBQXFCLE1BQXJCOztBQUVBLGdCQUFLLENBQUMsS0FBSyxhQUFMLENBQW1CLFFBQW5CLENBQTZCLE1BQTdCLENBQU4sRUFBOEM7QUFDMUMscUJBQUssYUFBTCxDQUFtQixXQUFuQixDQUFnQyxNQUFoQzs7QUFFQSx1QkFBTyxLQUFQLENBQWEsT0FBYixHQUF1QixDQUF2Qjs7QUFFQSx1Q0FBTTtBQUNGLDZCQUFTLE1BRFA7QUFFRiw4QkFBVyxJQUZUO0FBR0YsNEJBQVEsY0FITjtBQUlGLDZCQUFVLENBQUMsQ0FBRCxFQUFJLENBQUo7QUFKUixpQkFBTjtBQU9IO0FBSUo7OztrQ0FFUztBQUNOLHFCQUFTLElBQVQsQ0FBYyxTQUFkLENBQXdCLEdBQXhCLENBQTRCLGdCQUE1QjtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxJQUFaO0FBQ0g7OzsrQkFFTTtBQUNILGlCQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EscUJBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBd0IsR0FBeEIsQ0FBNEIsZ0JBQTVCOztBQUVBOzs7O0FBSUg7OztnQ0FFTztBQUNKLGlCQUFLLE1BQUwsR0FBYyxLQUFkO0FBQ0EscUJBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBd0IsTUFBeEIsQ0FBK0IsZ0JBQS9CO0FBQ0EscUJBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBd0IsTUFBeEIsQ0FBK0IsYUFBL0I7QUFDQSxxQkFBUyxJQUFULENBQWMsU0FBZCxDQUF3QixNQUF4QixDQUErQixnQkFBL0I7O0FBRUEsaUJBQUssTUFBTCxDQUFZLEtBQVo7QUFDQSxpQkFBSyxNQUFMLENBQVksWUFBWixHQUEyQixDQUEzQjs7QUFFQSxpQkFBSyxNQUFMLENBQVksWUFBWixHQUEyQixDQUEzQjtBQUVIOztBQUdEOzs7Ozs7MkNBS21CLENBRWxCOztBQUdEOzs7Ozs7OENBS3NCLEssRUFBTztBQUN6QixnQkFBSSxNQUFNLE1BQU4sS0FBaUIsS0FBSyxFQUExQixFQUE4QjtBQUMxQixvQkFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYiw2QkFBUyxJQUFULENBQWMsU0FBZCxDQUF3QixHQUF4QixDQUE0QixhQUE1QjtBQUNBLHdCQUFLLEtBQUssUUFBTCxDQUFjLEdBQWQsQ0FBTCxFQUEwQjtBQUN0Qiw2QkFBSyxNQUFMLENBQVksSUFBWjtBQUNIO0FBQ0osaUJBTEQsTUFLTztBQUNILHlDQUFNLEtBQUssYUFBWDtBQUNIO0FBQ0o7QUFDSjs7Ozs7O2tCQUtVLFE7Ozs7Ozs7Ozs7Ozs7QUNsSWYsSUFBTSxTQUFTLFNBQWYsQyxDQUEwQjtBQUMxQixJQUFNLGlCQUFpQixpQkFBdkIsQyxDQUEwQzs7QUFFMUM7Ozs7Ozs7Ozs7SUFTTSxXOztBQUVGOzs7O0FBSUEsMkJBQWM7QUFBQTs7QUFFVjs7OztBQUlBLGFBQUssTUFBTCxJQUFlLEVBQWY7O0FBRUE7Ozs7QUFJQSxhQUFLLGNBQUwsSUFBdUIsRUFBdkI7QUFFSDs7QUFFRDs7Ozs7Ozs7OzsyQkFNRyxJLEVBQU0sTyxFQUF5QjtBQUFBLGdCQUFoQixPQUFnQix1RUFBTixJQUFNOzs7QUFFOUIsZ0JBQUksT0FBTyxJQUFQLEtBQWdCLFFBQXBCLEVBQThCOztBQUUxQjtBQUNBLG9CQUFLLENBQUMsS0FBSyxZQUFMLENBQWtCLElBQWxCLENBQU4sRUFBZ0M7QUFDNUIseUJBQUssTUFBTCxFQUFhLElBQWIsSUFBcUIsRUFBckI7QUFDSDs7QUFFRCxxQkFBSyxNQUFMLEVBQWEsSUFBYixFQUFtQixJQUFuQixDQUF5QixFQUFDLFNBQVMsT0FBVixFQUFtQixTQUFVLE9BQTdCLEVBQXpCO0FBRUgsYUFURCxNQVNPO0FBQUU7O0FBRUw7QUFDQSxxQkFBTSxJQUFNLEdBQVosSUFBbUIsSUFBbkIsRUFBeUI7QUFDckIsd0JBQUksS0FBSyxjQUFMLENBQW9CLEdBQXBCLENBQUosRUFBOEI7QUFDMUIsNEJBQUksUUFBUSxLQUFLLEdBQUwsQ0FBWjtBQUNBLDZCQUFLLEVBQUwsQ0FBUSxHQUFSLEVBQWEsS0FBYjtBQUNIO0FBQ0o7QUFFSjtBQUVKOztBQUVEOzs7Ozs7Ozs7NkJBTUssSSxFQUFNLE8sRUFBeUI7QUFBQTs7QUFBQSxnQkFBaEIsT0FBZ0IsdUVBQU4sSUFBTTs7O0FBRWhDO0FBQ0EsZ0JBQU0sY0FBYyxTQUFkLFdBQWMsR0FBa0I7QUFBQSxrREFBZCxTQUFjO0FBQWQsNkJBQWM7QUFBQTs7QUFDbEMsd0JBQVEsS0FBUixRQUFvQixTQUFwQjtBQUNBLHNCQUFLLEdBQUwsQ0FBUyxJQUFULEVBQWUsV0FBZjtBQUNILGFBSEQ7O0FBS0E7QUFDQSxpQkFBSyxFQUFMLENBQVEsSUFBUixFQUFjLFdBQWQsRUFBMkIsT0FBM0I7QUFDSDs7QUFFRDs7Ozs7Ozs7NEJBS0ksSSxFQUFNLE8sRUFBUzs7QUFFZixnQkFBSyxLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FBTCxFQUErQjs7QUFFM0Isb0JBQUksT0FBTyxPQUFQLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ2hDLHlCQUFLLE1BQUwsRUFBYSxJQUFiLElBQXFCLEVBQXJCO0FBQ0gsaUJBRkQsTUFFTztBQUNILHdCQUFNLG9CQUFvQixLQUFLLE1BQUwsRUFBYSxJQUFiLEVBQW1CLElBQW5CLENBQXlCLFVBQUMsV0FBRDtBQUFBLCtCQUFpQixZQUFZLE9BQVosS0FBd0IsT0FBekM7QUFBQSxxQkFBekIsQ0FBMUI7QUFDQSx3QkFBSSxzQkFBc0IsQ0FBQyxDQUEzQixFQUE4QjtBQUMxQiw2QkFBSyxNQUFMLEVBQWEsSUFBYixFQUFtQixNQUFuQixDQUEyQixLQUFLLE1BQUwsRUFBYSxJQUFiLEVBQW1CLFdBQW5CLENBQStCLGlCQUEvQixDQUEzQixFQUErRSxDQUEvRTtBQUNIO0FBQ0o7QUFFSjtBQUVKOztBQUVEOzs7Ozs7Ozs7Ozs7aUNBU1MsTSxFQUFRLEksRUFBTSxPLEVBQVM7O0FBRTVCLGdCQUFLLEVBQUUsa0JBQWtCLFdBQXBCLENBQUwsRUFBd0M7QUFDcEMsc0JBQU0sSUFBSSxLQUFKLENBQVUseUVBQVYsQ0FBTjtBQUNIOztBQUVEO0FBQ0EsZ0JBQUksa0JBQWtCLEtBQUssY0FBTCxFQUFxQixJQUFyQixDQUEyQixVQUFDLFVBQUQ7QUFBQSx1QkFBZ0IsV0FBVyxNQUFYLEtBQXNCLE1BQXRDO0FBQUEsYUFBM0IsQ0FBdEI7O0FBRUE7QUFDQSxnQkFBSyxDQUFDLGVBQU4sRUFBd0I7QUFDcEIsa0NBQWtCLEVBQUMsUUFBUyxNQUFWLEVBQWtCLFdBQVksRUFBOUIsRUFBbEI7QUFDQSxxQkFBSyxjQUFMLEVBQXFCLElBQXJCLENBQTJCLGVBQTNCO0FBQ0g7O0FBRUQ7QUFDQSw0QkFBZ0IsU0FBaEIsQ0FBMEIsSUFBMUIsSUFBa0MsZ0JBQWdCLFNBQWhCLENBQTBCLElBQTFCLEtBQW1DLEVBQXJFOztBQUVBO0FBQ0EsNEJBQWdCLFNBQWhCLENBQTBCLElBQTFCLEVBQWdDLElBQWhDLENBQXNDLE9BQXRDOztBQUVBO0FBQ0EsbUJBQU8sRUFBUCxDQUFVLElBQVYsRUFBZ0IsT0FBaEIsRUFBeUIsSUFBekI7QUFFSDs7QUFFRDs7Ozs7Ozs7c0NBS2MsTSxFQUFRLEksRUFBTTs7QUFFeEI7QUFDQTtBQUNBLGdCQUFNLGtCQUFrQixLQUFLLGNBQUwsRUFBcUIsSUFBckIsQ0FBMkIsVUFBQyxVQUFEO0FBQUEsdUJBQWdCLGVBQWUsTUFBL0I7QUFBQSxhQUEzQixDQUF4Qjs7QUFFQTtBQUNBLGdCQUFLLGVBQUwsRUFBdUI7O0FBRW5CLG9CQUFJLElBQUosRUFBVTs7QUFFTixvQ0FBZ0IsU0FBaEIsQ0FBMEIsSUFBMUIsRUFBZ0MsT0FBaEMsQ0FBeUMsVUFBVSxPQUFWLEVBQW1CO0FBQ3hELCtCQUFPLEdBQVAsQ0FBVyxJQUFYLEVBQWlCLE9BQWpCO0FBQ0gscUJBRkQ7QUFJSCxpQkFORCxNQU1PO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxnQ0FFTSxRQUZOOzs7QUFJQyw0Q0FBZ0IsU0FBaEIsQ0FBMEIsUUFBMUIsRUFBb0MsT0FBcEMsQ0FBNkMsVUFBVSxPQUFWLEVBQW1CO0FBQzVELHVDQUFPLEdBQVAsQ0FBVyxRQUFYLEVBQXFCLE9BQXJCO0FBQ0gsNkJBRkQ7QUFKRDs7QUFFSCw2Q0FBcUIsT0FBTyxJQUFQLENBQVksZ0JBQWdCLFNBQTVCLENBQXJCLDhIQUE4RDtBQUFBO0FBTTdEO0FBUkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVVOO0FBRUo7QUFFSjs7QUFFRDs7Ozs7Ozs7cUNBS2EsSSxFQUFNO0FBQ2YsbUJBQU8sT0FBTyxLQUFLLE1BQUwsRUFBYSxJQUFiLENBQVAsS0FBOEIsV0FBckM7QUFDSDs7QUFFRDs7Ozs7Ozs7Z0NBS1EsSSxFQUFzQjs7QUFFMUI7QUFDQSxnQkFBSyxLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FBTCxFQUErQjs7QUFFM0I7QUFDQTtBQUNBLG9CQUFNLFdBQVcsS0FBSyxNQUFMLEVBQWEsSUFBYixDQUFqQjs7QUFKMkIsbURBSGxCLFdBR2tCO0FBSGxCLCtCQUdrQjtBQUFBOztBQUszQixxQkFBTSxJQUFNLFFBQVosSUFBd0IsUUFBeEIsRUFBbUM7O0FBRS9CLHdCQUFLLFNBQVMsY0FBVCxDQUF3QixRQUF4QixDQUFMLEVBQXlDO0FBQ3JDLDRCQUFJLFFBQVEsS0FBSyxNQUFMLEVBQWEsSUFBYixFQUFtQixRQUFuQixDQUFaOztBQUVBLDhCQUFNLE9BQU4sQ0FBYyxLQUFkLENBQW9CLE1BQU0sT0FBMUIsRUFBbUMsV0FBbkM7QUFDSDtBQUVKO0FBRUo7QUFFSjs7Ozs7O2tCQU1VLFc7Ozs7Ozs7Ozs7O0FDdk5mOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBSUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFmQTs7O0FBYUE7OztBQUlBOzs7Ozs7SUFNTSxROzs7QUFFRjs7Ozs7Ozs7O0FBU0Esc0JBQVksRUFBWixFQUE4QjtBQUFBLFlBQWQsT0FBYyx1RUFBSixFQUFJOztBQUFBOztBQUkxQjtBQUowQjs7QUFLMUIsWUFBSyxDQUFDLEVBQU4sRUFBVztBQUNQLGtCQUFNLElBQUksS0FBSixDQUFVLDhDQUFWLENBQU47QUFDSCxTQUZELE1BRU8sSUFBSyxDQUFDLHlCQUFVLEVBQVYsQ0FBTixFQUFzQjtBQUN6QixrQkFBTSxJQUFJLEtBQUosQ0FBVSxpREFBVixDQUFOO0FBQ0g7O0FBRUQ7QUFDQSxjQUFLLEVBQUwsR0FBVSxFQUFWO0FBQ0EsY0FBSyxPQUFMLEdBQWUsT0FBZjs7QUFFQTtBQUNBLFlBQUksTUFBSyxPQUFMLENBQWEsV0FBakIsRUFBOEI7QUFBRTtBQUM1QixrQkFBSyxXQUFMLEdBQW1CLHNCQUFRLHdCQUFjLFdBQXRCLEVBQW1DLFVBQUMsRUFBRDtBQUFBLHVCQUFRLHdCQUFTLE1BQUssT0FBTCxDQUFhLFdBQXRCLEVBQW1DLEdBQUcsSUFBdEMsQ0FBUjtBQUFBLGFBQW5DLENBQW5CO0FBRUgsU0FIRCxNQUdPO0FBQUU7QUFDTCxrQkFBSyxXQUFMLEdBQW1CLHFCQUFPLHdCQUFjLFdBQXJCLENBQW5CO0FBQ0g7O0FBRUQ7QUFDQSxZQUFLLENBQUMsU0FBUyxTQUFULENBQW1CLE1BQXpCLEVBQWtDO0FBQzlCLG9DQUFjLEVBQWQsQ0FBaUIsWUFBakIsRUFBK0IsaUJBQS9CO0FBQ0g7O0FBRUQ7QUFDQSxpQkFBUyxTQUFULENBQW1CLElBQW5COztBQUVBO0FBQ0EsY0FBSyxpQkFBTCxHQUF5Qix3QkFBUyxNQUFLLFdBQWQsRUFBMkIsVUFBQyxFQUFEO0FBQUEsbUJBQVEsd0JBQWMsS0FBZCxJQUF1QixHQUFHLEtBQWxDO0FBQUEsU0FBM0IsQ0FBekI7O0FBaEMwQjtBQWtDN0I7O0FBRUQ7Ozs7Ozs7NENBR29CLENBRW5COztBQUVEOzs7Ozs7Ozs7Ozs7b0NBU1ksSSxFQUFNLFEsRUFBMkI7QUFBQTs7QUFBQSxnQkFBakIsUUFBaUIsdUVBQU4sSUFBTTs7O0FBRXpDO0FBQ0EsaUJBQUssVUFBTCxHQUFrQixLQUFLLFVBQUwsSUFBbUIsRUFBckM7O0FBRUE7QUFDQSxpQkFBSyxVQUFMLENBQWdCLElBQWhCLElBQXdCLEtBQUssVUFBTCxDQUFnQixJQUFoQixLQUF5QixFQUFqRDs7QUFFQTtBQUNBLGdCQUFLLFlBQVksRUFBSSx3QkFBUyxRQUFULEtBQXNCLGFBQWEsS0FBcEMsSUFBOEMseUJBQVUsUUFBVixDQUFqRCxDQUFqQixFQUF5RjtBQUNyRixzQkFBTSxJQUFJLEtBQUosQ0FBVSx3RkFBVixDQUFOO0FBQ0g7O0FBRUQ7QUFDQSxnQkFBSyxDQUFDLDBCQUFXLFFBQVgsQ0FBTixFQUE2QjtBQUN6QixzQkFBTSxJQUFJLEtBQUosQ0FBVSxzREFBVixDQUFOO0FBQ0g7O0FBRUQ7QUFDQSxnQkFBSSxTQUFTLHlCQUFVLFFBQVYsSUFBc0IsUUFBdEIsR0FBaUMsS0FBSyxFQUFuRDs7QUFFQTtBQUNBLGdCQUFJLG1CQUFtQixTQUFuQixnQkFBbUIsQ0FBQyxLQUFELEVBQVc7O0FBRTlCO0FBQ0Esb0JBQUksYUFBYSxLQUFqQjs7QUFFQTtBQUNBLG9CQUFJLGVBQUo7O0FBRUEsb0JBQUssQ0FBQyxRQUFOLEVBQWlCO0FBQ2IsaUNBQWEsSUFBYixDQURhLENBQ007QUFDdEIsaUJBRkQsTUFFTzs7QUFFSCw2QkFBUyxNQUFNLE1BQWY7O0FBRUEsd0JBQUksd0JBQVMsUUFBVCxDQUFKLEVBQXdCOztBQUVwQiwrQkFBTyxXQUFXLE9BQUssRUFBdkIsRUFBMkI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLGdDQUFJLDZCQUE2QixNQUFqQyxFQUF5QztBQUNyQyx5Q0FBUyxPQUFPLHVCQUFoQjtBQUNIOztBQUVEO0FBQ0EsZ0NBQUssYUFBYSxNQUFiLElBQXVCLE9BQU8sT0FBUCxDQUFlLFFBQWYsQ0FBNUIsRUFBc0Q7QUFDbEQsNkNBQWEsSUFBYjtBQUNBO0FBQ0gsNkJBSEQsTUFHTztBQUNILHlDQUFTLE9BQU8sVUFBaEI7QUFDSDtBQUNKO0FBRUoscUJBcEJELE1Bb0JPLElBQUkseUJBQVUsUUFBVixDQUFKLEVBQXlCO0FBQUU7QUFDOUIsaUNBQVMsUUFBVDtBQUNBLHFDQUFhLElBQWI7QUFDSDtBQUNKOztBQUVELG9CQUFJLFVBQUosRUFBZ0I7QUFDWjtBQUNBLDBCQUFNLGNBQU4sR0FBdUIsTUFBdkI7QUFDQSw2QkFBUyxLQUFULFNBQXFCLENBQUMsS0FBRCxDQUFyQjtBQUNIO0FBRUosYUE5Q0Q7O0FBZ0RBO0FBQ0EsbUJBQU8sZ0JBQVAsQ0FBd0IsSUFBeEIsRUFBOEIsZ0JBQTlCOztBQUVBO0FBQ0EsaUJBQUssVUFBTCxDQUFnQixJQUFoQixFQUFzQixJQUF0QixDQUEyQixFQUFDLFFBQVMsTUFBVixFQUFrQixVQUFVLGdCQUE1QixFQUEzQjtBQUNIOztBQUVEOzs7Ozs7Ozt1Q0FLZSxNLEVBQXNCO0FBQUE7O0FBQUEsZ0JBQWQsSUFBYyx1RUFBUCxLQUFPOzs7QUFFakMsZ0JBQUksS0FBSyxVQUFULEVBQXFCOztBQUVqQixvQkFBSSxlQUFKO0FBQ0Esb0JBQUksMkJBQVksSUFBWixLQUFxQixTQUFTLEtBQWxDLEVBQXlDO0FBQ3JDLDZCQUFTLEtBQUssVUFBZCxDQURxQyxDQUNYO0FBQzdCLGlCQUZELE1BRU87QUFDSCw2QkFBUyxFQUFUO0FBQ0EsMkJBQU8sSUFBUCxJQUFlLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFmO0FBQ0g7O0FBRUQ7QUFDQSxvQ0FBSyxNQUFMLEVBQWEsVUFBQyxjQUFELEVBQWlCLFFBQWpCLEVBQThCOztBQUV2QztBQUNBLHdCQUFJLFVBQVUsRUFBZDs7QUFFQTtBQUNBLHdDQUFLLGNBQUwsRUFBcUIsVUFBQyxXQUFELEVBQWMsQ0FBZCxFQUFvQjs7QUFFckMsNEJBQUssQ0FBQyxNQUFELElBQVcsWUFBWSxNQUFaLElBQXNCLE1BQXRDLEVBQThDO0FBQzFDLHdDQUFZLE1BQVosQ0FBbUIsbUJBQW5CLENBQXVDLFFBQXZDLEVBQWlELFlBQVksUUFBN0Q7QUFDQSxvQ0FBUSxJQUFSLENBQWMsQ0FBZDtBQUNIO0FBRUoscUJBUEQ7O0FBU0E7QUFDQSw0QkFBUSxPQUFSLENBQWlCLFVBQUMsQ0FBRCxFQUFPO0FBQ3BCLHVDQUFlLE1BQWYsQ0FBc0IsQ0FBdEI7QUFDSCxxQkFGRDs7QUFJQTtBQUNBLHdCQUFLLENBQUMsY0FBRCxJQUFtQixlQUFlLE1BQWYsSUFBeUIsQ0FBakQsRUFBb0Q7QUFDaEQsK0JBQU8sT0FBSyxVQUFMLENBQWdCLFFBQWhCLENBQVA7QUFDSDtBQUVKLGlCQXpCRDtBQTBCSDtBQUVKOztBQUVEOzs7Ozs7O2lDQUlTO0FBQ0wsaUJBQUssY0FBTDtBQUNBO0FBQ0EsZ0JBQUksS0FBSyxFQUFMLENBQVEsVUFBWixFQUF3QjtBQUNwQixxQkFBSyxFQUFMLENBQVEsVUFBUixDQUFtQixXQUFuQixDQUErQixLQUFLLEVBQXBDO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7OztrQ0FJVTtBQUNOLGlCQUFLLGFBQUw7QUFDQSxpQkFBSyxNQUFMOztBQUVBO0FBQ0EscUJBQVMsU0FBVCxDQUFtQixNQUFuQixDQUEyQixTQUFTLFNBQVQsQ0FBbUIsT0FBbkIsQ0FBMkIsSUFBM0IsQ0FBM0IsRUFBNkQsQ0FBN0Q7QUFFSDs7QUFFRDs7Ozs7O2lDQUdTLENBRVI7O0FBRUQ7Ozs7Ozs7Ozs7O2lDQVFTLFUsRUFBWTtBQUNqQixtQkFBTyx3QkFBYyxRQUFkLENBQXdCLFVBQXhCLENBQVA7QUFDSDs7Ozs7O0FBSUw7Ozs7Ozs7O0FBTUEsU0FBUyxTQUFULEdBQXFCLEVBQXJCOztBQUVBOzs7Ozs7QUFNQSxTQUFTLGlCQUFULENBQTJCLEtBQTNCLEVBQWtDO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQzlCLDZCQUFxQixTQUFTLFNBQTlCLDhIQUF5QztBQUFBLGdCQUFoQyxRQUFnQzs7QUFDckM7QUFDQSxnQkFBSSxpQkFBaUIsd0JBQVMsU0FBUyxXQUFsQixFQUErQixVQUFDLEVBQUQ7QUFBQSx1QkFBUSxNQUFNLFVBQU4sQ0FBaUIsS0FBakIsSUFBMEIsR0FBRyxLQUFyQztBQUFBLGFBQS9CLENBQXJCOztBQUVBO0FBQ0EsZ0JBQUssQ0FBQyx1QkFBUSxjQUFSLEVBQXdCLFNBQVMsaUJBQWpDLENBQU4sRUFBNEQ7QUFDeEQseUJBQVMsaUJBQVQsR0FBNkIsY0FBN0I7QUFDQSx5QkFBUyxpQkFBVCxDQUE0QixjQUE1QixFQUE0QyxNQUFNLFFBQWxEO0FBQ0g7QUFDSjtBQVY2QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBV2pDOztrQkFHYyxROzs7Ozs7Ozs7Ozs7O0FDNVJmOzs7O0FBR0E7Ozs7Ozs7Ozs7K2VBSkE7OztBQUdBOzs7QUFJQTs7OztJQUlNLGE7OztBQUVGOzs7OztBQUtBLDJCQUFZLEVBQVosRUFBZ0IsT0FBaEIsRUFBeUI7QUFBQTs7QUFJckI7Ozs7O0FBSnFCLGtJQUVmLEVBRmUsRUFFWCxPQUZXOztBQVNyQixjQUFLLFNBQUwsR0FBaUIsRUFBakI7O0FBVHFCO0FBV3hCOztBQUVEOzs7O0FBTUE7Ozs7Ozs7a0NBR1U7QUFBQTs7QUFFTjtBQUNBLGlCQUFLLFNBQUwsQ0FBZSxPQUFmLENBQXdCLGdCQUFRO0FBQzVCLHFCQUFLLE9BQUw7QUFDQSx1QkFBSyxrQkFBTCxDQUF3QixJQUF4QjtBQUNILGFBSEQ7O0FBS0E7QUFDQTtBQUVIOztBQUVEOzs7Ozs7aUNBR1M7QUFDTCxpQkFBSyxTQUFMLENBQWUsT0FBZixDQUF3QixVQUFDLElBQUQ7QUFBQSx1QkFBVSxLQUFLLE1BQUwsRUFBVjtBQUFBLGFBQXhCO0FBQ0E7QUFFSDs7QUFHRDs7OztBQU1BOzs7Ozs7Ozt5Q0FLaUIsSSxFQUFPOztBQUVwQixnQkFBSyxFQUFFLGtDQUFGLENBQUwsRUFBbUM7QUFDL0Isc0JBQU0sSUFBSSxLQUFKLENBQVUsbUZBQVYsQ0FBTjtBQUNIOztBQUVEO0FBQ0EsZ0JBQUssQ0FBQyx3QkFBUyxLQUFLLFNBQWQsRUFBeUIsSUFBekIsQ0FBTixFQUF1QztBQUNuQyxxQkFBSyxTQUFMLENBQWUsSUFBZixDQUFvQixJQUFwQjtBQUNIOztBQUVELGdCQUFLLENBQUMsS0FBSyxFQUFMLENBQVEsUUFBUixDQUFrQixLQUFLLEVBQXZCLENBQU4sRUFBb0M7QUFDaEMsd0JBQVEsSUFBUixDQUFhLGdFQUFiO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7MkNBS21CLEksRUFBTztBQUN0QixnQkFBSSxZQUFZLEtBQUssU0FBTCxDQUFlLE9BQWYsQ0FBd0IsSUFBeEIsQ0FBaEI7O0FBRUEsZ0JBQUksWUFBWSxDQUFDLENBQWpCLEVBQW9CO0FBQ2hCLHFCQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXNCLFNBQXRCLEVBQWdDLENBQWhDO0FBQ0g7QUFDSjs7Ozs7O2tCQUlVLGE7Ozs7Ozs7Ozs7Ozs7QUN4R2Y7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFGQTs7O0FBSUE7O0FBRUE7Ozs7O0lBS00sYzs7O0FBRUYsNEJBQVksRUFBWixFQUFnQixPQUFoQixFQUF5QjtBQUFBOztBQUlyQjs7OztBQUpxQixvSUFFZixFQUZlLEVBRVgsT0FGVzs7QUFRckIsY0FBSyxjQUFMLEdBQXNCLE1BQUssRUFBTCxDQUFRLFVBQVIsQ0FBbUIsSUFBbkIsQ0FBdEI7O0FBRUE7QUFDQSxjQUFLLGNBQUwsQ0FBb0IsS0FBcEIsQ0FBMkIsQ0FBM0IsRUFBOEIsQ0FBOUI7O0FBRUE7Ozs7QUFJQSxjQUFLLGFBQUwsR0FBcUIsT0FBTyxRQUFRLEdBQXBDOztBQUVBOzs7O0FBSUEsY0FBSyxTQUFMLEdBQWlCLFFBQVEsU0FBekI7O0FBRUE7Ozs7QUFJQSxjQUFLLElBQUwsR0FBYSxRQUFRLElBQVIsS0FBaUIsS0FBbEIsR0FBMkIsQ0FBQyxDQUE1QixHQUFpQyxRQUFRLElBQVIsSUFBZ0IsQ0FBN0Q7O0FBRUEsY0FBSyxLQUFMLEdBQWEsTUFBSyxFQUFMLENBQVEsS0FBckI7QUFDQSxjQUFLLE1BQUwsR0FBYyxNQUFLLEVBQUwsQ0FBUSxNQUF0Qjs7QUFFQSxjQUFLLGFBQUwsR0FBcUIsQ0FBckI7QUFDQSxjQUFLLFNBQUwsR0FBaUIsS0FBakI7O0FBRUEsY0FBSyxXQUFMLEdBQW1CLDBCQUFpQixRQUFRLEdBQXpCLENBQW5CO0FBQ0EsY0FBSyxXQUFMLENBQWlCLE9BQWpCLENBQXlCLElBQXpCLENBQStCLFVBQUMsR0FBRCxFQUFTOztBQUVwQyxrQkFBSyxNQUFMLEdBQWMsSUFBSSxJQUFsQjs7QUFFQSxrQkFBSyxVQUFMLEdBQWtCLEtBQUssS0FBTCxDQUFZLE1BQUssTUFBTCxDQUFZLEtBQVosR0FBb0IsTUFBSyxLQUFyQyxDQUFsQjtBQUNBLGtCQUFLLFVBQUwsR0FBa0IsS0FBSyxLQUFMLENBQVksTUFBSyxNQUFMLENBQVksTUFBWixHQUFxQixNQUFLLE1BQXRDLENBQWxCOztBQUVBLGdCQUFJLFFBQVEsUUFBUixJQUFvQixNQUFLLGNBQTdCLEVBQTZDO0FBQ3pDLHNCQUFLLElBQUw7QUFDSDtBQUNKLFNBVkQ7O0FBdENxQjtBQWtEeEI7O0FBRUQ7Ozs7Ozs7O0FBZUE7Ozs7K0JBTU87QUFBQTs7QUFDSCxnQkFBSyxLQUFLLFdBQUwsQ0FBaUIsTUFBakIsS0FBNEIsVUFBakMsRUFBOEM7QUFDMUMscUJBQUssY0FBTCxHQUFzQixJQUF0QjtBQUNBO0FBQ0g7O0FBRUQsaUJBQUssU0FBTCxHQUFpQixJQUFqQjs7QUFFQSxnQkFBSyxDQUFDLEtBQUssV0FBWCxFQUF5QjtBQUNyQixxQkFBSyxXQUFMLEdBQW1CLHNCQUF1QixZQUFNO0FBQzVDLHdCQUFLLE1BQU0sT0FBSyxVQUFYLEtBQTBCLEtBQUssR0FBTCxLQUFhLE9BQUssVUFBbEIsR0FBK0IsT0FBSyxhQUFuRSxFQUFrRjtBQUM5RSwrQkFBSyxPQUFMO0FBQ0g7O0FBRUQsMkJBQUssV0FBTCxHQUFtQixJQUFuQixDQUw0QyxDQUtuQjtBQUN6Qix3QkFBSSxPQUFLLFNBQVQsRUFBb0IsT0FBSyxJQUFMO0FBQ3ZCLGlCQVBrQixDQUFuQjtBQVFIO0FBQ0o7OztnQ0FFTzs7QUFFSixpQkFBSyxTQUFMLEdBQWlCLEtBQWpCOztBQUVBLGdCQUFJLEtBQUssV0FBVCxFQUFzQjtBQUNsQix1QkFBTyxvQkFBUCxDQUE2QixLQUFLLFdBQWxDO0FBQ0EscUJBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLHFCQUFLLGNBQUwsR0FBc0IsS0FBdEIsQ0FIa0IsQ0FHVztBQUNoQztBQUNKOzs7a0NBRVM7QUFDTixpQkFBSyxLQUFMO0FBQ0E7QUFDSDs7QUFHRDs7Ozs7O2tDQU1VO0FBQ04sZ0JBQUksUUFBUSxLQUFLLGFBQUwsR0FBcUIsQ0FBakM7O0FBRUEsZ0JBQUksU0FBUyxLQUFLLFNBQUwsR0FBaUIsQ0FBOUIsRUFBaUM7O0FBRTdCLG9CQUFJLEtBQUssSUFBTCxHQUFZLENBQWhCLEVBQW1CO0FBQ2YseUJBQUssS0FBTDtBQUNBLHlCQUFLLGFBQUwsR0FBcUIsQ0FBckI7QUFDQTtBQUNILGlCQUpELE1BSU87QUFDSCw0QkFBUSxLQUFLLElBQWI7QUFDSDtBQUVKOztBQUVELGlCQUFLLGNBQUwsQ0FBb0IsU0FBcEIsQ0FBOEIsQ0FBOUIsRUFBaUMsQ0FBakMsRUFBb0MsS0FBSyxLQUF6QyxFQUFnRCxLQUFLLE1BQXJEOztBQUVBLGdCQUFJLElBQUksS0FBSyxLQUFMLENBQVksUUFBUSxLQUFLLFVBQXpCLENBQVI7QUFDQSxnQkFBSSxJQUFJLEtBQUssS0FBTCxDQUFZLFFBQVEsS0FBSyxVQUF6QixDQUFSOztBQUVBLGlCQUFLLGNBQUwsQ0FBb0IsU0FBcEIsQ0FDSSxLQUFLLE1BRFQsRUFFSSxJQUFJLEtBQUssS0FGYixFQUdJLElBQUksS0FBSyxNQUhiLEVBSUksS0FBSyxLQUpULEVBS0ksS0FBSyxNQUxULEVBTUksQ0FOSixFQU1NLENBTk4sRUFNUyxLQUFLLEtBTmQsRUFNcUIsS0FBSyxNQU4xQjs7QUFTQSxpQkFBSyxhQUFMLEdBQXFCLEtBQXJCO0FBQ0EsaUJBQUssVUFBTCxHQUFrQixLQUFLLEdBQUwsRUFBbEI7QUFDSDs7QUFHRDs7Ozs7OzZDQUtxQixDQUVwQjs7OzRCQW5HbUI7QUFDaEIsbUJBQU8sS0FBSyxhQUFaO0FBQ0g7OzswQkFFZ0IsSyxFQUFPO0FBQ3BCLGlCQUFLLGFBQUwsR0FBcUIsUUFBUSxDQUE3QjtBQUNBLGlCQUFLLE9BQUw7QUFDSDs7Ozs7O2tCQWlHVSxjOzs7Ozs7OztBQy9LZjs7OztBQUlBLElBQU0sUUFBUSxTQUFSLEtBQVEsQ0FBVSxFQUFWLEVBQWM7QUFDeEIsU0FBUSxHQUFHLFVBQVg7QUFBd0IsT0FBRyxXQUFILENBQWUsR0FBRyxVQUFsQjtBQUF4QjtBQUNILENBRkQ7O2tCQUllLEs7Ozs7Ozs7O0FDUmY7Ozs7O0FBS0EsU0FBUyxlQUFULENBQXlCLEVBQXpCLEVBQTZCOztBQUV6QjtBQUNBLFFBQUksZUFBZSxTQUFTLGVBQTVCOztBQUVBLFFBQUksU0FBUyxFQUFiO0FBQ0EsV0FBTyxPQUFPLFVBQVAsSUFBcUIsV0FBVyxTQUFTLGVBQWhELEVBQWtFO0FBQzlELGlCQUFTLE9BQU8sVUFBaEI7O0FBRUEsWUFBSyxnQkFBZ0IsSUFBaEIsQ0FBcUIsT0FBTyxnQkFBUCxDQUF5QixNQUF6QixFQUFrQyxTQUF2RCxDQUFMLEVBQXlFO0FBQ3JFLDJCQUFlLE1BQWY7QUFDQTtBQUNIO0FBQ0o7O0FBRUQsV0FBTyxZQUFQO0FBQ0g7O2tCQUVjLGU7Ozs7Ozs7OztBQ3ZCZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFHQTs7Ozs7O0FBTUEsSUFBTSxRQUFRLGVBQVUsY0FBVixFQUEwQixVQUExQixFQUFzQzs7QUFFaEQsUUFBSSxRQUFRLENBQUMsQ0FBYjs7QUFFQTtBQUNBLFFBQUssQ0FBQyxVQUFELElBQWUsQ0FBQyx5QkFBVSxVQUFWLENBQXJCLEVBQTZDO0FBQ3pDLHFCQUFhLE1BQU0sSUFBTixDQUFXLGVBQWUsVUFBZixDQUEwQixRQUFyQyxDQUFiO0FBQ0g7O0FBRUQ7QUFDQSxRQUFJLHVCQUFRLFVBQVIsQ0FBSixFQUF5Qjs7QUFFckI7QUFDQSxZQUFJLHlCQUFVLGNBQVYsQ0FBSixFQUErQjtBQUMzQixvQkFBUSx1QkFBUSxVQUFSLEVBQW9CLGNBQXBCLENBQVI7QUFDQTtBQUNILFNBSEQsTUFHTyxJQUFJLHdCQUFTLGNBQVQsQ0FBSixFQUE4QjtBQUNqQyxvQkFBUSx5QkFBVSxVQUFWLEVBQXNCLFVBQUMsSUFBRDtBQUFBLHVCQUFVLEtBQUssT0FBTCxDQUFhLGNBQWIsQ0FBVjtBQUFBLGFBQXRCLENBQVI7QUFDSCxTQUZNLE1BRUE7QUFDSCxrQkFBTSxJQUFJLEtBQUosQ0FBVSxnREFBVixDQUFOO0FBQ0g7QUFDSixLQVhELE1BV087QUFDSCxjQUFNLElBQUksS0FBSixDQUFVLGtEQUFWLENBQU47QUFDSDs7QUFFRCxXQUFPLEtBQVA7QUFFSCxDQTNCRDs7a0JBNkJlLEs7Ozs7Ozs7O0FDMUNmOzs7Ozs7QUFNQSxJQUFNLGdCQUFnQixTQUFoQixhQUFnQixDQUFVLEVBQVYsRUFBMkI7O0FBRTdDO0FBQ0EsUUFBSSxVQUFVLEdBQUcsU0FBakI7O0FBSDZDLHNDQUFWLFFBQVU7QUFBVixnQkFBVTtBQUFBOztBQUs3QyxhQUFTLE9BQVQsQ0FBa0IsVUFBQyxPQUFELEVBQWE7O0FBRTNCO0FBQ0EsWUFBSSxlQUFlLElBQUksTUFBSixDQUFZLFFBQVEsT0FBUixDQUFnQixHQUFoQixFQUFxQixnQkFBckIsSUFBeUMsTUFBckQsQ0FBbkI7O0FBRUE7QUFDQSxrQkFBVSxRQUFRLE9BQVIsQ0FBaUIsWUFBakIsRUFBK0IsRUFBL0IsQ0FBVjtBQUVILEtBUkQ7O0FBVUE7QUFDQSxPQUFHLFNBQUgsR0FBZSxPQUFmO0FBRUgsQ0FsQkQ7O2tCQW9CZSxhOzs7Ozs7OztBQzFCZjs7Ozs7O0FBTUEsSUFBTSxrQkFBa0IsU0FBbEIsZUFBa0IsQ0FBVSxZQUFWLEVBQXdCO0FBQzVDO0FBQ0EsUUFBSSxrQkFBa0IsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQXRCO0FBQ0EsUUFBSSxVQUFKOztBQUVBO0FBQ0Esb0JBQWdCLFNBQWhCLEdBQTRCLFlBQTVCOztBQUVBO0FBQ0EsUUFBSyxnQkFBZ0IsUUFBaEIsQ0FBeUIsTUFBekIsR0FBa0MsQ0FBdkMsRUFBMkM7QUFBRTtBQUN6QyxZQUFJLFVBQVUsU0FBUyxzQkFBVCxFQUFkO0FBQ0EsZUFBTyxJQUFJLGdCQUFnQixVQUEzQixFQUF3QztBQUNwQyxvQkFBUSxXQUFSLENBQW9CLENBQXBCO0FBQ0g7O0FBRUQsZUFBTyxPQUFQO0FBRUgsS0FSRCxNQVFPO0FBQUU7QUFDTCxlQUFPLGdCQUFnQixpQkFBdkI7QUFDSDtBQUVKLENBckJEOztrQkF1QmUsZTs7Ozs7Ozs7O0FDN0JmOzs7Ozs7QUFFQSxJQUFNLGtCQUFrQixTQUFsQixlQUFrQixDQUFTLEVBQVQsRUFBYTs7QUFFakMsUUFBSSxTQUFTLEdBQUcscUJBQUgsRUFBYjs7QUFFQSxRQUFNLFdBQVcsK0JBQWlCLEVBQWpCLENBQWpCOztBQUVBLFdBQU87QUFDSCxhQUFNLE9BQU8sR0FBUCxHQUFhLFNBQVMsU0FEekI7O0FBR0gsY0FBTSxPQUFPLElBQVAsR0FBYyxTQUFTLFNBSDFCOztBQUtILGVBQVUsT0FBTyxLQUxkO0FBTUgsZ0JBQVUsT0FBTyxNQU5kOztBQVFILGVBQVUsT0FBTyxLQUFQLEdBQWUsU0FBUyxVQVIvQjtBQVNILGdCQUFVLE9BQU8sTUFBUCxHQUFnQixTQUFTO0FBVGhDLEtBQVA7QUFZSCxDQWxCRDs7a0JBb0JlLGU7Ozs7Ozs7Ozs7Ozs7SUNuQlQsSztBQUVGLG1CQUFZLENBQVosRUFBZSxDQUFmLEVBQStDO0FBQUEsWUFBN0IsS0FBNkIsdUVBQXJCLEdBQXFCO0FBQUEsWUFBaEIsUUFBZ0IsdUVBQUwsR0FBSzs7QUFBQTs7QUFDM0MsYUFBSyxDQUFMLEdBQVMsQ0FBVDtBQUNBLGFBQUssQ0FBTCxHQUFTLENBQVQ7O0FBRUE7QUFDQSxhQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBRUg7Ozs7a0NBRVM7O0FBRU47QUFDQSxnQkFBSyxNQUFNLEtBQUssS0FBWCxLQUFxQixNQUFNLEtBQUssUUFBWCxDQUExQixFQUFpRDtBQUM3QyxxQkFBSyxRQUFMLEdBQWdCLEtBQUssSUFBTCxDQUFZLEtBQUssR0FBTCxDQUFTLEtBQUssQ0FBZCxFQUFpQixDQUFqQixJQUFzQixLQUFLLEdBQUwsQ0FBUyxLQUFLLENBQWQsRUFBaUIsQ0FBakIsQ0FBbEMsQ0FBaEI7QUFDQSxxQkFBSyxLQUFMLEdBQWEsS0FBSyxLQUFMLENBQVksS0FBSyxDQUFqQixFQUFvQixLQUFLLENBQXpCLENBQWI7QUFDSDs7QUFFRCxtQkFBTztBQUNILHVCQUFRLEtBQUssS0FEVjtBQUVILDBCQUFXLEtBQUs7QUFGYixhQUFQO0FBSUg7Ozs7OztBQUtMOzs7Ozs7O0FBS0EsTUFBTSxRQUFOLEdBQWlCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDN0IsUUFBSSxJQUFLLEVBQUUsQ0FBRixHQUFNLEVBQUUsQ0FBakI7QUFDQSxRQUFJLElBQUssRUFBRSxDQUFGLEdBQU0sRUFBRSxDQUFqQjtBQUNBLFdBQU8sS0FBSyxJQUFMLENBQVksSUFBRSxDQUFILEdBQVMsSUFBRSxDQUF0QixDQUFQO0FBQ0gsQ0FKRDs7a0JBTWUsSzs7Ozs7Ozs7Ozs7QUMzQ2Y7Ozs7Ozs7Ozs7OztBQUVBOzs7O0lBSU0sUTs7O0FBRUY7Ozs7QUFJQSxzQkFBc0M7QUFBQSxRQUExQixNQUEwQix1RUFBakIsT0FBTyxRQUFVOztBQUFBOztBQUdsQzs7OztBQUhrQzs7QUFPbEMsVUFBSyxNQUFMLEdBQWMsTUFBZDs7QUFFQTs7Ozs7QUFLQSxVQUFLLGVBQUwsR0FBdUI7QUFDbkIsYUFBVSxNQUFLLGdCQUFMLENBQXNCLElBQXRCLE9BRFM7QUFFbkIsWUFBVSxNQUFLLGVBQUwsQ0FBcUIsSUFBckI7QUFGUyxLQUF2Qjs7QUFLQSxXQUFPLGdCQUFQLENBQXdCLFVBQXhCLEVBQW9DLE1BQUssZUFBTCxDQUFxQixLQUF6RDtBQUNBLFdBQU8sZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsTUFBSyxlQUFMLENBQXFCLElBQXhEOztBQXBCa0M7QUFzQnJDOztBQUVEOzs7Ozs7OzhCQUdVO0FBQ04sV0FBSyxNQUFMLENBQVksbUJBQVosQ0FBZ0MsVUFBaEMsRUFBNEMsS0FBSyxlQUFMLENBQXFCLEtBQWpFO0FBQ0EsV0FBSyxNQUFMLENBQVksbUJBQVosQ0FBZ0MsU0FBaEMsRUFBMkMsS0FBSyxlQUFMLENBQXFCLElBQWhFO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztxQ0FNaUIsSyxFQUFPO0FBQ3BCO0FBQ0EsV0FBSyxPQUFMLENBQWEsT0FBYixFQUFzQixLQUF0QjtBQUNIOztBQUVEOzs7Ozs7Ozs7b0NBTWdCLEssRUFBTzs7QUFFbkI7QUFDQSxZQUFNLE1BQU4sR0FBZSxTQUFTLEtBQVQsQ0FBZ0IsTUFBTSxPQUF0QixDQUFmOztBQUVBO0FBQ0EsV0FBSyxPQUFMLENBQWEsTUFBYixFQUFxQixLQUFyQjtBQUNIOzs7Ozs7QUFJTDs7O0FBQ0EsU0FBUyxJQUFULEdBQWdCLEVBQWhCO0FBQ0EsU0FBUyxJQUFULENBQWMsR0FBZCxHQUEwQixFQUExQjs7QUFFQTtBQUNBLFNBQVMsS0FBVCxHQUFpQixFQUFqQjtBQUNBLFNBQVMsS0FBVCxDQUFnQixFQUFoQixJQUEwQixLQUExQjs7a0JBR2UsUTs7Ozs7Ozs7Ozs7QUNqRmY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7QUFNQSxJQUFNLHVCQUF1Qjs7QUFFekI7OztBQUtBLGFBQVM7QUFDTCxnQkFBUSxnQkFBVSxNQUFWLEVBQWtCLE9BQWxCLEVBQTJCOztBQUUvQixnQkFBSSxZQUFZLElBQWhCOztBQUVBO0FBQ0EsZ0JBQUksT0FBTyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ25CLG9CQUFJLGFBQWEscUJBQU0sTUFBTixDQUFqQjtBQUNBLG9CQUFJLFlBQVksb0JBQUssTUFBTCxDQUFoQjs7QUFFQTtBQUNBLG9CQUFJLENBQUMsYUFBYSxVQUFiLENBQUQsSUFBNkIsQ0FBQyxhQUFhLFNBQWIsQ0FBbEMsRUFBMkQ7O0FBRXZELHdCQUFJLFNBQVMsVUFBVSxPQUFWLENBQWtCLENBQWxCLEVBQXFCLE9BQXJCLEdBQStCLFdBQVcsT0FBWCxDQUFtQixDQUFuQixFQUFzQixPQUFsRTtBQUNBLHdCQUFJLFNBQVMsVUFBVSxPQUFWLENBQWtCLENBQWxCLEVBQXFCLE9BQXJCLEdBQStCLFdBQVcsT0FBWCxDQUFtQixDQUFuQixFQUFzQixPQUFsRTs7QUFFQSx3QkFBSSxVQUFVLEtBQUssR0FBTCxDQUFTLE1BQVQsQ0FBZDtBQUNBLHdCQUFJLFVBQVUsS0FBSyxHQUFMLENBQVMsTUFBVCxDQUFkOztBQUVBO0FBQ0Esd0JBQUksVUFBVyxJQUFJLE9BQWYsSUFBMkIsVUFBVSxRQUFRLGNBQWpELEVBQWlFOztBQUU3RCxvQ0FBWTtBQUNSLGtDQUFNLEdBREU7QUFFUixzQ0FBVTtBQUNOLG1DQUFHLE1BREc7QUFFTixtQ0FBRztBQUZHO0FBRkYseUJBQVo7QUFRSCxxQkFWRCxNQVVPLElBQUssUUFBUSxhQUFSLElBQXlCLFVBQVcsSUFBSSxPQUE3QyxFQUF1RDs7QUFFMUQsb0NBQVk7QUFDUixrQ0FBTSxHQURFO0FBRVIsc0NBQVU7QUFDTixtQ0FBRyxNQURHO0FBRU4sbUNBQUc7QUFGRztBQUZGLHlCQUFaO0FBUUg7QUFFSjtBQUNKOztBQUVELG1CQUFPLFNBQVA7QUFDSCxTQTlDSTtBQStDTCxxQkEvQ0sseUJBK0NTLE1BL0NULEVBK0NpQixTQS9DakIsRUErQzRCOztBQUU3QjtBQUNBLGdCQUFJLGFBQWEsU0FBUyxXQUFULENBQXFCLGFBQXJCLENBQWpCO0FBQ0EsdUJBQVcsZUFBWCxDQUEyQixPQUEzQixFQUFvQyxJQUFwQyxFQUEwQyxLQUExQyxFQUFpRCxJQUFqRDtBQUNBLHVCQUFXLFFBQVgsR0FBc0IsVUFBVSxRQUFoQztBQUNBLHVCQUFXLElBQVgsR0FBa0IsVUFBVSxJQUE1Qjs7QUFFQTtBQUNBLG1CQUFPLGFBQVAsQ0FBcUIsVUFBckI7QUFFSCxTQTFESTs7QUEyREwsZ0JBQVE7QUEzREgsS0FQZ0I7O0FBcUV6Qjs7O0FBS0EsWUFBUTtBQUNKLGdCQUFRLGdCQUFVLE1BQVYsRUFBa0I7QUFDdEIsZ0JBQUksWUFBWSxJQUFoQjs7QUFFQTtBQUNBLGdCQUFJLE9BQU8sTUFBUCxJQUFpQixDQUFyQixFQUF3Qjs7QUFFcEIsb0JBQUksU0FBUSxPQUFPLE9BQU8sTUFBUCxHQUFnQixDQUF2QixDQUFaO0FBQ0Esb0JBQUksUUFBTyxPQUFPLE9BQU8sTUFBUCxHQUFnQixDQUF2QixDQUFYOztBQUVBO0FBQ0Esb0JBQUksYUFBYSxNQUFiLEtBQXVCLGFBQWEsS0FBYixDQUEzQixFQUErQzs7QUFFM0M7QUFDQSx3QkFBSSxnQkFBZ0IsY0FBYyxNQUFkLENBQXBCO0FBQ0Esd0JBQUksZUFBZSxjQUFjLEtBQWQsQ0FBbkI7O0FBRUE7QUFDQSx3QkFBSSxnQkFBZ0IsWUFBcEIsRUFBbUM7O0FBRS9CLCtCQUFPO0FBQ0gsc0NBQVcsWUFEUjtBQUVILG9DQUFTLFlBQVksS0FBWjtBQUZOLHlCQUFQO0FBSUg7QUFDSjtBQUNKOztBQUVELG1CQUFPLFNBQVA7QUFDSCxTQTdCRztBQThCSixxQkE5QkkseUJBOEJVLE1BOUJWLEVBOEJrQixTQTlCbEIsRUE4QjZCOztBQUU3QjtBQUNBLGdCQUFJLGFBQWEsU0FBUyxXQUFULENBQXFCLGFBQXJCLENBQWpCO0FBQ0EsdUJBQVcsZUFBWCxDQUEyQixNQUEzQixFQUFtQyxJQUFuQyxFQUF5QyxLQUF6QyxFQUFnRCxJQUFoRDtBQUNBLHVCQUFXLFFBQVgsR0FBc0IsVUFBVSxRQUFoQzs7QUFFQTtBQUNBLG1CQUFPLGFBQVAsQ0FBcUIsVUFBckI7QUFFSCxTQXhDRzs7QUF5Q0osZ0JBQVE7QUF6Q0osS0ExRWlCOztBQXNIekIsYUFBUztBQUNMLGdCQUFRLGdCQUFVLE1BQVYsRUFBa0I7QUFDdEIsZ0JBQUksWUFBWSxJQUFoQjs7QUFFQTtBQUNBLGdCQUFJLE9BQU8sTUFBUCxJQUFpQixDQUFyQixFQUF3Qjs7QUFFcEIsb0JBQUksVUFBUSxPQUFPLE9BQU8sTUFBUCxHQUFnQixDQUF2QixDQUFaO0FBQ0Esb0JBQUksU0FBTyxPQUFPLE9BQU8sTUFBUCxHQUFnQixDQUF2QixDQUFYOztBQUVBO0FBQ0Esb0JBQUksYUFBYSxPQUFiLEtBQXVCLGFBQWEsTUFBYixDQUEzQixFQUErQzs7QUFFM0M7QUFDQSx3QkFBSSxnQkFBZ0IsY0FBYyxPQUFkLENBQXBCO0FBQ0Esd0JBQUksZUFBZSxjQUFjLE1BQWQsQ0FBbkI7O0FBRUEsd0JBQUksZ0JBQWdCLFlBQXBCLEVBQW1DOztBQUUvQiwrQkFBTztBQUNILHNDQUFXLFlBRFI7QUFFSCxvQ0FBUyxZQUFZLE1BQVo7QUFGTix5QkFBUDtBQUlIO0FBQ0o7QUFDSjs7QUFFRCxtQkFBTyxTQUFQO0FBQ0gsU0E1Qkk7QUE2QkwscUJBN0JLLHlCQTZCUyxNQTdCVCxFQTZCaUIsU0E3QmpCLEVBNkI0Qjs7QUFFN0I7QUFDQSxnQkFBSSxhQUFhLFNBQVMsV0FBVCxDQUFxQixhQUFyQixDQUFqQjtBQUNBLHVCQUFXLGVBQVgsQ0FBMkIsTUFBM0IsRUFBbUMsSUFBbkMsRUFBeUMsS0FBekMsRUFBZ0QsSUFBaEQ7QUFDQSx1QkFBVyxRQUFYLEdBQXNCLFVBQVUsUUFBaEM7O0FBRUE7QUFDQSxtQkFBTyxhQUFQLENBQXFCLFVBQXJCO0FBRUgsU0F2Q0k7O0FBd0NMLGdCQUFRO0FBeENIOztBQXRIZ0IsQ0FBN0I7O0FBbUtBOzs7OztBQUtBLFNBQVMsWUFBVCxDQUFzQixLQUF0QixFQUE2QjtBQUN6QixXQUFPLE1BQU0sT0FBTixDQUFjLE1BQWQsR0FBdUIsQ0FBOUI7QUFDSDs7QUFFRDs7Ozs7QUFLQSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsRUFBOEI7O0FBRTFCLFFBQUksSUFBSSxNQUFNLE9BQU4sQ0FBYyxDQUFkLENBQVI7QUFDQSxRQUFJLElBQUksTUFBTSxPQUFOLENBQWMsQ0FBZCxDQUFSOztBQUVBLFdBQU8sS0FBSyxJQUFMLENBQVcsS0FBSyxHQUFMLENBQVMsRUFBRSxPQUFGLEdBQVksRUFBRSxPQUF2QixFQUFnQyxDQUFoQyxJQUFxQyxLQUFLLEdBQUwsQ0FBUyxFQUFFLE9BQUYsR0FBWSxFQUFFLE9BQXZCLEVBQWdDLENBQWhDLENBQWhELENBQVA7QUFDSDs7QUFFRDs7Ozs7QUFLQSxTQUFTLFdBQVQsQ0FBcUIsS0FBckIsRUFBNEI7QUFDeEIsUUFBSyxhQUFhLEtBQWIsQ0FBTCxFQUEyQjs7QUFFdkIsWUFBSSxJQUFJLE1BQU0sT0FBTixDQUFjLENBQWQsQ0FBUjtBQUNBLFlBQUksSUFBSSxNQUFNLE9BQU4sQ0FBYyxDQUFkLENBQVI7O0FBRUEsWUFBSSxLQUFLLEVBQUUsT0FBWDtBQUNBLFlBQUksS0FBSyxFQUFFLE9BQVg7O0FBRUEsWUFBSSxLQUFLLEVBQUUsT0FBWDtBQUNBLFlBQUksS0FBSyxFQUFFLE9BQVg7O0FBRUE7QUFDQSxZQUFJLElBQUksS0FBTSxDQUFDLEtBQUssRUFBTixJQUFZLENBQTFCO0FBQ0EsWUFBSSxJQUFJLEtBQU0sQ0FBQyxLQUFLLEVBQU4sSUFBWSxDQUExQjs7QUFFQSxlQUFPO0FBQ0gsZUFBSSxDQUREO0FBRUgsZUFBSTtBQUZELFNBQVA7QUFLSCxLQXBCRCxNQW9CTztBQUNILFlBQUksUUFBUSxNQUFNLE9BQU4sQ0FBYyxDQUFkLENBQVo7O0FBRUEsZUFBTztBQUNILGVBQUksTUFBTSxPQURQO0FBRUgsZUFBSSxNQUFNO0FBRlAsU0FBUDtBQUlIO0FBQ0o7O0FBR0Q7Ozs7Ozs7O0lBT00sSzs7O0FBRUY7Ozs7QUFJQSxtQkFBWSxNQUFaLEVBQWtDO0FBQUEsWUFBZCxPQUFjLHVFQUFKLEVBQUk7O0FBQUE7O0FBRzlCOzs7O0FBSDhCOztBQU85QixjQUFLLE1BQUwsR0FBYyxNQUFkOztBQUVBOzs7O0FBSUEsY0FBSyxPQUFMLEdBQWUsd0JBQVMsT0FBVCxFQUFrQixNQUFNLGNBQXhCLENBQWY7O0FBRUE7QUFDQSxjQUFLLFlBQUwsR0FBb0I7QUFDaEIsbUJBQU8sTUFBSyxrQkFBTCxDQUF3QixJQUF4QixPQURTO0FBRWhCLGtCQUFNLE1BQUssaUJBQUwsQ0FBdUIsSUFBdkIsT0FGVTtBQUdoQixpQkFBSyxNQUFLLGdCQUFMLENBQXNCLElBQXRCO0FBSFcsU0FBcEI7O0FBTUEsY0FBSyxNQUFMLENBQVksZ0JBQVosQ0FBNkIsWUFBN0IsRUFBMkMsTUFBSyxZQUFMLENBQWtCLEtBQTdEO0FBQ0EsY0FBSyxNQUFMLENBQVksZ0JBQVosQ0FBNkIsV0FBN0IsRUFBMEMsTUFBSyxZQUFMLENBQWtCLElBQTVEO0FBQ0EsY0FBSyxNQUFMLENBQVksZ0JBQVosQ0FBNkIsVUFBN0IsRUFBeUMsTUFBSyxZQUFMLENBQWtCLEdBQTNEOztBQUVBO0FBQ0EsWUFBSSxNQUFLLE9BQUwsQ0FBYSxhQUFqQixFQUFnQztBQUM1QixtQkFBTyxnQkFBUCxDQUF3QixVQUF4QixFQUFvQyxNQUFLLFlBQUwsQ0FBa0IsR0FBdEQ7QUFDSDs7QUE3QjZCO0FBK0JqQzs7QUFFRDs7Ozs7Ozs7O0FBcURBOzs7a0NBR1U7O0FBRU4saUJBQUssTUFBTCxDQUFZLG1CQUFaLENBQWdDLFlBQWhDLEVBQThDLEtBQUssWUFBTCxDQUFrQixLQUFoRTtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxtQkFBWixDQUFnQyxXQUFoQyxFQUE2QyxLQUFLLFlBQUwsQ0FBa0IsSUFBL0Q7QUFDQSxpQkFBSyxNQUFMLENBQVksbUJBQVosQ0FBZ0MsVUFBaEMsRUFBNEMsS0FBSyxZQUFMLENBQWtCLEdBQTlEOztBQUVBLGdCQUFJLEtBQUssT0FBTCxDQUFhLGFBQWpCLEVBQWdDO0FBQzVCLHVCQUFPLG1CQUFQLENBQTJCLFVBQTNCLEVBQXVDLEtBQUssWUFBTCxDQUFrQixHQUF6RDtBQUNIO0FBRUo7O0FBRUQ7Ozs7QUFNQTs7Ozs7Ozs7OzsrQkFPTyxLLEVBQU87O0FBRVY7QUFDQSxnQkFBSSxLQUFLLFNBQVQsRUFBb0IsS0FBSyxHQUFMOztBQUVwQjs7OztBQUlBLGlCQUFLLFNBQUwsR0FBaUIsSUFBakI7O0FBRUE7Ozs7O0FBS0EsaUJBQUssWUFBTCxHQUFvQixDQUFDLEtBQUQsQ0FBcEI7O0FBRUE7Ozs7O0FBS0EsaUJBQUssZ0JBQUwsR0FBd0IsRUFBeEI7O0FBRUEsaUJBQUssT0FBTCxDQUFhLE9BQWIsRUFBc0IsS0FBdEI7QUFDSDs7QUFFRDs7Ozs7Ozs7OEJBS00sSyxFQUFPO0FBQ1QsaUJBQUssWUFBTCxDQUFrQixJQUFsQixDQUF1QixLQUF2Qjs7QUFFQTtBQUNBO0FBQ0EsaUJBQUssSUFBSSxPQUFULElBQW9CLG9CQUFwQixFQUEwQzs7QUFFdEMsb0JBQUksYUFBYSxxQkFBcUIsT0FBckIsQ0FBakI7QUFDQSxvQkFBSSxjQUFjLFdBQVcsTUFBWCxDQUFrQixLQUFLLFlBQXZCLEVBQXFDLEtBQUssT0FBMUMsQ0FBbEI7O0FBRUE7QUFDQSxvQkFBSSxXQUFKLEVBQWlCOztBQUViO0FBQ0Esd0JBQUssV0FBVyxNQUFYLElBQXNCLENBQUMsV0FBVyxNQUFaLElBQXNCLENBQUMsS0FBSyxnQkFBTCxDQUFzQixPQUF0QixDQUFsRCxFQUFvRjs7QUFFaEY7QUFDQSw4QkFBTSxjQUFOOztBQUVBO0FBQ0EsNkJBQUssZ0JBQUwsQ0FBc0IsT0FBdEIsSUFBaUMsV0FBakM7O0FBRUEsNEJBQUksS0FBSyxPQUFMLENBQWEsU0FBakIsRUFBNEI7QUFDeEIsdUNBQVcsYUFBWCxDQUF5QixLQUFLLE1BQTlCLEVBQXNDLFdBQXRDO0FBQ0g7O0FBRUQsNkJBQUssT0FBTCxDQUFhLE9BQWIsRUFBc0IsV0FBdEI7QUFDSDtBQUVKO0FBQ0o7O0FBR0QsaUJBQUssT0FBTCxDQUFhLE1BQWIsRUFBcUIsS0FBckI7QUFFSDs7QUFFRDs7Ozs7Ozs7OzZCQU1LLEssRUFBTzs7QUFFUjtBQUNBLGlCQUFLLE9BQUwsQ0FBYSxLQUFiLEVBQW9CLEtBQXBCOztBQUVBLGlCQUFLLFlBQUwsR0FBb0IsRUFBcEI7QUFDQSxpQkFBSyxTQUFMLEdBQWlCLEtBQWpCO0FBRUg7O0FBRUQ7Ozs7QUFNQTs7Ozs7Ozs7MkNBS21CLEssRUFBTzs7QUFFdEI7QUFDQSxnQkFBSSxNQUFNLE9BQU4sQ0FBYyxNQUFkLEdBQXVCLENBQTNCLEVBQThCO0FBQzFCLHNCQUFNLGNBQU47QUFDSDs7QUFFRDtBQUNBLGdCQUFJLEtBQUssU0FBVCxFQUFvQjtBQUNoQixxQkFBSyxLQUFMLENBQVcsS0FBWDtBQUNILGFBRkQsTUFFTztBQUNILHFCQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0g7QUFFSjs7QUFFRDs7Ozs7Ozs7MENBS2tCLEssRUFBTzs7QUFFckI7QUFDQSxnQkFBSSxNQUFNLE9BQU4sQ0FBYyxNQUFkLEdBQXVCLENBQTNCLEVBQThCO0FBQzFCLHNCQUFNLGNBQU47QUFDSDs7QUFFRCxpQkFBSyxLQUFMLENBQVcsS0FBWDtBQUNIOztBQUVEOzs7Ozs7Ozt5Q0FLaUIsSyxFQUFPO0FBQ3BCLGlCQUFLLElBQUwsQ0FBVSxLQUFWO0FBQ0g7Ozs0QkFwTmM7O0FBRVg7QUFDQSxnQkFBSyxDQUFDLEtBQUssWUFBTixJQUFzQixLQUFLLFlBQUwsQ0FBa0IsTUFBbEIsR0FBMkIsQ0FBdEQsRUFBMEQ7QUFDdEQsdUJBQU8sR0FBUDtBQUNILGFBRkQsTUFFTzs7QUFFSCxvQkFBSSxJQUFJLEtBQUssWUFBTCxDQUFrQixDQUFsQixFQUFxQixPQUFyQixDQUE2QixDQUE3QixDQUFSO0FBQ0Esb0JBQUksSUFBSSxLQUFLLFlBQUwsQ0FBbUIsS0FBSyxZQUFMLENBQWtCLE1BQWxCLEdBQTJCLENBQTlDLEVBQWtELE9BQWxELENBQTBELENBQTFELENBQVI7O0FBRUEsdUJBQU8sS0FBSyxJQUFMLENBQVcsS0FBSyxHQUFMLENBQVMsRUFBRSxPQUFGLEdBQVksRUFBRSxPQUF2QixFQUFnQyxDQUFoQyxJQUFxQyxLQUFLLEdBQUwsQ0FBUyxFQUFFLE9BQUYsR0FBWSxFQUFFLE9BQXZCLEVBQWdDLENBQWhDLENBQWhELENBQVA7QUFDSDtBQUVKOztBQUdEOzs7Ozs7OzRCQUlnQjtBQUNaO0FBQ0EsZ0JBQUssQ0FBQyxLQUFLLFlBQU4sSUFBc0IsS0FBSyxZQUFMLENBQWtCLE1BQWxCLEdBQTJCLENBQXRELEVBQTBEO0FBQ3RELHVCQUFPLEdBQVA7QUFDSCxhQUZELE1BRU87O0FBRUgsb0JBQUksSUFBSSxLQUFLLFlBQUwsQ0FBa0IsQ0FBbEIsRUFBcUIsT0FBckIsQ0FBNkIsQ0FBN0IsQ0FBUjtBQUNBLG9CQUFJLElBQUksS0FBSyxZQUFMLENBQW1CLEtBQUssWUFBTCxDQUFrQixNQUFsQixHQUEyQixDQUE5QyxFQUFtRCxPQUFuRCxDQUEyRCxDQUEzRCxDQUFSOztBQUVBLHVCQUFPLEVBQUUsT0FBRixHQUFZLEVBQUUsT0FBckI7QUFDSDtBQUNKOztBQUVEOzs7Ozs7OzRCQUlnQjtBQUNaO0FBQ0EsZ0JBQUssQ0FBQyxLQUFLLFlBQU4sSUFBc0IsS0FBSyxZQUFMLENBQWtCLE1BQWxCLEdBQTJCLENBQXRELEVBQTBEO0FBQ3RELHVCQUFPLEdBQVA7QUFDSCxhQUZELE1BRU87O0FBRUgsb0JBQUksSUFBSSxLQUFLLFlBQUwsQ0FBa0IsQ0FBbEIsRUFBcUIsT0FBckIsQ0FBNkIsQ0FBN0IsQ0FBUjtBQUNBLG9CQUFJLElBQUksS0FBSyxZQUFMLENBQW1CLEtBQUssWUFBTCxDQUFrQixNQUFsQixHQUEyQixDQUE5QyxFQUFtRCxPQUFuRCxDQUEyRCxDQUEzRCxDQUFSOztBQUVBLHVCQUFPLEVBQUUsT0FBRixHQUFZLEVBQUUsT0FBckI7QUFDSDtBQUNKOzs7Ozs7QUF3S0w7Ozs7OztBQUlBLE1BQU0sY0FBTixHQUF1Qjs7QUFFbkI7OztBQUdBLG1CQUFlLEtBTEk7O0FBT25COzs7QUFHQSxvQkFBZ0IsRUFWRzs7QUFZbkI7OztBQUdBLGVBQVc7O0FBZlEsQ0FBdkI7O2tCQW1CZSxLOzs7Ozs7Ozs7OztBQzNnQmY7Ozs7QUFFQTs7Ozs7Ozs7Ozs7O0lBRU0sVzs7O0FBRUYseUJBQVksR0FBWixFQUFpQixNQUFqQixFQUF5QixLQUF6QixFQUE4QztBQUFBLFlBQWQsT0FBYyx1RUFBSixFQUFJOztBQUFBOztBQUUxQztBQUNBLFlBQUksU0FBUyxRQUFRLE1BQXJCOztBQUgwQyw4SEFLcEMsR0FMb0MsRUFLL0Isd0JBQVMsRUFBQyxRQUFRLElBQVQsRUFBVCxFQUF5QixPQUF6QixDQUwrQjs7QUFPMUMsY0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLGNBQUssS0FBTCxHQUFhLEtBQWI7O0FBRUEsWUFBSyxDQUFDLE1BQU4sRUFBZTtBQUNYLGtCQUFLLElBQUw7QUFDSDs7QUFaeUM7QUFjN0M7O0FBRUQ7Ozs7Ozs7K0JBR087QUFBQTs7QUFFSCxnQkFBSSxRQUFRLElBQUksS0FBSixFQUFaOztBQUVBLGtCQUFNLE1BQU4sR0FBZSxZQUFNO0FBQ2pCLHVCQUFLLE1BQUwsR0FBYyxpQkFBTyxNQUFQLENBQWMsT0FBNUI7QUFDQSx1QkFBSyxlQUFMLENBQXFCLEVBQUMsS0FBTSxPQUFLLEdBQVosRUFBaUIsTUFBTSxLQUF2QixFQUE4QixTQUFTLEtBQXZDLEVBQXJCO0FBQ0EsdUJBQUssbUJBQUw7QUFDSCxhQUpEOztBQU1BLGtCQUFNLE9BQU4sR0FBZ0IsWUFBTTtBQUNsQix1QkFBSyxjQUFMLENBQW9CLHlCQUFwQjtBQUNBLHVCQUFLLG1CQUFMO0FBQ0gsYUFIRDs7QUFLQTtBQUNBLGdCQUFJLE1BQU0sUUFBTixLQUFtQixJQUFuQixJQUEyQixNQUFNLEtBQWpDLElBQTBDLE1BQU0sTUFBcEQsRUFBNEQ7QUFDeEQsMkJBQVk7QUFBQSwyQkFBTSxNQUFNLE1BQU4sRUFBTjtBQUFBLGlCQUFaLEVBQWtDLENBQWxDO0FBQ0g7O0FBRUQ7QUFDQSxnQkFBSSxLQUFLLE1BQVQsRUFBaUIsTUFBTSxNQUFOLEdBQWUsS0FBSyxNQUFwQjtBQUNqQixnQkFBSSxLQUFLLEtBQVQsRUFBZ0IsTUFBTSxLQUFOLEdBQWMsS0FBSyxLQUFuQjtBQUNoQixrQkFBTSxHQUFOLEdBQVksS0FBSyxHQUFqQjtBQUVIOzs7Ozs7a0JBSVUsVzs7Ozs7Ozs7Ozs7O0FDdERmOzs7O0FBR0E7Ozs7Ozs7Ozs7OztBQURBOzs7QUFJQSxJQUFJLFdBQVcsQ0FBZjs7SUFFTSxNOzs7QUFFRixvQkFBWSxHQUFaLEVBQStEO0FBQUEsWUFBOUMsT0FBOEMsdUVBQXBDLEVBQUMsUUFBUyxLQUFWLEVBQWlCLFdBQVksSUFBN0IsRUFBb0M7O0FBQUE7O0FBQUE7O0FBRzNELGNBQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxjQUFLLEVBQUwsR0FBVSxRQUFRLEVBQVIsSUFBYyxZQUFVLFVBQWxDOztBQUVBLGNBQUssT0FBTCxHQUFlLE9BQWY7O0FBRUE7QUFDQSxjQUFLLFFBQUwsR0FBZ0IsQ0FBaEI7O0FBRUE7QUFDQSxjQUFLLE9BQUwsR0FBZSxJQUFJLE9BQUosQ0FBYSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCO0FBQzdDLGtCQUFLLGVBQUwsR0FBdUIsT0FBdkI7QUFDQSxrQkFBSyxjQUFMLEdBQXNCLE1BQXRCO0FBQ0gsU0FIYyxDQUFmOztBQUtBO0FBQ0EsWUFBSyxNQUFLLE9BQUwsQ0FBYSxNQUFsQixFQUEyQjtBQUN2QixrQkFBSyxNQUFMLEdBQWMsT0FBTyxNQUFQLENBQWMsTUFBNUI7QUFDSCxTQUZELE1BRU87QUFDSCxrQkFBSyxJQUFMO0FBQ0g7O0FBdEIwRDtBQXdCOUQ7Ozs7K0JBRU07QUFBQTs7QUFFSDtBQUNBLGlCQUFLLE9BQUwsR0FBZSxtQkFBSTtBQUNmLHFCQUFNLEtBQUssR0FESTtBQUVmLDRCQUFhLG9CQUFDLFNBQUQsRUFBZTtBQUN4QjtBQUNBLDhCQUFVLGdCQUFWLENBQTJCLFVBQTNCLEVBQXVDLFVBQUMsS0FBRCxFQUFXO0FBQzlDLCtCQUFLLG1CQUFMLENBQXlCLEtBQXpCLEVBRDhDLENBQ2I7QUFDcEMscUJBRkQ7QUFHSDtBQVBjLGFBQUosRUFRWixVQUFDLEdBQUQsRUFBTSxRQUFOLEVBQWdCLElBQWhCLEVBQXlCOztBQUV4QixvQkFBSSxxQkFBcUIsU0FBVSxTQUFTLFVBQVQsQ0FBb0IsUUFBcEIsR0FBK0IsQ0FBL0IsQ0FBVixDQUF6Qjs7QUFFQSxvQkFBSSxHQUFKLEVBQVM7O0FBRUwsMkJBQUssY0FBTCxDQUFvQixJQUFJLEtBQUosQ0FBVSxTQUFTLElBQW5CLENBQXBCO0FBQ0EsMkJBQUssbUJBQUw7QUFFSCxpQkFMRCxNQUtPLElBQUssRUFBRSxRQUFGLENBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaLEVBQW9CLGtCQUFwQixDQUFMLEVBQWdELENBSXRELENBSk0sTUFJQTs7QUFFSDtBQUNBLDJCQUFLLE9BQUwsR0FBZSxJQUFmOztBQUVBO0FBQ0Esd0JBQUksT0FBSyxPQUFMLENBQWEsU0FBakIsRUFBNEI7O0FBRXhCO0FBQ0EsNEJBQUssT0FBSyxHQUFMLENBQVMsV0FBVCxDQUFxQixHQUFyQixJQUE0QixPQUFLLEdBQUwsQ0FBUyxXQUFULENBQXFCLEdBQXJCLENBQWpDLEVBQTREO0FBQ3hELGdDQUFJLGNBQWMsU0FBUyxPQUFULENBQWlCLGNBQWpCLENBQWxCO0FBQ0EsZ0NBQUksYUFBSjtBQUNBLGdDQUFLLFlBQVksV0FBWixHQUEwQixRQUExQixDQUFtQyxrQkFBbkMsQ0FBTCxFQUE4RDtBQUMxRCx1Q0FBTyxNQUFQO0FBQ0g7O0FBRUQsbUNBQUssSUFBTCxHQUFZLE9BQU8saUJBQVAsQ0FBMEIsT0FBSyxHQUEvQixFQUFvQyxJQUFwQyxFQUEwQyxJQUExQyxDQUFaO0FBQ0gseUJBUkQsTUFRTztBQUNILG1DQUFLLElBQUwsR0FBWSxPQUFPLGlCQUFQLENBQTBCLE9BQUssR0FBL0IsRUFBb0MsSUFBcEMsQ0FBWjtBQUNIO0FBRUoscUJBZkQsTUFlTztBQUNILCtCQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0g7O0FBRUQsMkJBQUssZUFBTCxDQUFxQixFQUFDLEtBQU0sT0FBSyxHQUFaLEVBQWlCLE1BQU0sT0FBSyxJQUE1QixFQUFrQyxTQUFTLElBQTNDLEVBQXJCO0FBQ0EsMkJBQUssbUJBQUw7QUFDSDtBQUVKLGFBbERjLENBQWY7O0FBb0RBLGlCQUFLLE1BQUwsR0FBYyxPQUFPLE1BQVAsQ0FBYyxPQUE1Qjs7QUFFQSxtQkFBTyxLQUFLLE9BQVo7QUFFSDs7OzRDQUVtQixLLEVBQU87QUFDdkIsZ0JBQUksTUFBTSxnQkFBVixFQUE0QjtBQUN4QixxQkFBSyxRQUFMLEdBQWdCLE1BQU0sTUFBTixHQUFlLE1BQU0sS0FBckM7QUFDQSxxQkFBSyxPQUFMLENBQWEsVUFBYixFQUF5QixFQUFDLFVBQVcsS0FBSyxRQUFqQixFQUF6QjtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7OENBSXNCOztBQUVsQixpQkFBSyxNQUFMLEdBQWMsT0FBTyxNQUFQLENBQWMsUUFBNUI7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLENBQWhCO0FBQ0EsaUJBQUssT0FBTCxDQUFhLFVBQWIsRUFBeUIsRUFBQyxRQUFRLElBQVQsRUFBekI7QUFFSDs7Ozs7O0FBU0w7Ozs7Ozs7OztBQU9BLE9BQU8saUJBQVAsR0FBMkIsVUFBVSxHQUFWLEVBQWUsSUFBZixFQUF1QztBQUFBLFFBQWxCLFNBQWtCLHVFQUFOLElBQU07OztBQUU5RCxRQUFJLHFCQUFKOztBQUVBLFFBQUksTUFBTyxjQUFjLElBQWYsR0FBdUIsU0FBdkIsR0FBbUMsSUFBSSxNQUFKLENBQVksSUFBSSxXQUFKLENBQWdCLEdBQWhCLElBQXFCLENBQWpDLENBQTdDOztBQUVBLFlBQVEsR0FBUjtBQUNJLGFBQUssSUFBTDtBQUNJLDJCQUFlLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUFmO0FBQ0EseUJBQWEsV0FBYixHQUEyQixJQUEzQjtBQUNBO0FBQ0osYUFBSyxNQUFMO0FBQ0ksMkJBQWUsS0FBSyxLQUFMLENBQVksSUFBWixDQUFmO0FBQ0E7QUFDSixhQUFLLEtBQUw7QUFDSSxnQkFBSSxVQUFVLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFkO0FBQ0Esb0JBQVEsU0FBUixHQUFvQixJQUFwQjtBQUNBLDJCQUFlLFFBQVEsVUFBdkI7QUFDQTtBQUNKO0FBQVU7QUFDTiwyQkFBZSxJQUFmO0FBZFI7O0FBaUJBLFdBQU8sWUFBUDtBQUVILENBekJEOztBQTJCQSxPQUFPLE1BQVAsR0FBZ0I7QUFDWixZQUFjLFFBREY7QUFFWixhQUFjLFNBRkY7QUFHWixjQUFjO0FBSEYsQ0FBaEI7O1FBUWtCLE8sR0FBVixNOzs7Ozs7Ozs7Ozs7QUNyS1I7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7OztBQUVBLElBQU0sZ0JBQWdCO0FBQ2xCLFNBQU0sTUFEWTtBQUVsQixjQUFXLEdBRk87QUFHbEIsZUFBWTtBQUhNLENBQXRCOztJQU1NLFc7QUFFRiwyQkFBYztBQUFBO0FBRWI7Ozs7bUNBRVUsZSxFQUFpQjtBQUN4QixpQkFBSyxVQUFMLEdBQWtCLEVBQWxCOztBQUVBO0FBQ0Esb0NBQVUsS0FBSyxVQUFmLEVBQTJCLGVBQTNCLEVBQTRDLGFBQTVDOztBQUVBO0FBQ0EsaUJBQUssVUFBTCxDQUFnQixTQUFoQixHQUE0QiwwQkFBVyxLQUFLLFVBQUwsQ0FBZ0IsU0FBM0IsRUFBc0MsR0FBdEMsSUFBNkMsS0FBSyxVQUFMLENBQWdCLFNBQWhCLENBQTBCLE1BQTFCLENBQWlDLENBQWpDLENBQTdDLEdBQW1GLEtBQUssVUFBTCxDQUFnQixTQUEvSDs7QUFFQTtBQUNBLGlCQUFLLFVBQUwsQ0FBZ0IsUUFBaEIsSUFBNkIsd0JBQVMsS0FBSyxVQUFMLENBQWdCLFFBQXpCLEVBQW1DLEdBQW5DLElBQTBDLEVBQTFDLEdBQStDLEdBQTVFO0FBQ0EsaUJBQUssVUFBTCxDQUFnQixTQUFoQixJQUE4Qix3QkFBUyxLQUFLLFVBQUwsQ0FBZ0IsU0FBekIsRUFBb0MsR0FBcEMsSUFBMkMsRUFBM0MsR0FBZ0QsR0FBOUU7O0FBRUE7QUFDQSxpQkFBSyxVQUFMLENBQWdCLE1BQWhCLEdBQXlCLFNBQVMsUUFBVCxHQUFrQixJQUFsQixHQUF1QixTQUFTLFFBQWhDLElBQTBDLFNBQVMsSUFBVCxHQUFnQixNQUFJLFNBQVMsSUFBN0IsR0FBbUMsRUFBN0UsQ0FBekI7QUFDSDs7OzRCQUVTO0FBQ04sbUJBQU8sS0FBSyxVQUFMLENBQWdCLEdBQXZCO0FBQ0g7Ozs0QkFFZTtBQUNaLG1CQUFPLEtBQUssVUFBTCxDQUFnQixNQUFoQixHQUF5QixLQUFLLFVBQUwsQ0FBZ0IsUUFBekMsR0FBb0QsS0FBSyxVQUFMLENBQWdCLFNBQTNFO0FBQ0g7Ozs0QkFFYztBQUNYLG1CQUFPLEtBQUssVUFBTCxDQUFnQixNQUFoQixHQUF5QixLQUFLLFVBQUwsQ0FBZ0IsUUFBaEQ7QUFDSDs7Ozs7O0FBSUwsSUFBTSxTQUFTLElBQUksV0FBSixFQUFmOztRQUVrQixPLEdBQVYsTTtRQUFtQixXLEdBQUEsVzs7Ozs7Ozs7Ozs7O0FDakQzQjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU0sTzs7O0FBRUYscUJBQVksRUFBWixFQUE0QjtBQUFBLFlBQVosTUFBWSx1RUFBSCxDQUFHOztBQUFBOztBQUFBOztBQUd4QixjQUFLLEVBQUwsR0FBVSxFQUFWO0FBQ0EsY0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLGNBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxjQUFLLEtBQUwsR0FBYSxJQUFiOztBQU53QjtBQVEzQjs7Ozs7QUFLTDs7Ozs7Ozs7OztJQVFNLGdCOzs7QUFFRixnQ0FBc0M7QUFBQSxZQUExQixlQUEwQix1RUFBUixNQUFROztBQUFBOztBQUdsQzs7O0FBSGtDOztBQU1sQyxlQUFLLGVBQUwsR0FBdUIsZUFBdkI7O0FBRUEsZUFBSyxTQUFMLEdBQWlCLEVBQWpCOztBQUVBLFlBQUksb0JBQW9CLE1BQXhCLEVBQWdDO0FBQzVCLG1CQUFLLFFBQUwsMEJBQThCLFFBQTlCLEVBQXdDLE9BQUssb0JBQTdDO0FBQ0gsU0FGRCxNQUVPO0FBQ0g7QUFDQSxtQkFBSyxjQUFMLEdBQXNCLE9BQUssb0JBQUwsQ0FBMEIsSUFBMUIsUUFBdEI7QUFDQSw0QkFBZ0IsZ0JBQWhCLENBQWtDLFFBQWxDLEVBQTRDLE9BQUssY0FBakQ7QUFDSDs7QUFFRCxlQUFLLFFBQUwsMEJBQThCLFFBQTlCLEVBQXdDLE9BQUssb0JBQTdDOztBQWxCa0M7QUFvQnJDOztBQUVEOzs7O0FBTUE7Ozs7Ozs7Ozs7cUNBTWEsRSxFQUFnQjtBQUFBLGdCQUFaLE1BQVksdUVBQUgsQ0FBRzs7O0FBRXpCLGdCQUFJLFVBQVUsSUFBSSxPQUFKLENBQVksRUFBWixFQUFnQixNQUFoQixDQUFkOztBQUVBLGlCQUFLLFNBQUwsQ0FBZSxJQUFmLENBQXFCLE9BQXJCOztBQUVBLGlCQUFLLHFCQUFMLENBQTJCLE9BQTNCOztBQUVBLGlCQUFLLE9BQUwsQ0FBYSxLQUFiOztBQUVBLG1CQUFPLE9BQVA7QUFFSDs7O3VDQUVjLFcsRUFBYTs7QUFFeEIsZ0JBQUkscUJBQUo7O0FBRUEsZ0JBQUksdUJBQXVCLE9BQTNCLEVBQW9DO0FBQ2hDLCtCQUFlLEtBQUssU0FBTCxDQUFlLE9BQWYsQ0FBd0IsV0FBeEIsQ0FBZjtBQUNILGFBRkQsTUFFTztBQUNILCtCQUFlLHlCQUFVLEtBQUssU0FBZixFQUEwQixFQUFDLElBQUksV0FBTCxFQUExQixDQUFmO0FBQ0g7QUFFSjs7QUFFRDs7Ozs7Ozs4Q0FJc0IsVyxFQUFhOztBQUUvQixnQkFBSSxpQkFBSjs7QUFFQSxnQkFBSyxDQUFDLFdBQU4sRUFBb0I7QUFDaEIsMkJBQVcsS0FBSyxTQUFoQjtBQUNILGFBRkQsTUFFTyxJQUFLLHlCQUFVLFdBQVYsQ0FBTCxFQUErQjtBQUNsQywyQkFBVyxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CO0FBQUEsMkJBQVcsWUFBWSxXQUF2QjtBQUFBLGlCQUFwQixDQUFYO0FBQ0gsYUFGTSxNQUVBLElBQUssdUJBQXVCLE9BQTVCLEVBQXNDO0FBQ3pDLDJCQUFXLENBQUMsV0FBRCxDQUFYO0FBQ0g7O0FBR0QscUJBQVMsT0FBVCxDQUFrQixtQkFBVzs7QUFFekI7QUFDQSxvQkFBTSx5QkFBeUIsNkJBQTZCLElBQTdCLENBQW1DLFFBQVEsRUFBUixDQUFXLFlBQVgsQ0FBd0IsT0FBeEIsQ0FBbkMsQ0FBL0I7QUFDQSxvQkFBTSwwQkFBMEIsOEJBQThCLElBQTlCLENBQW9DLFFBQVEsRUFBUixDQUFXLFlBQVgsQ0FBd0IsT0FBeEIsQ0FBcEMsQ0FBaEM7O0FBRUEsb0JBQU0sbUJBQW9CLGdCQUFNLEdBQU4sQ0FBVyxRQUFRLEVBQW5CLEVBQXVCLFdBQXZCLENBQTFCO0FBQ0Esb0JBQU0sb0JBQW9CLGdCQUFNLEdBQU4sQ0FBVyxRQUFRLEVBQW5CLEVBQXVCLFlBQXZCLENBQTFCOztBQUVBLGdDQUFNLEdBQU4sQ0FBVyxRQUFRLEVBQW5CLEVBQXVCO0FBQ25CLCtCQUFZLE1BRE87QUFFbkIsZ0NBQWE7QUFGTSxpQkFBdkI7O0FBS0E7QUFDQSxvQkFBTSxpQkFBaUIsK0JBQWdCLFFBQVEsRUFBeEIsQ0FBdkI7O0FBRUE7QUFDQSxvQkFBTSxTQUFTLGVBQWUsTUFBZixHQUF3QixRQUFRLE1BQS9DO0FBQ0Esb0JBQU0sTUFBTSxlQUFlLEdBQWYsR0FBeUIsQ0FBQyxlQUFlLE1BQWYsR0FBd0IsTUFBekIsSUFBbUMsQ0FBeEU7O0FBRUEsd0JBQVEsR0FBUixHQUFjLEdBQWQ7QUFDQSx3QkFBUSxNQUFSLEdBQWlCLE1BQWpCOztBQUVBO0FBQ0Esb0JBQUksb0JBQW9CLHNCQUF4QixFQUFnRDtBQUM1QyxvQ0FBTSxHQUFOLENBQVUsUUFBUSxFQUFsQixFQUFzQixFQUFDLFdBQVcsZ0JBQVosRUFBdEI7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsNEJBQVEsRUFBUixDQUFXLEtBQVgsQ0FBaUIsY0FBakIsQ0FBZ0MsV0FBaEM7QUFDSDs7QUFFRCxvQkFBSSxxQkFBcUIsdUJBQXpCLEVBQWtEO0FBQzlDLG9DQUFNLEdBQU4sQ0FBVSxRQUFRLEVBQWxCLEVBQXNCLEVBQUMsWUFBWSxpQkFBYixFQUF0QjtBQUNILGlCQUZELE1BRU87QUFDSCw0QkFBUSxFQUFSLENBQVcsS0FBWCxDQUFpQixjQUFqQixDQUFnQyxZQUFoQztBQUNIO0FBSUosYUF2Q0Q7O0FBeUNBLGlCQUFLLE9BQUwsQ0FBYSxLQUFiO0FBRUg7O0FBRUQ7Ozs7Ozt1REFNK0I7QUFDM0IsbUJBQVEsS0FBSyxlQUFMLEtBQXlCLE1BQTFCLEdBQXFDLHdCQUFjLGNBQWQsQ0FBNkIsR0FBbEUsR0FBd0UsS0FBSyxlQUFMLENBQXFCLFNBQXBHO0FBQ0g7OztvREFFMkI7QUFDeEIsbUJBQVEsS0FBSyxlQUFMLEtBQXlCLE1BQTFCLEdBQXFDLHdCQUFjLE1BQW5ELEdBQTRELEtBQUssZUFBTCxDQUFxQixZQUF4RjtBQUNIOzs7a0NBRTZCO0FBQUE7O0FBQUEsZ0JBQXRCLGFBQXNCLHVFQUFOLElBQU07OztBQUUxQixnQkFBSSxZQUFZLEtBQUssNEJBQUwsRUFBaEI7QUFDQSxnQkFBSSxlQUFlLEtBQUsseUJBQUwsRUFBbkI7QUFDQSxnQkFBSSxlQUFlLFlBQVksS0FBSyx5QkFBTCxFQUEvQjs7QUFFQSxpQkFBSyxTQUFMLENBQWUsT0FBZixDQUF3QixtQkFBVzs7QUFFL0Isb0JBQUksZUFBZSxRQUFRLEtBQTNCO0FBQ0Esb0JBQUksY0FBYyxRQUFRLElBQTFCO0FBQ0Esb0JBQUksaUJBQUo7QUFDQSxvQkFBSSxnQkFBSjs7QUFFQSxvQkFBSSxhQUFhLFFBQVEsR0FBekI7QUFDQSxvQkFBSSxnQkFBZ0IsUUFBUSxHQUFSLEdBQWMsUUFBUSxNQUExQzs7QUFFQTs7QUFFQTtBQUNBLG9CQUFJLGVBQWUsVUFBZixJQUE2QjtBQUM3Qiw0QkFBWSxhQURoQixFQUMrQjtBQUFHOztBQUU5QiwrQkFBVyxpQkFBaUIsS0FBakIsQ0FBdUIsR0FBbEM7O0FBRUo7QUFDQyxpQkFORCxNQU1PLElBQUssWUFBWSxVQUFaLElBQTBCLGVBQWUsYUFBMUMsSUFBNEQ7QUFDbEUsNEJBQVksVUFBWixJQUEwQixZQUFZLGFBQXZDLElBQXlEO0FBQ3pELGtCQUFFLFlBQVksVUFBWixJQUEwQixlQUFlLGFBQTNDLENBRkcsRUFFeUQ7QUFBRTs7QUFFOUQsK0JBQVcsaUJBQWlCLEtBQWpCLENBQXVCLE9BQWxDOztBQUVKO0FBQ0MsaUJBUE0sTUFPQTtBQUNILCtCQUFXLGlCQUFpQixLQUFqQixDQUF1QixFQUFsQztBQUNIOztBQUVEO0FBQ0EsMEJBQVksYUFBYyxRQUFRLE1BQVIsR0FBaUIsR0FBL0IsR0FBc0MsWUFBYSxlQUFlLEdBQXBFLEdBQTZFLGlCQUFpQixJQUFqQixDQUFzQixLQUFuRyxHQUEyRyxpQkFBaUIsSUFBakIsQ0FBc0IsS0FBM0k7O0FBRUE7QUFDQSxvQkFBSSxjQUFlLGFBQWEsWUFBaEM7QUFDQSxvQkFBSSxhQUFjLFlBQVksV0FBOUI7O0FBRUE7QUFDQSx3QkFBUSxLQUFSLEdBQWdCLFFBQWhCO0FBQ0Esd0JBQVEsSUFBUixHQUFlLE9BQWY7O0FBRUEsb0JBQUksYUFBSixFQUFtQjs7QUFFZix3QkFBSSxXQUFKLEVBQWlCO0FBQ2IsNEJBQUksY0FBYztBQUNkLG1DQUFRLFFBRE07QUFFZCxvQ0FBUTtBQUZNLHlCQUFsQjs7QUFLQSxnQ0FBUSxPQUFSLENBQWdCLE9BQWhCLEVBQXlCLFdBQXpCO0FBQ0EsZ0NBQVEsT0FBUixZQUF5QixRQUF6QixFQUFxQyxXQUFyQztBQUNBLCtCQUFLLE9BQUwsQ0FBYSxlQUFiLEVBQThCLFdBQTlCO0FBQ0g7O0FBRUQsd0JBQUksVUFBSixFQUFnQjs7QUFFWiw0QkFBSSxlQUFjO0FBQ2Qsa0NBQU8sT0FETztBQUVkLG9DQUFTO0FBRksseUJBQWxCOztBQUtBLGdDQUFRLE9BQVIsQ0FBZ0IsTUFBaEIsRUFBd0IsWUFBeEI7QUFDQSxnQ0FBUSxPQUFSLFdBQXdCLE9BQXhCLEVBQW1DLFlBQW5DO0FBQ0EsK0JBQUssT0FBTCxDQUFhLGNBQWIsRUFBNkIsWUFBN0I7QUFDSDtBQUNKO0FBRUosYUFuRUQ7QUFxRUg7O0FBR0Q7Ozs7QUFNQTs7Ozs2Q0FDcUIsSyxFQUFPO0FBQ3hCLGlCQUFLLE9BQUw7QUFDSDs7OzZDQUVvQixLLEVBQU87QUFDeEIsaUJBQUsscUJBQUw7QUFDSDs7Ozs7O0FBSUw7OztBQUNBLGlCQUFpQixLQUFqQixHQUF5QjtBQUNyQixRQUFJLElBRGlCO0FBRXJCLFNBQUssS0FGZ0I7QUFHckIsYUFBUztBQUhZLENBQXpCOztBQU1BO0FBQ0EsaUJBQWlCLElBQWpCLEdBQXdCO0FBQ3BCLFdBQU8sT0FEYTtBQUVwQixXQUFPO0FBRmEsQ0FBeEI7O0FBS0EsaUJBQWlCLFNBQWpCLEdBQTZCO0FBQ3pCLFFBQUksQ0FBQyxDQURvQjtBQUV6QixVQUFNO0FBRm1CLENBQTdCOztRQUs0QixPLEdBQXBCLGdCO1FBQTZCLE8sR0FBQSxPOzs7Ozs7Ozs7QUMzUnJDOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTtBQUNBLElBQU0sV0FBVyxDQUNiLFFBRGEsRUFFYixLQUZhLEVBR2IsSUFIYSxFQUliLEdBSmEsQ0FBakI7O0FBT0E7QUFDQSxJQUFNLHdCQUF3QixFQUE5Qjs7QUFFQTtBQUNBLElBQU0sZUFBZSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBckI7O0FBRUE7Ozs7Ozs7OztBQVNBLFNBQVMsY0FBVCxDQUF3QixRQUF4QixFQUFrQzs7QUFFOUI7QUFDQSxRQUFJLHFCQUFxQixDQUFDLFFBQUQsRUFBVyxNQUFYLENBQW1CLFNBQVMsR0FBVCxDQUFjO0FBQUEsZUFBVSxTQUFTLDBCQUFXLFFBQVgsQ0FBbkI7QUFBQSxLQUFkLENBQW5CLENBQXpCOztBQUVBO0FBQ0EsUUFBSSxtQkFBbUIsb0JBQUssa0JBQUwsRUFBeUIsVUFBQyxJQUFEO0FBQUEsZUFBVSxRQUFRLGFBQWEsS0FBL0I7QUFBQSxLQUF6QixDQUF2Qjs7QUFFQTtBQUNBLDBCQUFzQixRQUF0QixJQUFrQyxVQUFTLFdBQVQsRUFBc0IsS0FBdEIsRUFBNkI7QUFDM0Qsb0JBQVksZ0JBQVosSUFBZ0MsS0FBaEM7QUFDSCxLQUZEOztBQUlBLFdBQU8sc0JBQXNCLFFBQXRCLENBQVA7QUFDSDs7QUFFRDs7Ozs7O0FBTUEsSUFBTSxRQUFROztBQUVWOzs7Ozs7QUFNQSxTQUFNLGFBQVUsT0FBVixFQUFtQixVQUFuQixFQUErQjs7QUFFakMsWUFBSSxnQkFBa0IseUJBQVUsT0FBVixDQUFGLEdBQXlCLFFBQVEsS0FBakMsR0FBeUMsT0FBN0Q7O0FBRUE7QUFDQSxhQUFNLElBQUksSUFBVixJQUFrQixVQUFsQixFQUE4QjtBQUMxQixnQkFBSSxXQUFXLGNBQVgsQ0FBMEIsSUFBMUIsQ0FBSixFQUFxQzs7QUFFakM7QUFDQSxvQkFBSSxpQkFBaUIsV0FBVyxJQUFYLENBQXJCO0FBQ0Esb0JBQUksbUJBQUo7O0FBRUEsb0JBQUksbUJBQW1CLElBQXZCLEVBQTZCO0FBQ3pCLGlDQUFhLHdCQUFTLGNBQVQsSUFBMkIsY0FBM0IsR0FBNEMsS0FBSyxRQUFMLENBQWMsSUFBZCxFQUFvQixjQUFwQixDQUF6RDtBQUNILGlCQUZELE1BRU87QUFDSCxpQ0FBYSxJQUFiO0FBQ0g7O0FBRUQ7QUFDQSxpQkFBRSxzQkFBc0IsSUFBdEIsS0FBK0IsZUFBZSxJQUFmLENBQWpDLEVBQXdELGFBQXhELEVBQXVFLFVBQXZFO0FBQ0g7QUFDSjtBQUVKLEtBL0JTOztBQWlDVjs7Ozs7Ozs7O0FBU0EsU0FBTSxhQUFTLE9BQVQsRUFBa0IsUUFBbEIsRUFBNEI7QUFDOUIsZUFBTyxLQUFLLFVBQUwsQ0FBZ0IsUUFBaEIsRUFBMEIsT0FBTyxnQkFBUCxDQUF5QixPQUF6QixFQUFvQyxRQUFwQyxDQUExQixDQUFQO0FBQ0gsS0E1Q1M7O0FBOENWOzs7Ozs7OztBQVFBLGNBQVcsa0JBQVMsUUFBVCxFQUFtQixLQUFuQixFQUF3QztBQUFBLFlBQWQsS0FBYyx1RUFBTixJQUFNOzs7QUFFL0MsWUFBSSx1QkFBSjs7QUFFQSxnQkFBTyxRQUFQO0FBQ0ksaUJBQUssS0FBTDtBQUNBLGlCQUFLLE9BQUw7QUFDQSxpQkFBSyxRQUFMO0FBQ0EsaUJBQUssTUFBTDtBQUNBLGlCQUFLLFVBQUw7QUFDQSxpQkFBSyxXQUFMO0FBQ0EsaUJBQUssT0FBTDtBQUNBLGlCQUFLLFFBQUw7QUFDSSxpQ0FBaUIsTUFBTSxRQUFOLEtBQW1CLEtBQXBDO0FBQ0E7O0FBRUosaUJBQUssU0FBTDtBQUNJLGlDQUFpQixLQUFqQjtBQUNBO0FBZFI7O0FBaUJBO0FBQ0EsWUFBSyxtQkFBbUIsSUFBeEIsRUFBK0IsaUJBQWlCLEVBQWpCOztBQUUvQixlQUFPLGNBQVA7QUFDSCxLQS9FUzs7QUFpRlY7Ozs7Ozs7QUFPQSxnQkFBYSxvQkFBVSxRQUFWLEVBQW9CLEtBQXBCLEVBQTJCOztBQUVwQyxZQUFJLHVCQUFKOztBQUVBLGdCQUFPLFFBQVA7QUFDSSxpQkFBSyxLQUFMO0FBQ0EsaUJBQUssT0FBTDtBQUNBLGlCQUFLLFFBQUw7QUFDQSxpQkFBSyxNQUFMO0FBQ0EsaUJBQUssVUFBTDtBQUNBLGlCQUFLLFdBQUw7QUFDQSxpQkFBSyxPQUFMO0FBQ0EsaUJBQUssUUFBTDtBQUNBLGlCQUFLLFNBQUw7QUFDSSxpQ0FBaUIsV0FBWSxLQUFaLENBQWpCO0FBQ0E7QUFYUjs7QUFjQSxlQUFPLGNBQVA7QUFFSDs7QUE1R1MsQ0FBZDs7a0JBZ0hlLEs7Ozs7Ozs7Ozs7OztBQ2xLZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7Ozs7Ozs7QUFFQTtBQUNBLElBQU0sZUFBZSxTQUFmLFlBQWUsR0FBWTtBQUM3QixXQUFPLE9BQU8sV0FBUCxJQUFzQixTQUFTLGVBQVQsQ0FBeUIsU0FBL0MsSUFBNEQsU0FBUyxJQUFULENBQWMsU0FBMUUsSUFBdUYsQ0FBOUY7QUFDSCxDQUZEOztBQUlBLElBQU0sZ0JBQWdCLFNBQWhCLGFBQWdCLEdBQVk7QUFDOUIsV0FBTyxPQUFPLFdBQVAsSUFBc0IsU0FBUyxlQUFULENBQXlCLFVBQS9DLElBQTZELFNBQVMsSUFBVCxDQUFjLFVBQTNFLElBQXlGLENBQWhHO0FBQ0gsQ0FGRDs7QUFJQSxJQUFJLHNCQUFKOztJQUVNLGtCOzs7QUFFRixrQ0FBYztBQUFBOztBQUNWO0FBQ0EsWUFBSyxhQUFMLEVBQXFCO0FBQ2pCLGtCQUFNLElBQUksS0FBSixDQUFVLDBEQUFWLENBQU47QUFDSDs7QUFKUztBQU9iOztBQUVEOzs7Ozs7O21DQUtZLE0sRUFBUTs7QUFFaEIsZ0JBQUssQ0FBQyxLQUFLLFdBQVgsRUFBeUI7QUFDckIscUJBQUssTUFBTCxHQUFjLHdCQUFTLFVBQVUsRUFBbkIsRUFBdUIsbUJBQW1CLGFBQTFDLENBQWQ7O0FBRUE7Ozs7QUFJQSxxQkFBSyxXQUFMLEdBQW1CLEtBQUssTUFBTCxDQUFZLFdBQS9COztBQUVBO0FBQ0EscUJBQUssV0FBTCxDQUFpQixPQUFqQixDQUEwQjtBQUFBLDJCQUFNLE9BQU8sTUFBUCxDQUFjLEVBQWQsQ0FBTjtBQUFBLGlCQUExQjs7QUFFQTtBQUNBLHFCQUFLLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxxQkFBSyxVQUFMLENBQWdCLE1BQWhCLEdBQTBCLHdCQUFTLEtBQUssY0FBTCxDQUFvQixJQUFwQixDQUF5QixJQUF6QixDQUFULEVBQXlDLEtBQUssTUFBTCxDQUFZLGNBQXJELENBQTFCO0FBQ0EscUJBQUssVUFBTCxDQUFnQixJQUFoQixHQUEwQixLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBMUI7QUFDQSxxQkFBSyxVQUFMLENBQWdCLE1BQWhCLEdBQTBCLEtBQUssY0FBTCxDQUFvQixJQUFwQixDQUF5QixJQUF6QixDQUExQjtBQUNBLHFCQUFLLFVBQUwsQ0FBZ0IsTUFBaEIsR0FBMEIsd0JBQVUsS0FBSyxjQUFMLENBQW9CLElBQXBCLENBQXlCLElBQXpCLENBQVYsRUFBMEMsS0FBSyxNQUFMLENBQVksY0FBdEQsQ0FBMUI7O0FBRUE7QUFDQSx1QkFBTyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxLQUFLLFVBQUwsQ0FBZ0IsTUFBbEQ7QUFDQSx1QkFBTyxnQkFBUCxDQUF3QixNQUF4QixFQUFrQyxLQUFLLFVBQUwsQ0FBZ0IsSUFBbEQ7QUFDQSx1QkFBTyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxLQUFLLFVBQUwsQ0FBZ0IsTUFBbEQ7O0FBRUEscUJBQUssZUFBTDs7QUFFQTtBQUNBLHFCQUFLLGNBQUwsR0FBc0IsS0FBSyxjQUFMLElBQXVCLEVBQUMsS0FBSyxjQUFOLEVBQTdDOztBQUVBO0FBQ0EscUJBQUssY0FBTDtBQUNBLHFCQUFLLG9CQUFMOztBQUVBLHFCQUFLLGlCQUFMLENBQXVCLElBQXZCOztBQUVBLHFCQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFFSDtBQUVKOztBQUVEOzs7O0FBTUE7QUFDQTs7Ozs7OzBDQUdrQjtBQUNkLG1CQUFPLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDLEtBQUssVUFBTCxDQUFnQixNQUFsRDtBQUNIOztBQUVEOzs7Ozs7NENBR29CO0FBQ2hCLG1CQUFPLG1CQUFQLENBQTJCLFFBQTNCLEVBQXFDLEtBQUssVUFBTCxDQUFnQixNQUFyRDtBQUNIOztBQUVEOzs7Ozs7OzttQ0FLdUI7QUFBQSxnQkFBZCxDQUFjLHVFQUFWLENBQVU7QUFBQSxnQkFBUCxDQUFPLHVFQUFILENBQUc7OztBQUVuQixpQkFBSyxjQUFMLENBQW9CLEdBQXBCLEdBQTBCLENBQTFCO0FBQ0EsaUJBQUssY0FBTCxDQUFvQixJQUFwQixHQUEyQixDQUEzQjs7QUFFQSxtQkFBTyxRQUFQLENBQWdCLENBQWhCLEVBQW1CLENBQW5CO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7aUNBT1MsVSxFQUFZOztBQUVqQjtBQUNBLGdCQUFJLHdCQUFKO0FBQ0EsZ0JBQUssd0JBQVMsVUFBVCxDQUFMLEVBQTRCO0FBQ3hCLGtDQUFrQixVQUFsQjtBQUNILGFBRkQsTUFFTyxJQUFLLHdCQUFTLFVBQVQsQ0FBTCxFQUE0QjtBQUMvQixrQ0FBa0Isb0JBQU0sS0FBSyxXQUFYLEVBQXdCLEVBQUMsTUFBTSxVQUFQLEVBQXhCLEVBQTRDLEtBQTlEO0FBQ0gsYUFGTSxNQUVBLElBQUssd0JBQVMsVUFBVCxDQUFMLEVBQTRCO0FBQy9CLGtDQUFrQixXQUFXLEtBQTdCO0FBQ0g7O0FBRUQsbUJBQU8sS0FBSyxLQUFMLElBQWMsZUFBckI7QUFDSDs7QUFFRDs7O0FBS0E7Ozs7Ozs7eUNBSWlCO0FBQ2IsaUJBQUssS0FBTCxHQUFhLE9BQU8sVUFBcEI7QUFDQSxpQkFBSyxNQUFMLEdBQWMsT0FBTyxXQUFyQjtBQUNIOztBQUVEOzs7Ozs7OytDQUl1QjtBQUNuQixpQkFBSyxjQUFMLENBQW9CLEdBQXBCLEdBQTBCLGNBQTFCO0FBQ0EsaUJBQUssY0FBTCxDQUFvQixJQUFwQixHQUEyQixlQUEzQjtBQUNIOztBQUVEOzs7Ozs7Ozs7NENBTTBDO0FBQUE7O0FBQUEsZ0JBQXhCLGNBQXdCLHVFQUFQLEtBQU87OztBQUV0QztBQUNBLGdCQUFJLGFBQWEsd0JBQVMsS0FBSyxXQUFkLEVBQTJCLFVBQUMsRUFBRCxFQUFRO0FBQ2hELHVCQUFPLE9BQUssS0FBTCxJQUFjLEdBQUcsS0FBeEI7QUFDSCxhQUZnQixDQUFqQjs7QUFJQTtBQUNBLGdCQUFJLEtBQUssaUJBQUwsS0FBMkIsVUFBL0IsRUFBMkM7QUFDdkMsb0JBQUkscUJBQXFCLEtBQUssaUJBQTlCO0FBQ0EscUJBQUssaUJBQUwsR0FBeUIsVUFBekI7O0FBRUE7QUFDQSxvQkFBSSxDQUFDLGNBQUwsRUFBcUI7QUFDakIseUJBQUssT0FBTCxDQUFhLFlBQWIsRUFBMkIsRUFBQyxZQUFZLFVBQWIsRUFBeUIsVUFBVyxrQkFBcEMsRUFBM0IsRUFEaUIsQ0FDb0U7QUFDeEY7QUFDSjtBQUVKOztBQUVEOzs7QUFLQTs7Ozs7Ozs7dUNBS2UsSyxFQUFPO0FBQ2xCLGdCQUFJLGNBQWMsS0FBSyxjQUFMLENBQW9CLEdBQXRDO0FBQ0EsaUJBQUssb0JBQUw7QUFDQSxnQkFBSSxhQUFhLEtBQUssY0FBTCxDQUFvQixHQUFyQzs7QUFFQTtBQUNBLGdCQUFJLFlBQWEsY0FBYyxVQUFmLEdBQTZCLENBQTdCLEdBQWlDLENBQUMsQ0FBbEQ7O0FBRUE7QUFDQSxpQkFBSyxPQUFMLENBQWEsUUFBYixFQUF1QixFQUFDLGdCQUFnQixLQUFLLGNBQXRCLEVBQXNDLFdBQVksU0FBbEQsRUFBNkQsZUFBZSxLQUE1RSxFQUF2QjtBQUNIOztBQUVEOzs7Ozs7O3lDQUlpQjtBQUNiLGlCQUFLLGNBQUw7QUFDQSxpQkFBSyxPQUFMLENBQWEsUUFBYixFQUF1QixFQUFDLE9BQU8sS0FBSyxLQUFiLEVBQW9CLFFBQVEsS0FBSyxNQUFqQyxFQUF2QjtBQUNBLGlCQUFLLGlCQUFMO0FBQ0g7O0FBRUQ7Ozs7Ozs7eUNBSWlCO0FBQ2IsaUJBQUssT0FBTCxDQUFhLFFBQWI7QUFDSDs7QUFFRDs7Ozs7Ozt1Q0FJZTtBQUNYLGlCQUFLLE9BQUwsQ0FBYSxNQUFiO0FBQ0g7Ozs7OztBQUlMLG1CQUFtQixhQUFuQixHQUFtQztBQUMvQixvQkFBZ0IsRUFEZSxFQUNYO0FBQ3BCLG9CQUFnQixFQUZlLEVBRVg7QUFDcEIsd0JBQW9CLElBSFcsRUFHTDtBQUMxQiwyQkFBdUIsSUFKUSxDQUlGO0FBSkUsQ0FBbkM7O0FBT0E7QUFDQSxRQUd5QixPQUh6QixtQkFBZ0IsSUFBSSxrQkFBSixFQUFoQjs7QUFFQTtRQUN5QixPLEdBQWpCLGE7UUFBMEIsa0IsR0FBQSxrQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKlxuIDIwMTcgSnVsaWFuIEdhcm5pZXJcbiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiovXG52YXIgJGpzY29tcCR0aGlzPXRoaXM7XG4oZnVuY3Rpb24odixwKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxwKTpcIm9iamVjdFwiPT09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9cCgpOnYuYW5pbWU9cCgpfSkodGhpcyxmdW5jdGlvbigpe2Z1bmN0aW9uIHYoYSl7aWYoIWcuY29sKGEpKXRyeXtyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChhKX1jYXRjaChiKXt9fWZ1bmN0aW9uIHAoYSl7cmV0dXJuIGEucmVkdWNlKGZ1bmN0aW9uKGEsZCl7cmV0dXJuIGEuY29uY2F0KGcuYXJyKGQpP3AoZCk6ZCl9LFtdKX1mdW5jdGlvbiB3KGEpe2lmKGcuYXJyKGEpKXJldHVybiBhO2cuc3RyKGEpJiYoYT12KGEpfHxhKTtyZXR1cm4gYSBpbnN0YW5jZW9mIE5vZGVMaXN0fHxhIGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24/W10uc2xpY2UuY2FsbChhKTpbYV19ZnVuY3Rpb24gRihhLGIpe3JldHVybiBhLnNvbWUoZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1ifSl9XG5mdW5jdGlvbiBBKGEpe3ZhciBiPXt9LGQ7Zm9yKGQgaW4gYSliW2RdPWFbZF07cmV0dXJuIGJ9ZnVuY3Rpb24gRyhhLGIpe3ZhciBkPUEoYSksYztmb3IoYyBpbiBhKWRbY109Yi5oYXNPd25Qcm9wZXJ0eShjKT9iW2NdOmFbY107cmV0dXJuIGR9ZnVuY3Rpb24gQihhLGIpe3ZhciBkPUEoYSksYztmb3IoYyBpbiBiKWRbY109Zy51bmQoYVtjXSk/YltjXTphW2NdO3JldHVybiBkfWZ1bmN0aW9uIFMoYSl7YT1hLnJlcGxhY2UoL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaSxmdW5jdGlvbihhLGIsZCxoKXtyZXR1cm4gYitiK2QrZCtoK2h9KTt2YXIgYj0vXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoYSk7YT1wYXJzZUludChiWzFdLDE2KTt2YXIgZD1wYXJzZUludChiWzJdLDE2KSxiPXBhcnNlSW50KGJbM10sMTYpO3JldHVyblwicmdiKFwiK2ErXCIsXCIrZCtcIixcIitiK1wiKVwifWZ1bmN0aW9uIFQoYSl7ZnVuY3Rpb24gYihhLGIsYyl7MD5cbmMmJihjKz0xKTsxPGMmJi0tYztyZXR1cm4gYzwxLzY/YSs2KihiLWEpKmM6LjU+Yz9iOmM8Mi8zP2ErKGItYSkqKDIvMy1jKSo2OmF9dmFyIGQ9L2hzbFxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJVxcKS9nLmV4ZWMoYSk7YT1wYXJzZUludChkWzFdKS8zNjA7dmFyIGM9cGFyc2VJbnQoZFsyXSkvMTAwLGQ9cGFyc2VJbnQoZFszXSkvMTAwO2lmKDA9PWMpYz1kPWE9ZDtlbHNle3ZhciBlPS41PmQ/ZCooMStjKTpkK2MtZCpjLGw9MipkLWUsYz1iKGwsZSxhKzEvMyksZD1iKGwsZSxhKTthPWIobCxlLGEtMS8zKX1yZXR1cm5cInJnYihcIisyNTUqYytcIixcIisyNTUqZCtcIixcIisyNTUqYStcIilcIn1mdW5jdGlvbiB4KGEpe2lmKGE9LyhbXFwrXFwtXT9bMC05I1xcLl0rKSglfHB4fHB0fGVtfHJlbXxpbnxjbXxtbXxleHxwY3x2d3x2aHxkZWd8cmFkfHR1cm4pPy8uZXhlYyhhKSlyZXR1cm4gYVsyXX1mdW5jdGlvbiBVKGEpe2lmKC0xPGEuaW5kZXhPZihcInRyYW5zbGF0ZVwiKSlyZXR1cm5cInB4XCI7XG5pZigtMTxhLmluZGV4T2YoXCJyb3RhdGVcIil8fC0xPGEuaW5kZXhPZihcInNrZXdcIikpcmV0dXJuXCJkZWdcIn1mdW5jdGlvbiBIKGEsYil7cmV0dXJuIGcuZm5jKGEpP2EoYi50YXJnZXQsYi5pZCxiLnRvdGFsKTphfWZ1bmN0aW9uIEMoYSxiKXtpZihiIGluIGEuc3R5bGUpcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoYSkuZ2V0UHJvcGVydHlWYWx1ZShiLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpKXx8XCIwXCJ9ZnVuY3Rpb24gSShhLGIpe2lmKGcuZG9tKGEpJiZGKFYsYikpcmV0dXJuXCJ0cmFuc2Zvcm1cIjtpZihnLmRvbShhKSYmKGEuZ2V0QXR0cmlidXRlKGIpfHxnLnN2ZyhhKSYmYVtiXSkpcmV0dXJuXCJhdHRyaWJ1dGVcIjtpZihnLmRvbShhKSYmXCJ0cmFuc2Zvcm1cIiE9PWImJkMoYSxiKSlyZXR1cm5cImNzc1wiO2lmKG51bGwhPWFbYl0pcmV0dXJuXCJvYmplY3RcIn1mdW5jdGlvbiBXKGEsYil7dmFyIGQ9VShiKSxkPS0xPGIuaW5kZXhPZihcInNjYWxlXCIpP1xuMTowK2Q7YT1hLnN0eWxlLnRyYW5zZm9ybTtpZighYSlyZXR1cm4gZDtmb3IodmFyIGM9W10sZT1bXSxsPVtdLGg9LyhcXHcrKVxcKCguKz8pXFwpL2c7Yz1oLmV4ZWMoYSk7KWUucHVzaChjWzFdKSxsLnB1c2goY1syXSk7YT1sLmZpbHRlcihmdW5jdGlvbihhLGMpe3JldHVybiBlW2NdPT09Yn0pO3JldHVybiBhLmxlbmd0aD9hWzBdOmR9ZnVuY3Rpb24gSihhLGIpe3N3aXRjaChJKGEsYikpe2Nhc2UgXCJ0cmFuc2Zvcm1cIjpyZXR1cm4gVyhhLGIpO2Nhc2UgXCJjc3NcIjpyZXR1cm4gQyhhLGIpO2Nhc2UgXCJhdHRyaWJ1dGVcIjpyZXR1cm4gYS5nZXRBdHRyaWJ1dGUoYil9cmV0dXJuIGFbYl18fDB9ZnVuY3Rpb24gSyhhLGIpe3ZhciBkPS9eKFxcKj18XFwrPXwtPSkvLmV4ZWMoYSk7aWYoIWQpcmV0dXJuIGE7Yj1wYXJzZUZsb2F0KGIpO2E9cGFyc2VGbG9hdChhLnJlcGxhY2UoZFswXSxcIlwiKSk7c3dpdGNoKGRbMF1bMF0pe2Nhc2UgXCIrXCI6cmV0dXJuIGIrYTtjYXNlIFwiLVwiOnJldHVybiBiLWE7Y2FzZSBcIipcIjpyZXR1cm4gYipcbmF9fWZ1bmN0aW9uIEQoYSl7cmV0dXJuIGcub2JqKGEpJiZhLmhhc093blByb3BlcnR5KFwidG90YWxMZW5ndGhcIil9ZnVuY3Rpb24gWChhLGIpe2Z1bmN0aW9uIGQoYyl7Yz12b2lkIDA9PT1jPzA6YztyZXR1cm4gYS5lbC5nZXRQb2ludEF0TGVuZ3RoKDE8PWIrYz9iK2M6MCl9dmFyIGM9ZCgpLGU9ZCgtMSksbD1kKDEpO3N3aXRjaChhLnByb3BlcnR5KXtjYXNlIFwieFwiOnJldHVybiBjLng7Y2FzZSBcInlcIjpyZXR1cm4gYy55O2Nhc2UgXCJhbmdsZVwiOnJldHVybiAxODAqTWF0aC5hdGFuMihsLnktZS55LGwueC1lLngpL01hdGguUEl9fWZ1bmN0aW9uIEwoYSxiKXt2YXIgZD0vLT9cXGQqXFwuP1xcZCsvZzthPUQoYSk/YS50b3RhbExlbmd0aDphO2lmKGcuY29sKGEpKWI9Zy5yZ2IoYSk/YTpnLmhleChhKT9TKGEpOmcuaHNsKGEpP1QoYSk6dm9pZCAwO2Vsc2V7dmFyIGM9eChhKTthPWM/YS5zdWJzdHIoMCxhLmxlbmd0aC1jLmxlbmd0aCk6YTtiPWI/YStiOmF9Yis9XCJcIjtyZXR1cm57b3JpZ2luYWw6Yixcbm51bWJlcnM6Yi5tYXRjaChkKT9iLm1hdGNoKGQpLm1hcChOdW1iZXIpOlswXSxzdHJpbmdzOmIuc3BsaXQoZCl9fWZ1bmN0aW9uIFkoYSxiKXtyZXR1cm4gYi5yZWR1Y2UoZnVuY3Rpb24oYixjLGUpe3JldHVybiBiK2FbZS0xXStjfSl9ZnVuY3Rpb24gTShhKXtyZXR1cm4oYT9wKGcuYXJyKGEpP2EubWFwKHcpOncoYSkpOltdKS5maWx0ZXIoZnVuY3Rpb24oYSxkLGMpe3JldHVybiBjLmluZGV4T2YoYSk9PT1kfSl9ZnVuY3Rpb24gWihhKXt2YXIgYj1NKGEpO3JldHVybiBiLm1hcChmdW5jdGlvbihhLGMpe3JldHVybnt0YXJnZXQ6YSxpZDpjLHRvdGFsOmIubGVuZ3RofX0pfWZ1bmN0aW9uIGFhKGEsYil7dmFyIGQ9QShiKTtpZihnLmFycihhKSl7dmFyIGM9YS5sZW5ndGg7MiE9PWN8fGcub2JqKGFbMF0pP2cuZm5jKGIuZHVyYXRpb24pfHwoZC5kdXJhdGlvbj1iLmR1cmF0aW9uL2MpOmE9e3ZhbHVlOmF9fXJldHVybiB3KGEpLm1hcChmdW5jdGlvbihhLGMpe2M9Yz8wOmIuZGVsYXk7XG5hPWcub2JqKGEpJiYhRChhKT9hOnt2YWx1ZTphfTtnLnVuZChhLmRlbGF5KSYmKGEuZGVsYXk9Yyk7cmV0dXJuIGF9KS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIEIoYSxkKX0pfWZ1bmN0aW9uIGJhKGEsYil7dmFyIGQ9e30sYztmb3IoYyBpbiBhKXt2YXIgZT1IKGFbY10sYik7Zy5hcnIoZSkmJihlPWUubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBIKGEsYil9KSwxPT09ZS5sZW5ndGgmJihlPWVbMF0pKTtkW2NdPWV9ZC5kdXJhdGlvbj1wYXJzZUZsb2F0KGQuZHVyYXRpb24pO2QuZGVsYXk9cGFyc2VGbG9hdChkLmRlbGF5KTtyZXR1cm4gZH1mdW5jdGlvbiBjYShhKXtyZXR1cm4gZy5hcnIoYSk/eS5hcHBseSh0aGlzLGEpOk5bYV19ZnVuY3Rpb24gZGEoYSxiKXt2YXIgZDtyZXR1cm4gYS50d2VlbnMubWFwKGZ1bmN0aW9uKGMpe2M9YmEoYyxiKTt2YXIgZT1jLnZhbHVlLGw9SihiLnRhcmdldCxhLm5hbWUpLGg9ZD9kLnRvLm9yaWdpbmFsOmwsaD1nLmFycihlKT9lWzBdOmgsbT1LKGcuYXJyKGUpP1xuZVsxXTplLGgpLGw9eChtKXx8eChoKXx8eChsKTtjLmlzUGF0aD1EKGUpO2MuZnJvbT1MKGgsbCk7Yy50bz1MKG0sbCk7Yy5zdGFydD1kP2QuZW5kOmEub2Zmc2V0O2MuZW5kPWMuc3RhcnQrYy5kZWxheStjLmR1cmF0aW9uO2MuZWFzaW5nPWNhKGMuZWFzaW5nKTtjLmVsYXN0aWNpdHk9KDFFMy1NYXRoLm1pbihNYXRoLm1heChjLmVsYXN0aWNpdHksMSksOTk5KSkvMUUzO2cuY29sKGMuZnJvbS5vcmlnaW5hbCkmJihjLnJvdW5kPTEpO3JldHVybiBkPWN9KX1mdW5jdGlvbiBlYShhLGIpe3JldHVybiBwKGEubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBiLm1hcChmdW5jdGlvbihiKXt2YXIgYz1JKGEudGFyZ2V0LGIubmFtZSk7aWYoYyl7dmFyIGQ9ZGEoYixhKTtiPXt0eXBlOmMscHJvcGVydHk6Yi5uYW1lLGFuaW1hdGFibGU6YSx0d2VlbnM6ZCxkdXJhdGlvbjpkW2QubGVuZ3RoLTFdLmVuZCxkZWxheTpkWzBdLmRlbGF5fX1lbHNlIGI9dm9pZCAwO3JldHVybiBifSl9KSkuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiFnLnVuZChhKX0pfVxuZnVuY3Rpb24gTyhhLGIsZCl7dmFyIGM9XCJkZWxheVwiPT09YT9NYXRoLm1pbjpNYXRoLm1heDtyZXR1cm4gYi5sZW5ndGg/Yy5hcHBseShNYXRoLGIubWFwKGZ1bmN0aW9uKGIpe3JldHVybiBiW2FdfSkpOmRbYV19ZnVuY3Rpb24gZmEoYSl7dmFyIGI9RyhnYSxhKSxkPUcoaGEsYSksYz1aKGEudGFyZ2V0cyksZT1bXSxnPUIoYixkKSxoO2ZvcihoIGluIGEpZy5oYXNPd25Qcm9wZXJ0eShoKXx8XCJ0YXJnZXRzXCI9PT1ofHxlLnB1c2goe25hbWU6aCxvZmZzZXQ6Zy5vZmZzZXQsdHdlZW5zOmFhKGFbaF0sZCl9KTthPWVhKGMsZSk7cmV0dXJuIEIoYix7Y2hpbGRyZW46W10sYW5pbWF0YWJsZXM6YyxhbmltYXRpb25zOmEsZHVyYXRpb246TyhcImR1cmF0aW9uXCIsYSxkKSxkZWxheTpPKFwiZGVsYXlcIixhLGQpfSl9ZnVuY3Rpb24gbihhKXtmdW5jdGlvbiBiKCl7cmV0dXJuIHdpbmRvdy5Qcm9taXNlJiZuZXcgUHJvbWlzZShmdW5jdGlvbihhKXtyZXR1cm4gUT1hfSl9ZnVuY3Rpb24gZChhKXtyZXR1cm4gZi5yZXZlcnNlZD9cbmYuZHVyYXRpb24tYTphfWZ1bmN0aW9uIGMoYSl7Zm9yKHZhciBiPTAsYz17fSxkPWYuYW5pbWF0aW9ucyxlPXt9O2I8ZC5sZW5ndGg7KXt2YXIgZz1kW2JdLGg9Zy5hbmltYXRhYmxlLG09Zy50d2VlbnM7ZS50d2Vlbj1tLmZpbHRlcihmdW5jdGlvbihiKXtyZXR1cm4gYTxiLmVuZH0pWzBdfHxtW20ubGVuZ3RoLTFdO2UuaXNQYXRoJDE9ZS50d2Vlbi5pc1BhdGg7ZS5yb3VuZD1lLnR3ZWVuLnJvdW5kO2UuZWFzZWQ9ZS50d2Vlbi5lYXNpbmcoTWF0aC5taW4oTWF0aC5tYXgoYS1lLnR3ZWVuLnN0YXJ0LWUudHdlZW4uZGVsYXksMCksZS50d2Vlbi5kdXJhdGlvbikvZS50d2Vlbi5kdXJhdGlvbixlLnR3ZWVuLmVsYXN0aWNpdHkpO209WShlLnR3ZWVuLnRvLm51bWJlcnMubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiLGMpe2M9YS5pc1BhdGgkMT8wOmEudHdlZW4uZnJvbS5udW1iZXJzW2NdO2I9YythLmVhc2VkKihiLWMpO2EuaXNQYXRoJDEmJihiPVgoYS50d2Vlbi52YWx1ZSxcbmIpKTthLnJvdW5kJiYoYj1NYXRoLnJvdW5kKGIqYS5yb3VuZCkvYS5yb3VuZCk7cmV0dXJuIGJ9fShlKSksZS50d2Vlbi50by5zdHJpbmdzKTtpYVtnLnR5cGVdKGgudGFyZ2V0LGcucHJvcGVydHksbSxjLGguaWQpO2cuY3VycmVudFZhbHVlPW07YisrO2U9e2lzUGF0aCQxOmUuaXNQYXRoJDEsdHdlZW46ZS50d2VlbixlYXNlZDplLmVhc2VkLHJvdW5kOmUucm91bmR9fWlmKGMpZm9yKHZhciBrIGluIGMpRXx8KEU9Qyhkb2N1bWVudC5ib2R5LFwidHJhbnNmb3JtXCIpP1widHJhbnNmb3JtXCI6XCItd2Via2l0LXRyYW5zZm9ybVwiKSxmLmFuaW1hdGFibGVzW2tdLnRhcmdldC5zdHlsZVtFXT1jW2tdLmpvaW4oXCIgXCIpO2YuY3VycmVudFRpbWU9YTtmLnByb2dyZXNzPWEvZi5kdXJhdGlvbioxMDB9ZnVuY3Rpb24gZShhKXtpZihmW2FdKWZbYV0oZil9ZnVuY3Rpb24gZygpe2YucmVtYWluaW5nJiYhMCE9PWYucmVtYWluaW5nJiZmLnJlbWFpbmluZy0tfWZ1bmN0aW9uIGgoYSl7dmFyIGg9Zi5kdXJhdGlvbixcbmw9Zi5vZmZzZXQsbj1mLmRlbGF5LFA9Zi5jdXJyZW50VGltZSxxPWYucmV2ZXJzZWQscj1kKGEpLHI9TWF0aC5taW4oTWF0aC5tYXgociwwKSxoKTtpZihmLmNoaWxkcmVuKXt2YXIgcD1mLmNoaWxkcmVuO2lmKHI+PWYuY3VycmVudFRpbWUpZm9yKHZhciB1PTA7dTxwLmxlbmd0aDt1KyspcFt1XS5zZWVrKHIpO2Vsc2UgZm9yKHU9cC5sZW5ndGg7dS0tOylwW3VdLnNlZWsocil9cj5sJiZyPGg/KGMociksIWYuYmVnYW4mJnI+PW4mJihmLmJlZ2FuPSEwLGUoXCJiZWdpblwiKSksZShcInJ1blwiKSk6KHI8PWwmJjAhPT1QJiYoYygwKSxxJiZnKCkpLHI+PWgmJlAhPT1oJiYoYyhoKSxxfHxnKCkpKTthPj1oJiYoZi5yZW1haW5pbmc/KHQ9bSxcImFsdGVybmF0ZVwiPT09Zi5kaXJlY3Rpb24mJihmLnJldmVyc2VkPSFmLnJldmVyc2VkKSk6KGYucGF1c2UoKSxcIlByb21pc2VcImluIHdpbmRvdyYmKFEoKSxSPWIoKSksZi5jb21wbGV0ZWR8fChmLmNvbXBsZXRlZD0hMCxlKFwiY29tcGxldGVcIikpKSxcbms9MCk7ZShcInVwZGF0ZVwiKX1hPXZvaWQgMD09PWE/e306YTt2YXIgbSx0LGs9MCxRPW51bGwsUj1iKCksZj1mYShhKTtmLnJlc2V0PWZ1bmN0aW9uKCl7dmFyIGE9Zi5kaXJlY3Rpb24sYj1mLmxvb3A7Zi5jdXJyZW50VGltZT0wO2YucHJvZ3Jlc3M9MDtmLnBhdXNlZD0hMDtmLmJlZ2FuPSExO2YuY29tcGxldGVkPSExO2YucmV2ZXJzZWQ9XCJyZXZlcnNlXCI9PT1hO2YucmVtYWluaW5nPVwiYWx0ZXJuYXRlXCI9PT1hJiYxPT09Yj8yOmI7Zm9yKGE9Zi5jaGlsZHJlbi5sZW5ndGg7YS0tOyliPWYuY2hpbGRyZW5bYV0sYi5zZWVrKGIub2Zmc2V0KSxiLnJlc2V0KCl9O2YudGljaz1mdW5jdGlvbihhKXttPWE7dHx8KHQ9bSk7aCgoayttLXQpKm4uc3BlZWQpfTtmLnNlZWs9ZnVuY3Rpb24oYSl7aChkKGEpKX07Zi5wYXVzZT1mdW5jdGlvbigpe3ZhciBhPXEuaW5kZXhPZihmKTstMTxhJiZxLnNwbGljZShhLDEpO2YucGF1c2VkPSEwfTtmLnBsYXk9ZnVuY3Rpb24oKXtmLnBhdXNlZCYmKGYucGF1c2VkPVxuITEsdD0wLGs9ZChmLmN1cnJlbnRUaW1lKSxxLnB1c2goZiksenx8amEoKSl9O2YucmV2ZXJzZT1mdW5jdGlvbigpe2YucmV2ZXJzZWQ9IWYucmV2ZXJzZWQ7dD0wO2s9ZChmLmN1cnJlbnRUaW1lKX07Zi5yZXN0YXJ0PWZ1bmN0aW9uKCl7Zi5wYXVzZSgpO2YucmVzZXQoKTtmLnBsYXkoKX07Zi5maW5pc2hlZD1SO2YucmVzZXQoKTtmLmF1dG9wbGF5JiZmLnBsYXkoKTtyZXR1cm4gZn12YXIgZ2E9e3VwZGF0ZTp2b2lkIDAsYmVnaW46dm9pZCAwLHJ1bjp2b2lkIDAsY29tcGxldGU6dm9pZCAwLGxvb3A6MSxkaXJlY3Rpb246XCJub3JtYWxcIixhdXRvcGxheTohMCxvZmZzZXQ6MH0saGE9e2R1cmF0aW9uOjFFMyxkZWxheTowLGVhc2luZzpcImVhc2VPdXRFbGFzdGljXCIsZWxhc3RpY2l0eTo1MDAscm91bmQ6MH0sVj1cInRyYW5zbGF0ZVggdHJhbnNsYXRlWSB0cmFuc2xhdGVaIHJvdGF0ZSByb3RhdGVYIHJvdGF0ZVkgcm90YXRlWiBzY2FsZSBzY2FsZVggc2NhbGVZIHNjYWxlWiBza2V3WCBza2V3WVwiLnNwbGl0KFwiIFwiKSxcbkUsZz17YXJyOmZ1bmN0aW9uKGEpe3JldHVybiBBcnJheS5pc0FycmF5KGEpfSxvYmo6ZnVuY3Rpb24oYSl7cmV0dXJuLTE8T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpLmluZGV4T2YoXCJPYmplY3RcIil9LHN2ZzpmdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnR9LGRvbTpmdW5jdGlvbihhKXtyZXR1cm4gYS5ub2RlVHlwZXx8Zy5zdmcoYSl9LHN0cjpmdW5jdGlvbihhKXtyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGF9LGZuYzpmdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYX0sdW5kOmZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCI9PT10eXBlb2YgYX0saGV4OmZ1bmN0aW9uKGEpe3JldHVybi8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGEpfSxyZ2I6ZnVuY3Rpb24oYSl7cmV0dXJuL15yZ2IvLnRlc3QoYSl9LGhzbDpmdW5jdGlvbihhKXtyZXR1cm4vXmhzbC8udGVzdChhKX0sY29sOmZ1bmN0aW9uKGEpe3JldHVybiBnLmhleChhKXx8XG5nLnJnYihhKXx8Zy5oc2woYSl9fSx5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGQsYyl7cmV0dXJuKCgoMS0zKmMrMypkKSphKygzKmMtNipkKSkqYSszKmQpKmF9cmV0dXJuIGZ1bmN0aW9uKGIsZCxjLGUpe2lmKDA8PWImJjE+PWImJjA8PWMmJjE+PWMpe3ZhciBnPW5ldyBGbG9hdDMyQXJyYXkoMTEpO2lmKGIhPT1kfHxjIT09ZSlmb3IodmFyIGg9MDsxMT5oOysraClnW2hdPWEoLjEqaCxiLGMpO3JldHVybiBmdW5jdGlvbihoKXtpZihiPT09ZCYmYz09PWUpcmV0dXJuIGg7aWYoMD09PWgpcmV0dXJuIDA7aWYoMT09PWgpcmV0dXJuIDE7Zm9yKHZhciBtPTAsaz0xOzEwIT09ayYmZ1trXTw9aDsrK2spbSs9LjE7LS1rO3ZhciBrPW0rKGgtZ1trXSkvKGdbaysxXS1nW2tdKSouMSxsPTMqKDEtMypjKzMqYikqayprKzIqKDMqYy02KmIpKmsrMypiO2lmKC4wMDE8PWwpe2ZvcihtPTA7ND5tOysrbSl7bD0zKigxLTMqYyszKmIpKmsqaysyKigzKmMtNipiKSprKzMqYjtpZigwPT09bClicmVhaztcbnZhciBuPWEoayxiLGMpLWgsaz1rLW4vbH1oPWt9ZWxzZSBpZigwPT09bCloPWs7ZWxzZXt2YXIgaz1tLG09bSsuMSxmPTA7ZG8gbj1rKyhtLWspLzIsbD1hKG4sYixjKS1oLDA8bD9tPW46az1uO3doaWxlKDFlLTc8TWF0aC5hYnMobCkmJjEwPisrZik7aD1ufXJldHVybiBhKGgsZCxlKX19fX0oKSxOPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIpe3JldHVybiAwPT09YXx8MT09PWE/YTotTWF0aC5wb3coMiwxMCooYS0xKSkqTWF0aC5zaW4oMiooYS0xLWIvKDIqTWF0aC5QSSkqTWF0aC5hc2luKDEpKSpNYXRoLlBJL2IpfXZhciBiPVwiUXVhZCBDdWJpYyBRdWFydCBRdWludCBTaW5lIEV4cG8gQ2lyYyBCYWNrIEVsYXN0aWNcIi5zcGxpdChcIiBcIiksZD17SW46W1suNTUsLjA4NSwuNjgsLjUzXSxbLjU1LC4wNTUsLjY3NSwuMTldLFsuODk1LC4wMywuNjg1LC4yMl0sWy43NTUsLjA1LC44NTUsLjA2XSxbLjQ3LDAsLjc0NSwuNzE1XSxbLjk1LC4wNSwuNzk1LC4wMzVdLFsuNiwuMDQsLjk4LFxuLjMzNV0sWy42LC0uMjgsLjczNSwuMDQ1XSxhXSxPdXQ6W1suMjUsLjQ2LC40NSwuOTRdLFsuMjE1LC42MSwuMzU1LDFdLFsuMTY1LC44NCwuNDQsMV0sWy4yMywxLC4zMiwxXSxbLjM5LC41NzUsLjU2NSwxXSxbLjE5LDEsLjIyLDFdLFsuMDc1LC44MiwuMTY1LDFdLFsuMTc1LC44ODUsLjMyLDEuMjc1XSxmdW5jdGlvbihiLGMpe3JldHVybiAxLWEoMS1iLGMpfV0sSW5PdXQ6W1suNDU1LC4wMywuNTE1LC45NTVdLFsuNjQ1LC4wNDUsLjM1NSwxXSxbLjc3LDAsLjE3NSwxXSxbLjg2LDAsLjA3LDFdLFsuNDQ1LC4wNSwuNTUsLjk1XSxbMSwwLDAsMV0sWy43ODUsLjEzNSwuMTUsLjg2XSxbLjY4LC0uNTUsLjI2NSwxLjU1XSxmdW5jdGlvbihiLGMpe3JldHVybi41PmI/YSgyKmIsYykvMjoxLWEoLTIqYisyLGMpLzJ9XX0sYz17bGluZWFyOnkoLjI1LC4yNSwuNzUsLjc1KX0sZT17fSxsO2ZvcihsIGluIGQpZS50eXBlPWwsZFtlLnR5cGVdLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGQsXG5lKXtjW1wiZWFzZVwiK2EudHlwZStiW2VdXT1nLmZuYyhkKT9kOnkuYXBwbHkoJGpzY29tcCR0aGlzLGQpfX0oZSkpLGU9e3R5cGU6ZS50eXBlfTtyZXR1cm4gY30oKSxpYT17Y3NzOmZ1bmN0aW9uKGEsYixkKXtyZXR1cm4gYS5zdHlsZVtiXT1kfSxhdHRyaWJ1dGU6ZnVuY3Rpb24oYSxiLGQpe3JldHVybiBhLnNldEF0dHJpYnV0ZShiLGQpfSxvYmplY3Q6ZnVuY3Rpb24oYSxiLGQpe3JldHVybiBhW2JdPWR9LHRyYW5zZm9ybTpmdW5jdGlvbihhLGIsZCxjLGUpe2NbZV18fChjW2VdPVtdKTtjW2VdLnB1c2goYitcIihcIitkK1wiKVwiKX19LHE9W10sej0wLGphPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3o9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGIpfWZ1bmN0aW9uIGIoYil7dmFyIGM9cS5sZW5ndGg7aWYoYyl7Zm9yKHZhciBkPTA7ZDxjOylxW2RdJiZxW2RdLnRpY2soYiksZCsrO2EoKX1lbHNlIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHopLHo9MH1yZXR1cm4gYX0oKTtuLnZlcnNpb249XCIyLjAuMlwiO1xubi5zcGVlZD0xO24ucnVubmluZz1xO24ucmVtb3ZlPWZ1bmN0aW9uKGEpe2E9TShhKTtmb3IodmFyIGI9cS5sZW5ndGg7Yi0tOylmb3IodmFyIGQ9cVtiXSxjPWQuYW5pbWF0aW9ucyxlPWMubGVuZ3RoO2UtLTspRihhLGNbZV0uYW5pbWF0YWJsZS50YXJnZXQpJiYoYy5zcGxpY2UoZSwxKSxjLmxlbmd0aHx8ZC5wYXVzZSgpKX07bi5nZXRWYWx1ZT1KO24ucGF0aD1mdW5jdGlvbihhLGIpe3ZhciBkPWcuc3RyKGEpP3YoYSlbMF06YSxjPWJ8fDEwMDtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJue2VsOmQscHJvcGVydHk6YSx0b3RhbExlbmd0aDpkLmdldFRvdGFsTGVuZ3RoKCkqKGMvMTAwKX19fTtuLnNldERhc2hvZmZzZXQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRUb3RhbExlbmd0aCgpO2Euc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLGIpO3JldHVybiBifTtuLmJlemllcj15O24uZWFzaW5ncz1OO24udGltZWxpbmU9ZnVuY3Rpb24oYSl7dmFyIGI9bihhKTtiLnBhdXNlKCk7XG5iLmR1cmF0aW9uPTA7Yi5hZGQ9ZnVuY3Rpb24oYSl7Yi5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuYmVnYW49ITA7YS5jb21wbGV0ZWQ9ITB9KTt3KGEpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGM9Yi5kdXJhdGlvbixkPWEub2Zmc2V0O2EuYXV0b3BsYXk9ITE7YS5vZmZzZXQ9Zy51bmQoZCk/YzpLKGQsYyk7Yi5zZWVrKGEub2Zmc2V0KTthPW4oYSk7YS5kdXJhdGlvbj5jJiYoYi5kdXJhdGlvbj1hLmR1cmF0aW9uKTthLmJlZ2FuPSEwO2IuY2hpbGRyZW4ucHVzaChhKX0pO2IucmVzZXQoKTtiLnNlZWsoMCk7Yi5hdXRvcGxheSYmYi5yZXN0YXJ0KCk7cmV0dXJuIGJ9O3JldHVybiBifTtuLnJhbmRvbT1mdW5jdGlvbihhLGIpe3JldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKGItYSsxKSkrYX07cmV0dXJuIG59KTsiLCIvKiBNSVQgbGljZW5zZSAqL1xudmFyIGNzc0tleXdvcmRzID0gcmVxdWlyZSgnY29sb3ItbmFtZScpO1xuXG4vLyBOT1RFOiBjb252ZXJzaW9ucyBzaG91bGQgb25seSByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcyAoaS5lLiBhcnJheXMsIG9yXG4vLyAgICAgICB2YWx1ZXMgdGhhdCBnaXZlIGNvcnJlY3QgYHR5cGVvZmAgcmVzdWx0cykuXG4vLyAgICAgICBkbyBub3QgdXNlIGJveCB2YWx1ZXMgdHlwZXMgKGkuZS4gTnVtYmVyKCksIFN0cmluZygpLCBldGMuKVxuXG52YXIgcmV2ZXJzZUtleXdvcmRzID0ge307XG5mb3IgKHZhciBrZXkgaW4gY3NzS2V5d29yZHMpIHtcblx0aWYgKGNzc0tleXdvcmRzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRyZXZlcnNlS2V5d29yZHNbY3NzS2V5d29yZHNba2V5XV0gPSBrZXk7XG5cdH1cbn1cblxudmFyIGNvbnZlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0cmdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3JnYid9LFxuXHRoc2w6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHNsJ30sXG5cdGhzdjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdoc3YnfSxcblx0aHdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2h3Yid9LFxuXHRjbXlrOiB7Y2hhbm5lbHM6IDQsIGxhYmVsczogJ2NteWsnfSxcblx0eHl6OiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3h5eid9LFxuXHRsYWI6IHtjaGFubmVsczogMywgbGFiZWxzOiAnbGFiJ30sXG5cdGxjaDoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdsY2gnfSxcblx0aGV4OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydoZXgnXX0sXG5cdGtleXdvcmQ6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2tleXdvcmQnXX0sXG5cdGFuc2kxNjoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnYW5zaTE2J119LFxuXHRhbnNpMjU2OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydhbnNpMjU2J119LFxuXHRoY2c6IHtjaGFubmVsczogMywgbGFiZWxzOiBbJ2gnLCAnYycsICdnJ119LFxuXHRhcHBsZToge2NoYW5uZWxzOiAzLCBsYWJlbHM6IFsncjE2JywgJ2cxNicsICdiMTYnXX0sXG5cdGdyYXk6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2dyYXknXX1cbn07XG5cbi8vIGhpZGUgLmNoYW5uZWxzIGFuZCAubGFiZWxzIHByb3BlcnRpZXNcbmZvciAodmFyIG1vZGVsIGluIGNvbnZlcnQpIHtcblx0aWYgKGNvbnZlcnQuaGFzT3duUHJvcGVydHkobW9kZWwpKSB7XG5cdFx0aWYgKCEoJ2NoYW5uZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHRpZiAoISgnbGFiZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVsIGxhYmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHRpZiAoY29udmVydFttb2RlbF0ubGFiZWxzLmxlbmd0aCAhPT0gY29udmVydFttb2RlbF0uY2hhbm5lbHMpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignY2hhbm5lbCBhbmQgbGFiZWwgY291bnRzIG1pc21hdGNoOiAnICsgbW9kZWwpO1xuXHRcdH1cblxuXHRcdHZhciBjaGFubmVscyA9IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuXHRcdHZhciBsYWJlbHMgPSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG5cdFx0ZGVsZXRlIGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuXHRcdGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNoYW5uZWxzfSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnbGFiZWxzJywge3ZhbHVlOiBsYWJlbHN9KTtcblx0fVxufVxuXG5jb252ZXJ0LnJnYi5oc2wgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcblx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cdHZhciBoO1xuXHR2YXIgcztcblx0dmFyIGw7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0aCA9IDA7XG5cdH0gZWxzZSBpZiAociA9PT0gbWF4KSB7XG5cdFx0aCA9IChnIC0gYikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChnID09PSBtYXgpIHtcblx0XHRoID0gMiArIChiIC0gcikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChiID09PSBtYXgpIHtcblx0XHRoID0gNCArIChyIC0gZykgLyBkZWx0YTtcblx0fVxuXG5cdGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRsID0gKG1pbiArIG1heCkgLyAyO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdHMgPSAwO1xuXHR9IGVsc2UgaWYgKGwgPD0gMC41KSB7XG5cdFx0cyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHR9XG5cblx0cmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmhzdiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF07XG5cdHZhciBnID0gcmdiWzFdO1xuXHR2YXIgYiA9IHJnYlsyXTtcblx0dmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG5cdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblx0dmFyIGg7XG5cdHZhciBzO1xuXHR2YXIgdjtcblxuXHRpZiAobWF4ID09PSAwKSB7XG5cdFx0cyA9IDA7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IChkZWx0YSAvIG1heCAqIDEwMDApIC8gMTA7XG5cdH1cblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRoID0gMDtcblx0fSBlbHNlIGlmIChyID09PSBtYXgpIHtcblx0XHRoID0gKGcgLSBiKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuXHRcdGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuXHRcdGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXHR9XG5cblx0aCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdHYgPSAoKG1heCAvIDI1NSkgKiAxMDAwKSAvIDEwO1xuXG5cdHJldHVybiBbaCwgcywgdl07XG59O1xuXG5jb252ZXJ0LnJnYi5od2IgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdO1xuXHR2YXIgZyA9IHJnYlsxXTtcblx0dmFyIGIgPSByZ2JbMl07XG5cdHZhciBoID0gY29udmVydC5yZ2IuaHNsKHJnYilbMF07XG5cdHZhciB3ID0gMSAvIDI1NSAqIE1hdGgubWluKHIsIE1hdGgubWluKGcsIGIpKTtcblxuXHRiID0gMSAtIDEgLyAyNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG5cblx0cmV0dXJuIFtoLCB3ICogMTAwLCBiICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmNteWsgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBjO1xuXHR2YXIgbTtcblx0dmFyIHk7XG5cdHZhciBrO1xuXG5cdGsgPSBNYXRoLm1pbigxIC0gciwgMSAtIGcsIDEgLSBiKTtcblx0YyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXHRtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cdHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gaykgfHwgMDtcblxuXHRyZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xufTtcblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9lbi5tLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UjU3F1YXJlZF9FdWNsaWRlYW5fZGlzdGFuY2VcbiAqICovXG5mdW5jdGlvbiBjb21wYXJhdGl2ZURpc3RhbmNlKHgsIHkpIHtcblx0cmV0dXJuIChcblx0XHRNYXRoLnBvdyh4WzBdIC0geVswXSwgMikgK1xuXHRcdE1hdGgucG93KHhbMV0gLSB5WzFdLCAyKSArXG5cdFx0TWF0aC5wb3coeFsyXSAtIHlbMl0sIDIpXG5cdCk7XG59XG5cbmNvbnZlcnQucmdiLmtleXdvcmQgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByZXZlcnNlZCA9IHJldmVyc2VLZXl3b3Jkc1tyZ2JdO1xuXHRpZiAocmV2ZXJzZWQpIHtcblx0XHRyZXR1cm4gcmV2ZXJzZWQ7XG5cdH1cblxuXHR2YXIgY3VycmVudENsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXHR2YXIgY3VycmVudENsb3Nlc3RLZXl3b3JkO1xuXG5cdGZvciAodmFyIGtleXdvcmQgaW4gY3NzS2V5d29yZHMpIHtcblx0XHRpZiAoY3NzS2V5d29yZHMuaGFzT3duUHJvcGVydHkoa2V5d29yZCkpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGNzc0tleXdvcmRzW2tleXdvcmRdO1xuXG5cdFx0XHQvLyBDb21wdXRlIGNvbXBhcmF0aXZlIGRpc3RhbmNlXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBjb21wYXJhdGl2ZURpc3RhbmNlKHJnYiwgdmFsdWUpO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBpdHMgbGVzcywgaWYgc28gc2V0IGFzIGNsb3Nlc3Rcblx0XHRcdGlmIChkaXN0YW5jZSA8IGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UpIHtcblx0XHRcdFx0Y3VycmVudENsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdFx0XHRjdXJyZW50Q2xvc2VzdEtleXdvcmQgPSBrZXl3b3JkO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG59O1xuXG5jb252ZXJ0LmtleXdvcmQucmdiID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcblx0cmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufTtcblxuY29udmVydC5yZ2IueHl6ID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXG5cdC8vIGFzc3VtZSBzUkdCXG5cdHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuXHRnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcblx0YiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cblx0dmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG5cdHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuXHR2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuXHRyZXR1cm4gW3ggKiAxMDAsIHkgKiAxMDAsIHogKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IubGFiID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgeHl6ID0gY29udmVydC5yZ2IueHl6KHJnYik7XG5cdHZhciB4ID0geHl6WzBdO1xuXHR2YXIgeSA9IHh5elsxXTtcblx0dmFyIHogPSB4eXpbMl07XG5cdHZhciBsO1xuXHR2YXIgYTtcblx0dmFyIGI7XG5cblx0eCAvPSA5NS4wNDc7XG5cdHkgLz0gMTAwO1xuXHR6IC89IDEwOC44ODM7XG5cblx0eCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcblx0eSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEgLyAzKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcblx0eiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuXHRsID0gKDExNiAqIHkpIC0gMTY7XG5cdGEgPSA1MDAgKiAoeCAtIHkpO1xuXHRiID0gMjAwICogKHkgLSB6KTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydC5oc2wucmdiID0gZnVuY3Rpb24gKGhzbCkge1xuXHR2YXIgaCA9IGhzbFswXSAvIDM2MDtcblx0dmFyIHMgPSBoc2xbMV0gLyAxMDA7XG5cdHZhciBsID0gaHNsWzJdIC8gMTAwO1xuXHR2YXIgdDE7XG5cdHZhciB0Mjtcblx0dmFyIHQzO1xuXHR2YXIgcmdiO1xuXHR2YXIgdmFsO1xuXG5cdGlmIChzID09PSAwKSB7XG5cdFx0dmFsID0gbCAqIDI1NTtcblx0XHRyZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuXHR9XG5cblx0aWYgKGwgPCAwLjUpIHtcblx0XHR0MiA9IGwgKiAoMSArIHMpO1xuXHR9IGVsc2Uge1xuXHRcdHQyID0gbCArIHMgLSBsICogcztcblx0fVxuXG5cdHQxID0gMiAqIGwgLSB0MjtcblxuXHRyZ2IgPSBbMCwgMCwgMF07XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0dDMgPSBoICsgMSAvIDMgKiAtKGkgLSAxKTtcblx0XHRpZiAodDMgPCAwKSB7XG5cdFx0XHR0MysrO1xuXHRcdH1cblx0XHRpZiAodDMgPiAxKSB7XG5cdFx0XHR0My0tO1xuXHRcdH1cblxuXHRcdGlmICg2ICogdDMgPCAxKSB7XG5cdFx0XHR2YWwgPSB0MSArICh0MiAtIHQxKSAqIDYgKiB0Mztcblx0XHR9IGVsc2UgaWYgKDIgKiB0MyA8IDEpIHtcblx0XHRcdHZhbCA9IHQyO1xuXHRcdH0gZWxzZSBpZiAoMyAqIHQzIDwgMikge1xuXHRcdFx0dmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWwgPSB0MTtcblx0XHR9XG5cblx0XHRyZ2JbaV0gPSB2YWwgKiAyNTU7XG5cdH1cblxuXHRyZXR1cm4gcmdiO1xufTtcblxuY29udmVydC5oc2wuaHN2ID0gZnVuY3Rpb24gKGhzbCkge1xuXHR2YXIgaCA9IGhzbFswXTtcblx0dmFyIHMgPSBoc2xbMV0gLyAxMDA7XG5cdHZhciBsID0gaHNsWzJdIC8gMTAwO1xuXHR2YXIgc21pbiA9IHM7XG5cdHZhciBsbWluID0gTWF0aC5tYXgobCwgMC4wMSk7XG5cdHZhciBzdjtcblx0dmFyIHY7XG5cblx0bCAqPSAyO1xuXHRzICo9IChsIDw9IDEpID8gbCA6IDIgLSBsO1xuXHRzbWluICo9IGxtaW4gPD0gMSA/IGxtaW4gOiAyIC0gbG1pbjtcblx0diA9IChsICsgcykgLyAyO1xuXHRzdiA9IGwgPT09IDAgPyAoMiAqIHNtaW4pIC8gKGxtaW4gKyBzbWluKSA6ICgyICogcykgLyAobCArIHMpO1xuXG5cdHJldHVybiBbaCwgc3YgKiAxMDAsIHYgKiAxMDBdO1xufTtcblxuY29udmVydC5oc3YucmdiID0gZnVuY3Rpb24gKGhzdikge1xuXHR2YXIgaCA9IGhzdlswXSAvIDYwO1xuXHR2YXIgcyA9IGhzdlsxXSAvIDEwMDtcblx0dmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG5cdHZhciBoaSA9IE1hdGguZmxvb3IoaCkgJSA2O1xuXG5cdHZhciBmID0gaCAtIE1hdGguZmxvb3IoaCk7XG5cdHZhciBwID0gMjU1ICogdiAqICgxIC0gcyk7XG5cdHZhciBxID0gMjU1ICogdiAqICgxIC0gKHMgKiBmKSk7XG5cdHZhciB0ID0gMjU1ICogdiAqICgxIC0gKHMgKiAoMSAtIGYpKSk7XG5cdHYgKj0gMjU1O1xuXG5cdHN3aXRjaCAoaGkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRyZXR1cm4gW3YsIHQsIHBdO1xuXHRcdGNhc2UgMTpcblx0XHRcdHJldHVybiBbcSwgdiwgcF07XG5cdFx0Y2FzZSAyOlxuXHRcdFx0cmV0dXJuIFtwLCB2LCB0XTtcblx0XHRjYXNlIDM6XG5cdFx0XHRyZXR1cm4gW3AsIHEsIHZdO1xuXHRcdGNhc2UgNDpcblx0XHRcdHJldHVybiBbdCwgcCwgdl07XG5cdFx0Y2FzZSA1OlxuXHRcdFx0cmV0dXJuIFt2LCBwLCBxXTtcblx0fVxufTtcblxuY29udmVydC5oc3YuaHNsID0gZnVuY3Rpb24gKGhzdikge1xuXHR2YXIgaCA9IGhzdlswXTtcblx0dmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG5cdHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuXHR2YXIgdm1pbiA9IE1hdGgubWF4KHYsIDAuMDEpO1xuXHR2YXIgbG1pbjtcblx0dmFyIHNsO1xuXHR2YXIgbDtcblxuXHRsID0gKDIgLSBzKSAqIHY7XG5cdGxtaW4gPSAoMiAtIHMpICogdm1pbjtcblx0c2wgPSBzICogdm1pbjtcblx0c2wgLz0gKGxtaW4gPD0gMSkgPyBsbWluIDogMiAtIGxtaW47XG5cdHNsID0gc2wgfHwgMDtcblx0bCAvPSAyO1xuXG5cdHJldHVybiBbaCwgc2wgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5jb252ZXJ0Lmh3Yi5yZ2IgPSBmdW5jdGlvbiAoaHdiKSB7XG5cdHZhciBoID0gaHdiWzBdIC8gMzYwO1xuXHR2YXIgd2ggPSBod2JbMV0gLyAxMDA7XG5cdHZhciBibCA9IGh3YlsyXSAvIDEwMDtcblx0dmFyIHJhdGlvID0gd2ggKyBibDtcblx0dmFyIGk7XG5cdHZhciB2O1xuXHR2YXIgZjtcblx0dmFyIG47XG5cblx0Ly8gd2ggKyBibCBjYW50IGJlID4gMVxuXHRpZiAocmF0aW8gPiAxKSB7XG5cdFx0d2ggLz0gcmF0aW87XG5cdFx0YmwgLz0gcmF0aW87XG5cdH1cblxuXHRpID0gTWF0aC5mbG9vcig2ICogaCk7XG5cdHYgPSAxIC0gYmw7XG5cdGYgPSA2ICogaCAtIGk7XG5cblx0aWYgKChpICYgMHgwMSkgIT09IDApIHtcblx0XHRmID0gMSAtIGY7XG5cdH1cblxuXHRuID0gd2ggKyBmICogKHYgLSB3aCk7IC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cblx0dmFyIHI7XG5cdHZhciBnO1xuXHR2YXIgYjtcblx0c3dpdGNoIChpKSB7XG5cdFx0ZGVmYXVsdDpcblx0XHRjYXNlIDY6XG5cdFx0Y2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG5cdFx0Y2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG5cdFx0Y2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG5cdFx0Y2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC5jbXlrLnJnYiA9IGZ1bmN0aW9uIChjbXlrKSB7XG5cdHZhciBjID0gY215a1swXSAvIDEwMDtcblx0dmFyIG0gPSBjbXlrWzFdIC8gMTAwO1xuXHR2YXIgeSA9IGNteWtbMl0gLyAxMDA7XG5cdHZhciBrID0gY215a1szXSAvIDEwMDtcblx0dmFyIHI7XG5cdHZhciBnO1xuXHR2YXIgYjtcblxuXHRyID0gMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgayk7XG5cdGcgPSAxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKTtcblx0YiA9IDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0Lnh5ei5yZ2IgPSBmdW5jdGlvbiAoeHl6KSB7XG5cdHZhciB4ID0geHl6WzBdIC8gMTAwO1xuXHR2YXIgeSA9IHh5elsxXSAvIDEwMDtcblx0dmFyIHogPSB4eXpbMl0gLyAxMDA7XG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cblx0ciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuXHRnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcblx0YiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cblx0Ly8gYXNzdW1lIHNSR0Jcblx0ciA9IHIgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogciAqIDEyLjkyO1xuXG5cdGcgPSBnID4gMC4wMDMxMzA4XG5cdFx0PyAoKDEuMDU1ICogTWF0aC5wb3coZywgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IGcgKiAxMi45MjtcblxuXHRiID0gYiA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIE1hdGgucG93KGIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiBiICogMTIuOTI7XG5cblx0ciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcblx0ZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcblx0YiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC54eXoubGFiID0gZnVuY3Rpb24gKHh5eikge1xuXHR2YXIgeCA9IHh5elswXTtcblx0dmFyIHkgPSB4eXpbMV07XG5cdHZhciB6ID0geHl6WzJdO1xuXHR2YXIgbDtcblx0dmFyIGE7XG5cdHZhciBiO1xuXG5cdHggLz0gOTUuMDQ3O1xuXHR5IC89IDEwMDtcblx0eiAvPSAxMDguODgzO1xuXG5cdHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG5cdHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG5cdHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cblx0bCA9ICgxMTYgKiB5KSAtIDE2O1xuXHRhID0gNTAwICogKHggLSB5KTtcblx0YiA9IDIwMCAqICh5IC0geik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQubGFiLnh5eiA9IGZ1bmN0aW9uIChsYWIpIHtcblx0dmFyIGwgPSBsYWJbMF07XG5cdHZhciBhID0gbGFiWzFdO1xuXHR2YXIgYiA9IGxhYlsyXTtcblx0dmFyIHg7XG5cdHZhciB5O1xuXHR2YXIgejtcblxuXHR5ID0gKGwgKyAxNikgLyAxMTY7XG5cdHggPSBhIC8gNTAwICsgeTtcblx0eiA9IHkgLSBiIC8gMjAwO1xuXG5cdHZhciB5MiA9IE1hdGgucG93KHksIDMpO1xuXHR2YXIgeDIgPSBNYXRoLnBvdyh4LCAzKTtcblx0dmFyIHoyID0gTWF0aC5wb3coeiwgMyk7XG5cdHkgPSB5MiA+IDAuMDA4ODU2ID8geTIgOiAoeSAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXHR4ID0geDIgPiAwLjAwODg1NiA/IHgyIDogKHggLSAxNiAvIDExNikgLyA3Ljc4Nztcblx0eiA9IHoyID4gMC4wMDg4NTYgPyB6MiA6ICh6IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cblx0eCAqPSA5NS4wNDc7XG5cdHkgKj0gMTAwO1xuXHR6ICo9IDEwOC44ODM7XG5cblx0cmV0dXJuIFt4LCB5LCB6XTtcbn07XG5cbmNvbnZlcnQubGFiLmxjaCA9IGZ1bmN0aW9uIChsYWIpIHtcblx0dmFyIGwgPSBsYWJbMF07XG5cdHZhciBhID0gbGFiWzFdO1xuXHR2YXIgYiA9IGxhYlsyXTtcblx0dmFyIGhyO1xuXHR2YXIgaDtcblx0dmFyIGM7XG5cblx0aHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuXHRoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG5cblx0cmV0dXJuIFtsLCBjLCBoXTtcbn07XG5cbmNvbnZlcnQubGNoLmxhYiA9IGZ1bmN0aW9uIChsY2gpIHtcblx0dmFyIGwgPSBsY2hbMF07XG5cdHZhciBjID0gbGNoWzFdO1xuXHR2YXIgaCA9IGxjaFsyXTtcblx0dmFyIGE7XG5cdHZhciBiO1xuXHR2YXIgaHI7XG5cblx0aHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG5cdGEgPSBjICogTWF0aC5jb3MoaHIpO1xuXHRiID0gYyAqIE1hdGguc2luKGhyKTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydC5yZ2IuYW5zaTE2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIHIgPSBhcmdzWzBdO1xuXHR2YXIgZyA9IGFyZ3NbMV07XG5cdHZhciBiID0gYXJnc1syXTtcblx0dmFyIHZhbHVlID0gMSBpbiBhcmd1bWVudHMgPyBhcmd1bWVudHNbMV0gOiBjb252ZXJ0LnJnYi5oc3YoYXJncylbMl07IC8vIGhzdiAtPiBhbnNpMTYgb3B0aW1pemF0aW9uXG5cblx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gNTApO1xuXG5cdGlmICh2YWx1ZSA9PT0gMCkge1xuXHRcdHJldHVybiAzMDtcblx0fVxuXG5cdHZhciBhbnNpID0gMzBcblx0XHQrICgoTWF0aC5yb3VuZChiIC8gMjU1KSA8PCAyKVxuXHRcdHwgKE1hdGgucm91bmQoZyAvIDI1NSkgPDwgMSlcblx0XHR8IE1hdGgucm91bmQociAvIDI1NSkpO1xuXG5cdGlmICh2YWx1ZSA9PT0gMikge1xuXHRcdGFuc2kgKz0gNjA7XG5cdH1cblxuXHRyZXR1cm4gYW5zaTtcbn07XG5cbmNvbnZlcnQuaHN2LmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdC8vIG9wdGltaXphdGlvbiBoZXJlOyB3ZSBhbHJlYWR5IGtub3cgdGhlIHZhbHVlIGFuZCBkb24ndCBuZWVkIHRvIGdldFxuXHQvLyBpdCBjb252ZXJ0ZWQgZm9yIHVzLlxuXHRyZXR1cm4gY29udmVydC5yZ2IuYW5zaTE2KGNvbnZlcnQuaHN2LnJnYihhcmdzKSwgYXJnc1syXSk7XG59O1xuXG5jb252ZXJ0LnJnYi5hbnNpMjU2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIHIgPSBhcmdzWzBdO1xuXHR2YXIgZyA9IGFyZ3NbMV07XG5cdHZhciBiID0gYXJnc1syXTtcblxuXHQvLyB3ZSB1c2UgdGhlIGV4dGVuZGVkIGdyZXlzY2FsZSBwYWxldHRlIGhlcmUsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuXHQvLyBibGFjayBhbmQgd2hpdGUuIG5vcm1hbCBwYWxldHRlIG9ubHkgaGFzIDQgZ3JleXNjYWxlIHNoYWRlcy5cblx0aWYgKHIgPT09IGcgJiYgZyA9PT0gYikge1xuXHRcdGlmIChyIDwgOCkge1xuXHRcdFx0cmV0dXJuIDE2O1xuXHRcdH1cblxuXHRcdGlmIChyID4gMjQ4KSB7XG5cdFx0XHRyZXR1cm4gMjMxO1xuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLnJvdW5kKCgociAtIDgpIC8gMjQ3KSAqIDI0KSArIDIzMjtcblx0fVxuXG5cdHZhciBhbnNpID0gMTZcblx0XHQrICgzNiAqIE1hdGgucm91bmQociAvIDI1NSAqIDUpKVxuXHRcdCsgKDYgKiBNYXRoLnJvdW5kKGcgLyAyNTUgKiA1KSlcblx0XHQrIE1hdGgucm91bmQoYiAvIDI1NSAqIDUpO1xuXG5cdHJldHVybiBhbnNpO1xufTtcblxuY29udmVydC5hbnNpMTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIGNvbG9yID0gYXJncyAlIDEwO1xuXG5cdC8vIGhhbmRsZSBncmV5c2NhbGVcblx0aWYgKGNvbG9yID09PSAwIHx8IGNvbG9yID09PSA3KSB7XG5cdFx0aWYgKGFyZ3MgPiA1MCkge1xuXHRcdFx0Y29sb3IgKz0gMy41O1xuXHRcdH1cblxuXHRcdGNvbG9yID0gY29sb3IgLyAxMC41ICogMjU1O1xuXG5cdFx0cmV0dXJuIFtjb2xvciwgY29sb3IsIGNvbG9yXTtcblx0fVxuXG5cdHZhciBtdWx0ID0gKH5+KGFyZ3MgPiA1MCkgKyAxKSAqIDAuNTtcblx0dmFyIHIgPSAoKGNvbG9yICYgMSkgKiBtdWx0KSAqIDI1NTtcblx0dmFyIGcgPSAoKChjb2xvciA+PiAxKSAmIDEpICogbXVsdCkgKiAyNTU7XG5cdHZhciBiID0gKCgoY29sb3IgPj4gMikgJiAxKSAqIG11bHQpICogMjU1O1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LmFuc2kyNTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Ly8gaGFuZGxlIGdyZXlzY2FsZVxuXHRpZiAoYXJncyA+PSAyMzIpIHtcblx0XHR2YXIgYyA9IChhcmdzIC0gMjMyKSAqIDEwICsgODtcblx0XHRyZXR1cm4gW2MsIGMsIGNdO1xuXHR9XG5cblx0YXJncyAtPSAxNjtcblxuXHR2YXIgcmVtO1xuXHR2YXIgciA9IE1hdGguZmxvb3IoYXJncyAvIDM2KSAvIDUgKiAyNTU7XG5cdHZhciBnID0gTWF0aC5mbG9vcigocmVtID0gYXJncyAlIDM2KSAvIDYpIC8gNSAqIDI1NTtcblx0dmFyIGIgPSAocmVtICUgNikgLyA1ICogMjU1O1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5oZXggPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgaW50ZWdlciA9ICgoTWF0aC5yb3VuZChhcmdzWzBdKSAmIDB4RkYpIDw8IDE2KVxuXHRcdCsgKChNYXRoLnJvdW5kKGFyZ3NbMV0pICYgMHhGRikgPDwgOClcblx0XHQrIChNYXRoLnJvdW5kKGFyZ3NbMl0pICYgMHhGRik7XG5cblx0dmFyIHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59O1xuXG5jb252ZXJ0LmhleC5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgbWF0Y2ggPSBhcmdzLnRvU3RyaW5nKDE2KS5tYXRjaCgvW2EtZjAtOV17Nn18W2EtZjAtOV17M30vaSk7XG5cdGlmICghbWF0Y2gpIHtcblx0XHRyZXR1cm4gWzAsIDAsIDBdO1xuXHR9XG5cblx0dmFyIGNvbG9yU3RyaW5nID0gbWF0Y2hbMF07XG5cblx0aWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMykge1xuXHRcdGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoY2hhcikge1xuXHRcdFx0cmV0dXJuIGNoYXIgKyBjaGFyO1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0dmFyIGludGVnZXIgPSBwYXJzZUludChjb2xvclN0cmluZywgMTYpO1xuXHR2YXIgciA9IChpbnRlZ2VyID4+IDE2KSAmIDB4RkY7XG5cdHZhciBnID0gKGludGVnZXIgPj4gOCkgJiAweEZGO1xuXHR2YXIgYiA9IGludGVnZXIgJiAweEZGO1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5oY2cgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBtYXggPSBNYXRoLm1heChNYXRoLm1heChyLCBnKSwgYik7XG5cdHZhciBtaW4gPSBNYXRoLm1pbihNYXRoLm1pbihyLCBnKSwgYik7XG5cdHZhciBjaHJvbWEgPSAobWF4IC0gbWluKTtcblx0dmFyIGdyYXlzY2FsZTtcblx0dmFyIGh1ZTtcblxuXHRpZiAoY2hyb21hIDwgMSkge1xuXHRcdGdyYXlzY2FsZSA9IG1pbiAvICgxIC0gY2hyb21hKTtcblx0fSBlbHNlIHtcblx0XHRncmF5c2NhbGUgPSAwO1xuXHR9XG5cblx0aWYgKGNocm9tYSA8PSAwKSB7XG5cdFx0aHVlID0gMDtcblx0fSBlbHNlXG5cdGlmIChtYXggPT09IHIpIHtcblx0XHRodWUgPSAoKGcgLSBiKSAvIGNocm9tYSkgJSA2O1xuXHR9IGVsc2Vcblx0aWYgKG1heCA9PT0gZykge1xuXHRcdGh1ZSA9IDIgKyAoYiAtIHIpIC8gY2hyb21hO1xuXHR9IGVsc2Uge1xuXHRcdGh1ZSA9IDQgKyAociAtIGcpIC8gY2hyb21hICsgNDtcblx0fVxuXG5cdGh1ZSAvPSA2O1xuXHRodWUgJT0gMTtcblxuXHRyZXR1cm4gW2h1ZSAqIDM2MCwgY2hyb21hICogMTAwLCBncmF5c2NhbGUgKiAxMDBdO1xufTtcblxuY29udmVydC5oc2wuaGNnID0gZnVuY3Rpb24gKGhzbCkge1xuXHR2YXIgcyA9IGhzbFsxXSAvIDEwMDtcblx0dmFyIGwgPSBoc2xbMl0gLyAxMDA7XG5cdHZhciBjID0gMTtcblx0dmFyIGYgPSAwO1xuXG5cdGlmIChsIDwgMC41KSB7XG5cdFx0YyA9IDIuMCAqIHMgKiBsO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSAyLjAgKiBzICogKDEuMCAtIGwpO1xuXHR9XG5cblx0aWYgKGMgPCAxLjApIHtcblx0XHRmID0gKGwgLSAwLjUgKiBjKSAvICgxLjAgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHNsWzBdLCBjICogMTAwLCBmICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHN2LmhjZyA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG5cdHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuXG5cdHZhciBjID0gcyAqIHY7XG5cdHZhciBmID0gMDtcblxuXHRpZiAoYyA8IDEuMCkge1xuXHRcdGYgPSAodiAtIGMpIC8gKDEgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHN2WzBdLCBjICogMTAwLCBmICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLnJnYiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGggPSBoY2dbMF0gLyAzNjA7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHRpZiAoYyA9PT0gMC4wKSB7XG5cdFx0cmV0dXJuIFtnICogMjU1LCBnICogMjU1LCBnICogMjU1XTtcblx0fVxuXG5cdHZhciBwdXJlID0gWzAsIDAsIDBdO1xuXHR2YXIgaGkgPSAoaCAlIDEpICogNjtcblx0dmFyIHYgPSBoaSAlIDE7XG5cdHZhciB3ID0gMSAtIHY7XG5cdHZhciBtZyA9IDA7XG5cblx0c3dpdGNoIChNYXRoLmZsb29yKGhpKSkge1xuXHRcdGNhc2UgMDpcblx0XHRcdHB1cmVbMF0gPSAxOyBwdXJlWzFdID0gdjsgcHVyZVsyXSA9IDA7IGJyZWFrO1xuXHRcdGNhc2UgMTpcblx0XHRcdHB1cmVbMF0gPSB3OyBwdXJlWzFdID0gMTsgcHVyZVsyXSA9IDA7IGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdHB1cmVbMF0gPSAwOyBwdXJlWzFdID0gMTsgcHVyZVsyXSA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdHB1cmVbMF0gPSAwOyBwdXJlWzFdID0gdzsgcHVyZVsyXSA9IDE7IGJyZWFrO1xuXHRcdGNhc2UgNDpcblx0XHRcdHB1cmVbMF0gPSB2OyBwdXJlWzFdID0gMDsgcHVyZVsyXSA9IDE7IGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRwdXJlWzBdID0gMTsgcHVyZVsxXSA9IDA7IHB1cmVbMl0gPSB3O1xuXHR9XG5cblx0bWcgPSAoMS4wIC0gYykgKiBnO1xuXG5cdHJldHVybiBbXG5cdFx0KGMgKiBwdXJlWzBdICsgbWcpICogMjU1LFxuXHRcdChjICogcHVyZVsxXSArIG1nKSAqIDI1NSxcblx0XHQoYyAqIHB1cmVbMl0gKyBtZykgKiAyNTVcblx0XTtcbn07XG5cbmNvbnZlcnQuaGNnLmhzdiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdHZhciB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG5cdHZhciBmID0gMDtcblxuXHRpZiAodiA+IDAuMCkge1xuXHRcdGYgPSBjIC8gdjtcblx0fVxuXG5cdHJldHVybiBbaGNnWzBdLCBmICogMTAwLCB2ICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLmhzbCA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdHZhciBsID0gZyAqICgxLjAgLSBjKSArIDAuNSAqIGM7XG5cdHZhciBzID0gMDtcblxuXHRpZiAobCA+IDAuMCAmJiBsIDwgMC41KSB7XG5cdFx0cyA9IGMgLyAoMiAqIGwpO1xuXHR9IGVsc2Vcblx0aWYgKGwgPj0gMC41ICYmIGwgPCAxLjApIHtcblx0XHRzID0gYyAvICgyICogKDEgLSBsKSk7XG5cdH1cblxuXHRyZXR1cm4gW2hjZ1swXSwgcyAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5od2IgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblx0dmFyIHYgPSBjICsgZyAqICgxLjAgLSBjKTtcblx0cmV0dXJuIFtoY2dbMF0sICh2IC0gYykgKiAxMDAsICgxIC0gdikgKiAxMDBdO1xufTtcblxuY29udmVydC5od2IuaGNnID0gZnVuY3Rpb24gKGh3Yikge1xuXHR2YXIgdyA9IGh3YlsxXSAvIDEwMDtcblx0dmFyIGIgPSBod2JbMl0gLyAxMDA7XG5cdHZhciB2ID0gMSAtIGI7XG5cdHZhciBjID0gdiAtIHc7XG5cdHZhciBnID0gMDtcblxuXHRpZiAoYyA8IDEpIHtcblx0XHRnID0gKHYgLSBjKSAvICgxIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2h3YlswXSwgYyAqIDEwMCwgZyAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmFwcGxlLnJnYiA9IGZ1bmN0aW9uIChhcHBsZSkge1xuXHRyZXR1cm4gWyhhcHBsZVswXSAvIDY1NTM1KSAqIDI1NSwgKGFwcGxlWzFdIC8gNjU1MzUpICogMjU1LCAoYXBwbGVbMl0gLyA2NTUzNSkgKiAyNTVdO1xufTtcblxuY29udmVydC5yZ2IuYXBwbGUgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHJldHVybiBbKHJnYlswXSAvIDI1NSkgKiA2NTUzNSwgKHJnYlsxXSAvIDI1NSkgKiA2NTUzNSwgKHJnYlsyXSAvIDI1NSkgKiA2NTUzNV07XG59O1xuXG5jb252ZXJ0LmdyYXkucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0cmV0dXJuIFthcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1XTtcbn07XG5cbmNvbnZlcnQuZ3JheS5oc2wgPSBjb252ZXJ0LmdyYXkuaHN2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0cmV0dXJuIFswLCAwLCBhcmdzWzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5od2IgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gWzAsIDEwMCwgZ3JheVswXV07XG59O1xuXG5jb252ZXJ0LmdyYXkuY215ayA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbMCwgMCwgMCwgZ3JheVswXV07XG59O1xuXG5jb252ZXJ0LmdyYXkubGFiID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFtncmF5WzBdLCAwLCAwXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5oZXggPSBmdW5jdGlvbiAoZ3JheSkge1xuXHR2YXIgdmFsID0gTWF0aC5yb3VuZChncmF5WzBdIC8gMTAwICogMjU1KSAmIDB4RkY7XG5cdHZhciBpbnRlZ2VyID0gKHZhbCA8PCAxNikgKyAodmFsIDw8IDgpICsgdmFsO1xuXG5cdHZhciBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcblxuY29udmVydC5yZ2IuZ3JheSA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHZhbCA9IChyZ2JbMF0gKyByZ2JbMV0gKyByZ2JbMl0pIC8gMztcblx0cmV0dXJuIFt2YWwgLyAyNTUgKiAxMDBdO1xufTtcbiIsInZhciBjb252ZXJzaW9ucyA9IHJlcXVpcmUoJy4vY29udmVyc2lvbnMnKTtcbnZhciByb3V0ZSA9IHJlcXVpcmUoJy4vcm91dGUnKTtcblxudmFyIGNvbnZlcnQgPSB7fTtcblxudmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuZnVuY3Rpb24gd3JhcFJhdyhmbikge1xuXHR2YXIgd3JhcHBlZEZuID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmdzO1xuXHRcdH1cblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZuKGFyZ3MpO1xuXHR9O1xuXG5cdC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXHRpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG5cdFx0d3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuXHR9XG5cblx0cmV0dXJuIHdyYXBwZWRGbjtcbn1cblxuZnVuY3Rpb24gd3JhcFJvdW5kZWQoZm4pIHtcblx0dmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0aWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gYXJncztcblx0XHR9XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdHZhciByZXN1bHQgPSBmbihhcmdzKTtcblxuXHRcdC8vIHdlJ3JlIGFzc3VtaW5nIHRoZSByZXN1bHQgaXMgYW4gYXJyYXkgaGVyZS5cblx0XHQvLyBzZWUgbm90aWNlIGluIGNvbnZlcnNpb25zLmpzOyBkb24ndCB1c2UgYm94IHR5cGVzXG5cdFx0Ly8gaW4gY29udmVyc2lvbiBmdW5jdGlvbnMuXG5cdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRmb3IgKHZhciBsZW4gPSByZXN1bHQubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IE1hdGgucm91bmQocmVzdWx0W2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXHRpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG5cdFx0d3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuXHR9XG5cblx0cmV0dXJuIHdyYXBwZWRGbjtcbn1cblxubW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKGZyb21Nb2RlbCkge1xuXHRjb252ZXJ0W2Zyb21Nb2RlbF0gPSB7fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0uY2hhbm5lbHN9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2xhYmVscycsIHt2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5sYWJlbHN9KTtcblxuXHR2YXIgcm91dGVzID0gcm91dGUoZnJvbU1vZGVsKTtcblx0dmFyIHJvdXRlTW9kZWxzID0gT2JqZWN0LmtleXMocm91dGVzKTtcblxuXHRyb3V0ZU1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uICh0b01vZGVsKSB7XG5cdFx0dmFyIGZuID0gcm91dGVzW3RvTW9kZWxdO1xuXG5cdFx0Y29udmVydFtmcm9tTW9kZWxdW3RvTW9kZWxdID0gd3JhcFJvdW5kZWQoZm4pO1xuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXS5yYXcgPSB3cmFwUmF3KGZuKTtcblx0fSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0O1xuIiwidmFyIGNvbnZlcnNpb25zID0gcmVxdWlyZSgnLi9jb252ZXJzaW9ucycpO1xuXG4vKlxuXHR0aGlzIGZ1bmN0aW9uIHJvdXRlcyBhIG1vZGVsIHRvIGFsbCBvdGhlciBtb2RlbHMuXG5cblx0YWxsIGZ1bmN0aW9ucyB0aGF0IGFyZSByb3V0ZWQgaGF2ZSBhIHByb3BlcnR5IGAuY29udmVyc2lvbmAgYXR0YWNoZWRcblx0dG8gdGhlIHJldHVybmVkIHN5bnRoZXRpYyBmdW5jdGlvbi4gVGhpcyBwcm9wZXJ0eSBpcyBhbiBhcnJheVxuXHRvZiBzdHJpbmdzLCBlYWNoIHdpdGggdGhlIHN0ZXBzIGluIGJldHdlZW4gdGhlICdmcm9tJyBhbmQgJ3RvJ1xuXHRjb2xvciBtb2RlbHMgKGluY2x1c2l2ZSkuXG5cblx0Y29udmVyc2lvbnMgdGhhdCBhcmUgbm90IHBvc3NpYmxlIHNpbXBseSBhcmUgbm90IGluY2x1ZGVkLlxuKi9cblxuLy8gaHR0cHM6Ly9qc3BlcmYuY29tL29iamVjdC1rZXlzLXZzLWZvci1pbi13aXRoLWNsb3N1cmUvM1xudmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuZnVuY3Rpb24gYnVpbGRHcmFwaCgpIHtcblx0dmFyIGdyYXBoID0ge307XG5cblx0Zm9yICh2YXIgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdGdyYXBoW21vZGVsc1tpXV0gPSB7XG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS8xLXZzLWluZmluaXR5XG5cdFx0XHQvLyBtaWNyby1vcHQsIGJ1dCB0aGlzIGlzIHNpbXBsZS5cblx0XHRcdGRpc3RhbmNlOiAtMSxcblx0XHRcdHBhcmVudDogbnVsbFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gZ3JhcGg7XG59XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JyZWFkdGgtZmlyc3Rfc2VhcmNoXG5mdW5jdGlvbiBkZXJpdmVCRlMoZnJvbU1vZGVsKSB7XG5cdHZhciBncmFwaCA9IGJ1aWxkR3JhcGgoKTtcblx0dmFyIHF1ZXVlID0gW2Zyb21Nb2RlbF07IC8vIHVuc2hpZnQgLT4gcXVldWUgLT4gcG9wXG5cblx0Z3JhcGhbZnJvbU1vZGVsXS5kaXN0YW5jZSA9IDA7XG5cblx0d2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdHZhciBjdXJyZW50ID0gcXVldWUucG9wKCk7XG5cdFx0dmFyIGFkamFjZW50cyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zW2N1cnJlbnRdKTtcblxuXHRcdGZvciAodmFyIGxlbiA9IGFkamFjZW50cy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHZhciBhZGphY2VudCA9IGFkamFjZW50c1tpXTtcblx0XHRcdHZhciBub2RlID0gZ3JhcGhbYWRqYWNlbnRdO1xuXG5cdFx0XHRpZiAobm9kZS5kaXN0YW5jZSA9PT0gLTEpIHtcblx0XHRcdFx0bm9kZS5kaXN0YW5jZSA9IGdyYXBoW2N1cnJlbnRdLmRpc3RhbmNlICsgMTtcblx0XHRcdFx0bm9kZS5wYXJlbnQgPSBjdXJyZW50O1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KGFkamFjZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZ3JhcGg7XG59XG5cbmZ1bmN0aW9uIGxpbmsoZnJvbSwgdG8pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0cmV0dXJuIHRvKGZyb20oYXJncykpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCkge1xuXHR2YXIgcGF0aCA9IFtncmFwaFt0b01vZGVsXS5wYXJlbnQsIHRvTW9kZWxdO1xuXHR2YXIgZm4gPSBjb252ZXJzaW9uc1tncmFwaFt0b01vZGVsXS5wYXJlbnRdW3RvTW9kZWxdO1xuXG5cdHZhciBjdXIgPSBncmFwaFt0b01vZGVsXS5wYXJlbnQ7XG5cdHdoaWxlIChncmFwaFtjdXJdLnBhcmVudCkge1xuXHRcdHBhdGgudW5zaGlmdChncmFwaFtjdXJdLnBhcmVudCk7XG5cdFx0Zm4gPSBsaW5rKGNvbnZlcnNpb25zW2dyYXBoW2N1cl0ucGFyZW50XVtjdXJdLCBmbik7XG5cdFx0Y3VyID0gZ3JhcGhbY3VyXS5wYXJlbnQ7XG5cdH1cblxuXHRmbi5jb252ZXJzaW9uID0gcGF0aDtcblx0cmV0dXJuIGZuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmcm9tTW9kZWwpIHtcblx0dmFyIGdyYXBoID0gZGVyaXZlQkZTKGZyb21Nb2RlbCk7XG5cdHZhciBjb252ZXJzaW9uID0ge307XG5cblx0dmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGdyYXBoKTtcblx0Zm9yICh2YXIgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdHZhciB0b01vZGVsID0gbW9kZWxzW2ldO1xuXHRcdHZhciBub2RlID0gZ3JhcGhbdG9Nb2RlbF07XG5cblx0XHRpZiAobm9kZS5wYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdC8vIG5vIHBvc3NpYmxlIGNvbnZlcnNpb24sIG9yIHRoaXMgbm9kZSBpcyB0aGUgc291cmNlIG1vZGVsLlxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udmVyc2lvblt0b01vZGVsXSA9IHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKTtcblx0fVxuXG5cdHJldHVybiBjb252ZXJzaW9uO1xufTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59OyIsIi8qIE1JVCBsaWNlbnNlICovXG52YXIgY29sb3JOYW1lcyA9IHJlcXVpcmUoJ2NvbG9yLW5hbWUnKTtcbnZhciBzd2l6emxlID0gcmVxdWlyZSgnc2ltcGxlLXN3aXp6bGUnKTtcblxudmFyIHJldmVyc2VOYW1lcyA9IHt9O1xuXG4vLyBjcmVhdGUgYSBsaXN0IG9mIHJldmVyc2UgY29sb3IgbmFtZXNcbmZvciAodmFyIG5hbWUgaW4gY29sb3JOYW1lcykge1xuXHRpZiAoY29sb3JOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdHJldmVyc2VOYW1lc1tjb2xvck5hbWVzW25hbWVdXSA9IG5hbWU7XG5cdH1cbn1cblxudmFyIGNzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cdHRvOiB7fVxufTtcblxuY3MuZ2V0ID0gZnVuY3Rpb24gKHN0cmluZykge1xuXHR2YXIgcHJlZml4ID0gc3RyaW5nLnN1YnN0cmluZygwLCAzKS50b0xvd2VyQ2FzZSgpO1xuXHR2YXIgdmFsO1xuXHR2YXIgbW9kZWw7XG5cdHN3aXRjaCAocHJlZml4KSB7XG5cdFx0Y2FzZSAnaHNsJzpcblx0XHRcdHZhbCA9IGNzLmdldC5oc2woc3RyaW5nKTtcblx0XHRcdG1vZGVsID0gJ2hzbCc7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdod2InOlxuXHRcdFx0dmFsID0gY3MuZ2V0Lmh3YihzdHJpbmcpO1xuXHRcdFx0bW9kZWwgPSAnaHdiJztcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR2YWwgPSBjcy5nZXQucmdiKHN0cmluZyk7XG5cdFx0XHRtb2RlbCA9ICdyZ2InO1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRpZiAoIXZhbCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIHttb2RlbDogbW9kZWwsIHZhbHVlOiB2YWx9O1xufTtcblxuY3MuZ2V0LnJnYiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0aWYgKCFzdHJpbmcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBhYmJyID0gL14jKFthLWYwLTldezMsNH0pJC9pO1xuXHR2YXIgaGV4ID0gL14jKFthLWYwLTldezZ9KShbYS1mMC05XXsyfSk/JC9pO1xuXHR2YXIgcmdiYSA9IC9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvO1xuXHR2YXIgcGVyID0gL15yZ2JhP1xcKFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC87XG5cdHZhciBrZXl3b3JkID0gLyhcXEQrKS87XG5cblx0dmFyIHJnYiA9IFswLCAwLCAwLCAxXTtcblx0dmFyIG1hdGNoO1xuXHR2YXIgaTtcblx0dmFyIGhleEFscGhhO1xuXG5cdGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChoZXgpKSB7XG5cdFx0aGV4QWxwaGEgPSBtYXRjaFsyXTtcblx0XHRtYXRjaCA9IG1hdGNoWzFdO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3NsaWNlLXZzLXN1YnN0ci12cy1zdWJzdHJpbmctbWV0aG9kcy1sb25nLXN0cmluZy8xOVxuXHRcdFx0dmFyIGkyID0gaSAqIDI7XG5cdFx0XHRyZ2JbaV0gPSBwYXJzZUludChtYXRjaC5zbGljZShpMiwgaTIgKyAyKSwgMTYpO1xuXHRcdH1cblxuXHRcdGlmIChoZXhBbHBoYSkge1xuXHRcdFx0cmdiWzNdID0gTWF0aC5yb3VuZCgocGFyc2VJbnQoaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuXHRcdH1cblx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChhYmJyKSkge1xuXHRcdG1hdGNoID0gbWF0Y2hbMV07XG5cdFx0aGV4QWxwaGEgPSBtYXRjaFszXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2ldICsgbWF0Y2hbaV0sIDE2KTtcblx0XHR9XG5cblx0XHRpZiAoaGV4QWxwaGEpIHtcblx0XHRcdHJnYlszXSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhICsgaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuXHRcdH1cblx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChyZ2JhKSkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2kgKyAxXSwgMCk7XG5cdFx0fVxuXG5cdFx0aWYgKG1hdGNoWzRdKSB7XG5cdFx0XHRyZ2JbM10gPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocGVyKSkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYltpXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1hdGNoWzRdKSB7XG5cdFx0XHRyZ2JbM10gPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goa2V5d29yZCkpIHtcblx0XHRpZiAobWF0Y2hbMV0gPT09ICd0cmFuc3BhcmVudCcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgMCwgMF07XG5cdFx0fVxuXG5cdFx0cmdiID0gY29sb3JOYW1lc1ttYXRjaFsxXV07XG5cblx0XHRpZiAoIXJnYikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmdiWzNdID0gMTtcblxuXHRcdHJldHVybiByZ2I7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0cmdiW2ldID0gY2xhbXAocmdiW2ldLCAwLCAyNTUpO1xuXHR9XG5cdHJnYlszXSA9IGNsYW1wKHJnYlszXSwgMCwgMSk7XG5cblx0cmV0dXJuIHJnYjtcbn07XG5cbmNzLmdldC5oc2wgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdGlmICghc3RyaW5nKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgaHNsID0gL15oc2xhP1xcKFxccyooWystXT9cXGQqW1xcLl0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC87XG5cdHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChoc2wpO1xuXG5cdGlmIChtYXRjaCkge1xuXHRcdHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuXHRcdHZhciBoID0gKChwYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCkgKyAzNjApICUgMzYwO1xuXHRcdHZhciBzID0gY2xhbXAocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCk7XG5cdFx0dmFyIGwgPSBjbGFtcChwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKTtcblx0XHR2YXIgYSA9IGNsYW1wKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG5cblx0XHRyZXR1cm4gW2gsIHMsIGwsIGFdO1xuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59O1xuXG5jcy5nZXQuaHdiID0gZnVuY3Rpb24gKHN0cmluZykge1xuXHRpZiAoIXN0cmluZykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGh3YiA9IC9eaHdiXFwoXFxzKihbKy1dP1xcZCpbXFwuXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkLztcblx0dmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGh3Yik7XG5cblx0aWYgKG1hdGNoKSB7XG5cdFx0dmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG5cdFx0dmFyIGggPSAoKHBhcnNlRmxvYXQobWF0Y2hbMV0pICUgMzYwKSArIDM2MCkgJSAzNjA7XG5cdFx0dmFyIHcgPSBjbGFtcChwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKTtcblx0XHR2YXIgYiA9IGNsYW1wKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApO1xuXHRcdHZhciBhID0gY2xhbXAoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcblx0XHRyZXR1cm4gW2gsIHcsIGIsIGFdO1xuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59O1xuXG5jcy50by5oZXggPSBmdW5jdGlvbiAoKSB7XG5cdHZhciByZ2JhID0gc3dpenpsZShhcmd1bWVudHMpO1xuXG5cdHJldHVybiAoXG5cdFx0JyMnICtcblx0XHRoZXhEb3VibGUocmdiYVswXSkgK1xuXHRcdGhleERvdWJsZShyZ2JhWzFdKSArXG5cdFx0aGV4RG91YmxlKHJnYmFbMl0pICtcblx0XHQocmdiYVszXSA8IDFcblx0XHRcdD8gKGhleERvdWJsZShNYXRoLnJvdW5kKHJnYmFbM10gKiAyNTUpKSlcblx0XHRcdDogJycpXG5cdCk7XG59O1xuXG5jcy50by5yZ2IgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciByZ2JhID0gc3dpenpsZShhcmd1bWVudHMpO1xuXG5cdHJldHVybiByZ2JhLmxlbmd0aCA8IDQgfHwgcmdiYVszXSA9PT0gMVxuXHRcdD8gJ3JnYignICsgTWF0aC5yb3VuZChyZ2JhWzBdKSArICcsICcgKyBNYXRoLnJvdW5kKHJnYmFbMV0pICsgJywgJyArIE1hdGgucm91bmQocmdiYVsyXSkgKyAnKSdcblx0XHQ6ICdyZ2JhKCcgKyBNYXRoLnJvdW5kKHJnYmFbMF0pICsgJywgJyArIE1hdGgucm91bmQocmdiYVsxXSkgKyAnLCAnICsgTWF0aC5yb3VuZChyZ2JhWzJdKSArICcsICcgKyByZ2JhWzNdICsgJyknO1xufTtcblxuY3MudG8ucmdiLnBlcmNlbnQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciByZ2JhID0gc3dpenpsZShhcmd1bWVudHMpO1xuXG5cdHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdIC8gMjU1ICogMTAwKTtcblx0dmFyIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0gLyAyNTUgKiAxMDApO1xuXHR2YXIgYiA9IE1hdGgucm91bmQocmdiYVsyXSAvIDI1NSAqIDEwMCk7XG5cblx0cmV0dXJuIHJnYmEubGVuZ3RoIDwgNCB8fCByZ2JhWzNdID09PSAxXG5cdFx0PyAncmdiKCcgKyByICsgJyUsICcgKyBnICsgJyUsICcgKyBiICsgJyUpJ1xuXHRcdDogJ3JnYmEoJyArIHIgKyAnJSwgJyArIGcgKyAnJSwgJyArIGIgKyAnJSwgJyArIHJnYmFbM10gKyAnKSc7XG59O1xuXG5jcy50by5oc2wgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBoc2xhID0gc3dpenpsZShhcmd1bWVudHMpO1xuXHRyZXR1cm4gaHNsYS5sZW5ndGggPCA0IHx8IGhzbGFbM10gPT09IDFcblx0XHQ/ICdoc2woJyArIGhzbGFbMF0gKyAnLCAnICsgaHNsYVsxXSArICclLCAnICsgaHNsYVsyXSArICclKSdcblx0XHQ6ICdoc2xhKCcgKyBoc2xhWzBdICsgJywgJyArIGhzbGFbMV0gKyAnJSwgJyArIGhzbGFbMl0gKyAnJSwgJyArIGhzbGFbM10gKyAnKSc7XG59O1xuXG4vLyBod2IgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gcmdiKGEpICYgaHNsKGEpIHNpbmNlIHRoZXJlIGlzIG5vIGFscGhhIHNwZWNpZmljIHN5bnRheFxuLy8gKGh3YiBoYXZlIGFscGhhIG9wdGlvbmFsICYgMSBpcyBkZWZhdWx0IHZhbHVlKVxuY3MudG8uaHdiID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaHdiYSA9IHN3aXp6bGUoYXJndW1lbnRzKTtcblxuXHR2YXIgYSA9ICcnO1xuXHRpZiAoaHdiYS5sZW5ndGggPj0gNCAmJiBod2JhWzNdICE9PSAxKSB7XG5cdFx0YSA9ICcsICcgKyBod2JhWzNdO1xuXHR9XG5cblx0cmV0dXJuICdod2IoJyArIGh3YmFbMF0gKyAnLCAnICsgaHdiYVsxXSArICclLCAnICsgaHdiYVsyXSArICclJyArIGEgKyAnKSc7XG59O1xuXG5jcy50by5rZXl3b3JkID0gZnVuY3Rpb24gKHJnYikge1xuXHRyZXR1cm4gcmV2ZXJzZU5hbWVzW3JnYi5zbGljZSgwLCAzKV07XG59O1xuXG4vLyBoZWxwZXJzXG5mdW5jdGlvbiBjbGFtcChudW0sIG1pbiwgbWF4KSB7XG5cdHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIG51bSksIG1heCk7XG59XG5cbmZ1bmN0aW9uIGhleERvdWJsZShudW0pIHtcblx0dmFyIHN0ciA9IG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0cmV0dXJuIChzdHIubGVuZ3RoIDwgMikgPyAnMCcgKyBzdHIgOiBzdHI7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb2xvclN0cmluZyA9IHJlcXVpcmUoJ2NvbG9yLXN0cmluZycpO1xudmFyIGNvbnZlcnQgPSByZXF1aXJlKCdjb2xvci1jb252ZXJ0Jyk7XG5cbnZhciBfc2xpY2UgPSBbXS5zbGljZTtcblxudmFyIHNraXBwZWRNb2RlbHMgPSBbXG5cdC8vIHRvIGJlIGhvbmVzdCwgSSBkb24ndCByZWFsbHkgZmVlbCBsaWtlIGtleXdvcmQgYmVsb25ncyBpbiBjb2xvciBjb252ZXJ0LCBidXQgZWguXG5cdCdrZXl3b3JkJyxcblxuXHQvLyBncmF5IGNvbmZsaWN0cyB3aXRoIHNvbWUgbWV0aG9kIG5hbWVzLCBhbmQgaGFzIGl0cyBvd24gbWV0aG9kIGRlZmluZWQuXG5cdCdncmF5JyxcblxuXHQvLyBzaG91bGRuJ3QgcmVhbGx5IGJlIGluIGNvbG9yLWNvbnZlcnQgZWl0aGVyLi4uXG5cdCdoZXgnXG5dO1xuXG52YXIgaGFzaGVkTW9kZWxLZXlzID0ge307XG5PYmplY3Qua2V5cyhjb252ZXJ0KS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuXHRoYXNoZWRNb2RlbEtleXNbX3NsaWNlLmNhbGwoY29udmVydFttb2RlbF0ubGFiZWxzKS5zb3J0KCkuam9pbignJyldID0gbW9kZWw7XG59KTtcblxudmFyIGxpbWl0ZXJzID0ge307XG5cbmZ1bmN0aW9uIENvbG9yKG9iaiwgbW9kZWwpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbG9yKSkge1xuXHRcdHJldHVybiBuZXcgQ29sb3Iob2JqLCBtb2RlbCk7XG5cdH1cblxuXHRpZiAobW9kZWwgJiYgbW9kZWwgaW4gc2tpcHBlZE1vZGVscykge1xuXHRcdG1vZGVsID0gbnVsbDtcblx0fVxuXG5cdGlmIChtb2RlbCAmJiAhKG1vZGVsIGluIGNvbnZlcnQpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGVsOiAnICsgbW9kZWwpO1xuXHR9XG5cblx0dmFyIGk7XG5cdHZhciBjaGFubmVscztcblxuXHRpZiAoIW9iaikge1xuXHRcdHRoaXMubW9kZWwgPSAncmdiJztcblx0XHR0aGlzLmNvbG9yID0gWzAsIDAsIDBdO1xuXHRcdHRoaXMudmFscGhhID0gMTtcblx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBDb2xvcikge1xuXHRcdHRoaXMubW9kZWwgPSBvYmoubW9kZWw7XG5cdFx0dGhpcy5jb2xvciA9IG9iai5jb2xvci5zbGljZSgpO1xuXHRcdHRoaXMudmFscGhhID0gb2JqLnZhbHBoYTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHRcdHZhciByZXN1bHQgPSBjb2xvclN0cmluZy5nZXQob2JqKTtcblx0XHRpZiAocmVzdWx0ID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBjb2xvciBmcm9tIHN0cmluZzogJyArIG9iaik7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb2RlbCA9IHJlc3VsdC5tb2RlbDtcblx0XHRjaGFubmVscyA9IGNvbnZlcnRbdGhpcy5tb2RlbF0uY2hhbm5lbHM7XG5cdFx0dGhpcy5jb2xvciA9IHJlc3VsdC52YWx1ZS5zbGljZSgwLCBjaGFubmVscyk7XG5cdFx0dGhpcy52YWxwaGEgPSB0eXBlb2YgcmVzdWx0LnZhbHVlW2NoYW5uZWxzXSA9PT0gJ251bWJlcicgPyByZXN1bHQudmFsdWVbY2hhbm5lbHNdIDogMTtcblx0fSBlbHNlIGlmIChvYmoubGVuZ3RoKSB7XG5cdFx0dGhpcy5tb2RlbCA9IG1vZGVsIHx8ICdyZ2InO1xuXHRcdGNoYW5uZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5jaGFubmVscztcblx0XHR2YXIgbmV3QXJyID0gX3NsaWNlLmNhbGwob2JqLCAwLCBjaGFubmVscyk7XG5cdFx0dGhpcy5jb2xvciA9IHplcm9BcnJheShuZXdBcnIsIGNoYW5uZWxzKTtcblx0XHR0aGlzLnZhbHBoYSA9IHR5cGVvZiBvYmpbY2hhbm5lbHNdID09PSAnbnVtYmVyJyA/IG9ialtjaGFubmVsc10gOiAxO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKSB7XG5cdFx0Ly8gdGhpcyBpcyBhbHdheXMgUkdCIC0gY2FuIGJlIGNvbnZlcnRlZCBsYXRlciBvbi5cblx0XHRvYmogJj0gMHhGRkZGRkY7XG5cdFx0dGhpcy5tb2RlbCA9ICdyZ2InO1xuXHRcdHRoaXMuY29sb3IgPSBbXG5cdFx0XHQob2JqID4+IDE2KSAmIDB4RkYsXG5cdFx0XHQob2JqID4+IDgpICYgMHhGRixcblx0XHRcdG9iaiAmIDB4RkZcblx0XHRdO1xuXHRcdHRoaXMudmFscGhhID0gMTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLnZhbHBoYSA9IDE7XG5cblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0aWYgKCdhbHBoYScgaW4gb2JqKSB7XG5cdFx0XHRrZXlzLnNwbGljZShrZXlzLmluZGV4T2YoJ2FscGhhJyksIDEpO1xuXHRcdFx0dGhpcy52YWxwaGEgPSB0eXBlb2Ygb2JqLmFscGhhID09PSAnbnVtYmVyJyA/IG9iai5hbHBoYSA6IDA7XG5cdFx0fVxuXG5cdFx0dmFyIGhhc2hlZEtleXMgPSBrZXlzLnNvcnQoKS5qb2luKCcnKTtcblx0XHRpZiAoIShoYXNoZWRLZXlzIGluIGhhc2hlZE1vZGVsS2V5cykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIGNvbG9yIGZyb20gb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkob2JqKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb2RlbCA9IGhhc2hlZE1vZGVsS2V5c1toYXNoZWRLZXlzXTtcblxuXHRcdHZhciBsYWJlbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmxhYmVscztcblx0XHR2YXIgY29sb3IgPSBbXTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb2xvci5wdXNoKG9ialtsYWJlbHNbaV1dKTtcblx0XHR9XG5cblx0XHR0aGlzLmNvbG9yID0gemVyb0FycmF5KGNvbG9yKTtcblx0fVxuXG5cdC8vIHBlcmZvcm0gbGltaXRhdGlvbnMgKGNsYW1waW5nLCBldGMuKVxuXHRpZiAobGltaXRlcnNbdGhpcy5tb2RlbF0pIHtcblx0XHRjaGFubmVscyA9IGNvbnZlcnRbdGhpcy5tb2RlbF0uY2hhbm5lbHM7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGNoYW5uZWxzOyBpKyspIHtcblx0XHRcdHZhciBsaW1pdCA9IGxpbWl0ZXJzW3RoaXMubW9kZWxdW2ldO1xuXHRcdFx0aWYgKGxpbWl0KSB7XG5cdFx0XHRcdHRoaXMuY29sb3JbaV0gPSBsaW1pdCh0aGlzLmNvbG9yW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR0aGlzLnZhbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMudmFscGhhKSk7XG5cblx0aWYgKE9iamVjdC5mcmVlemUpIHtcblx0XHRPYmplY3QuZnJlZXplKHRoaXMpO1xuXHR9XG59XG5cbkNvbG9yLnByb3RvdHlwZSA9IHtcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zdHJpbmcoKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpc1t0aGlzLm1vZGVsXSgpO1xuXHR9LFxuXG5cdHN0cmluZzogZnVuY3Rpb24gKHBsYWNlcykge1xuXHRcdHZhciBzZWxmID0gdGhpcy5tb2RlbCBpbiBjb2xvclN0cmluZy50byA/IHRoaXMgOiB0aGlzLnJnYigpO1xuXHRcdHNlbGYgPSBzZWxmLnJvdW5kKHR5cGVvZiBwbGFjZXMgPT09ICdudW1iZXInID8gcGxhY2VzIDogMSk7XG5cdFx0dmFyIGFyZ3MgPSBzZWxmLnZhbHBoYSA9PT0gMSA/IHNlbGYuY29sb3IgOiBzZWxmLmNvbG9yLmNvbmNhdCh0aGlzLnZhbHBoYSk7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnRvW3NlbGYubW9kZWxdKGFyZ3MpO1xuXHR9LFxuXG5cdHBlcmNlbnRTdHJpbmc6IGZ1bmN0aW9uIChwbGFjZXMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMucmdiKCkucm91bmQodHlwZW9mIHBsYWNlcyA9PT0gJ251bWJlcicgPyBwbGFjZXMgOiAxKTtcblx0XHR2YXIgYXJncyA9IHNlbGYudmFscGhhID09PSAxID8gc2VsZi5jb2xvciA6IHNlbGYuY29sb3IuY29uY2F0KHRoaXMudmFscGhhKTtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcudG8ucmdiLnBlcmNlbnQoYXJncyk7XG5cdH0sXG5cblx0YXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWxwaGEgPT09IDEgPyB0aGlzLmNvbG9yLnNsaWNlKCkgOiB0aGlzLmNvbG9yLmNvbmNhdCh0aGlzLnZhbHBoYSk7XG5cdH0sXG5cblx0b2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHt9O1xuXHRcdHZhciBjaGFubmVscyA9IGNvbnZlcnRbdGhpcy5tb2RlbF0uY2hhbm5lbHM7XG5cdFx0dmFyIGxhYmVscyA9IGNvbnZlcnRbdGhpcy5tb2RlbF0ubGFiZWxzO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsczsgaSsrKSB7XG5cdFx0XHRyZXN1bHRbbGFiZWxzW2ldXSA9IHRoaXMuY29sb3JbaV07XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMudmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZXN1bHQuYWxwaGEgPSB0aGlzLnZhbHBoYTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdHVuaXRBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHJnYlswXSAvPSAyNTU7XG5cdFx0cmdiWzFdIC89IDI1NTtcblx0XHRyZ2JbMl0gLz0gMjU1O1xuXG5cdFx0aWYgKHRoaXMudmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZ2IucHVzaCh0aGlzLnZhbHBoYSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJnYjtcblx0fSxcblxuXHR1bml0T2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCkub2JqZWN0KCk7XG5cdFx0cmdiLnIgLz0gMjU1O1xuXHRcdHJnYi5nIC89IDI1NTtcblx0XHRyZ2IuYiAvPSAyNTU7XG5cblx0XHRpZiAodGhpcy52YWxwaGEgIT09IDEpIHtcblx0XHRcdHJnYi5hbHBoYSA9IHRoaXMudmFscGhhO1xuXHRcdH1cblxuXHRcdHJldHVybiByZ2I7XG5cdH0sXG5cblx0cm91bmQ6IGZ1bmN0aW9uIChwbGFjZXMpIHtcblx0XHRwbGFjZXMgPSBNYXRoLm1heChwbGFjZXMgfHwgMCwgMCk7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcih0aGlzLmNvbG9yLm1hcChyb3VuZFRvUGxhY2UocGxhY2VzKSkuY29uY2F0KHRoaXMudmFscGhhKSwgdGhpcy5tb2RlbCk7XG5cdH0sXG5cblx0YWxwaGE6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0aGlzLmNvbG9yLmNvbmNhdChNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWwpKSksIHRoaXMubW9kZWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnZhbHBoYTtcblx0fSxcblxuXHQvLyByZ2Jcblx0cmVkOiBnZXRzZXQoJ3JnYicsIDAsIG1heGZuKDI1NSkpLFxuXHRncmVlbjogZ2V0c2V0KCdyZ2InLCAxLCBtYXhmbigyNTUpKSxcblx0Ymx1ZTogZ2V0c2V0KCdyZ2InLCAyLCBtYXhmbigyNTUpKSxcblxuXHRodWU6IGdldHNldChbJ2hzbCcsICdoc3YnLCAnaHNsJywgJ2h3YicsICdoY2cnXSwgMCwgZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gKCh2YWwgJSAzNjApICsgMzYwKSAlIDM2MDsgfSksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcblxuXHRzYXR1cmF0aW9ubDogZ2V0c2V0KCdoc2wnLCAxLCBtYXhmbigxMDApKSxcblx0bGlnaHRuZXNzOiBnZXRzZXQoJ2hzbCcsIDIsIG1heGZuKDEwMCkpLFxuXG5cdHNhdHVyYXRpb252OiBnZXRzZXQoJ2hzdicsIDEsIG1heGZuKDEwMCkpLFxuXHR2YWx1ZTogZ2V0c2V0KCdoc3YnLCAyLCBtYXhmbigxMDApKSxcblxuXHRjaHJvbWE6IGdldHNldCgnaGNnJywgMSwgbWF4Zm4oMTAwKSksXG5cdGdyYXk6IGdldHNldCgnaGNnJywgMiwgbWF4Zm4oMTAwKSksXG5cblx0d2hpdGU6IGdldHNldCgnaHdiJywgMSwgbWF4Zm4oMTAwKSksXG5cdHdibGFjazogZ2V0c2V0KCdod2InLCAyLCBtYXhmbigxMDApKSxcblxuXHRjeWFuOiBnZXRzZXQoJ2NteWsnLCAwLCBtYXhmbigxMDApKSxcblx0bWFnZW50YTogZ2V0c2V0KCdjbXlrJywgMSwgbWF4Zm4oMTAwKSksXG5cdHllbGxvdzogZ2V0c2V0KCdjbXlrJywgMiwgbWF4Zm4oMTAwKSksXG5cdGJsYWNrOiBnZXRzZXQoJ2NteWsnLCAzLCBtYXhmbigxMDApKSxcblxuXHR4OiBnZXRzZXQoJ3h5eicsIDAsIG1heGZuKDEwMCkpLFxuXHR5OiBnZXRzZXQoJ3h5eicsIDEsIG1heGZuKDEwMCkpLFxuXHR6OiBnZXRzZXQoJ3h5eicsIDIsIG1heGZuKDEwMCkpLFxuXG5cdGw6IGdldHNldCgnbGFiJywgMCwgbWF4Zm4oMTAwKSksXG5cdGE6IGdldHNldCgnbGFiJywgMSksXG5cdGI6IGdldHNldCgnbGFiJywgMiksXG5cblx0a2V5d29yZDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHZhbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbnZlcnRbdGhpcy5tb2RlbF0ua2V5d29yZCh0aGlzLmNvbG9yKTtcblx0fSxcblxuXHRoZXg6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih2YWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb2xvclN0cmluZy50by5oZXgodGhpcy5yZ2IoKS5yb3VuZCgpLmNvbG9yKTtcblx0fSxcblxuXHRyZ2JOdW1iZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcblx0XHRyZXR1cm4gKChyZ2JbMF0gJiAweEZGKSA8PCAxNikgfCAoKHJnYlsxXSAmIDB4RkYpIDw8IDgpIHwgKHJnYlsyXSAmIDB4RkYpO1xuXHR9LFxuXG5cdGx1bWlub3NpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cblx0XHR2YXIgbHVtID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjaGFuID0gcmdiW2ldIC8gMjU1O1xuXHRcdFx0bHVtW2ldID0gKGNoYW4gPD0gMC4wMzkyOCkgPyBjaGFuIC8gMTIuOTIgOiBNYXRoLnBvdygoKGNoYW4gKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDAuMjEyNiAqIGx1bVswXSArIDAuNzE1MiAqIGx1bVsxXSArIDAuMDcyMiAqIGx1bVsyXTtcblx0fSxcblxuXHRjb250cmFzdDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jY29udHJhc3QtcmF0aW9kZWZcblx0XHR2YXIgbHVtMSA9IHRoaXMubHVtaW5vc2l0eSgpO1xuXHRcdHZhciBsdW0yID0gY29sb3IyLmx1bWlub3NpdHkoKTtcblxuXHRcdGlmIChsdW0xID4gbHVtMikge1xuXHRcdFx0cmV0dXJuIChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpO1xuXHRcdH1cblxuXHRcdHJldHVybiAobHVtMiArIDAuMDUpIC8gKGx1bTEgKyAwLjA1KTtcblx0fSxcblxuXHRsZXZlbDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdHZhciBjb250cmFzdFJhdGlvID0gdGhpcy5jb250cmFzdChjb2xvcjIpO1xuXHRcdGlmIChjb250cmFzdFJhdGlvID49IDcuMSkge1xuXHRcdFx0cmV0dXJuICdBQUEnO1xuXHRcdH1cblxuXHRcdHJldHVybiAoY29udHJhc3RSYXRpbyA+PSA0LjUpID8gJ0FBJyA6ICcnO1xuXHR9LFxuXG5cdGRhcms6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBZSVEgZXF1YXRpb24gZnJvbSBodHRwOi8vMjR3YXlzLm9yZy8yMDEwL2NhbGN1bGF0aW5nLWNvbG9yLWNvbnRyYXN0XG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cdFx0dmFyIHlpcSA9IChyZ2JbMF0gKiAyOTkgKyByZ2JbMV0gKiA1ODcgKyByZ2JbMl0gKiAxMTQpIC8gMTAwMDtcblx0XHRyZXR1cm4geWlxIDwgMTI4O1xuXHR9LFxuXG5cdGxpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmRhcmsoKTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy5yZ2IoKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0cmdiLmNvbG9yW2ldID0gMjU1IC0gcmdiLmNvbG9yW2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gcmdiO1xuXHR9LFxuXG5cdGxpZ2h0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdGhzbC5jb2xvclsyXSArPSBoc2wuY29sb3JbMl0gKiByYXRpbztcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdGRhcmtlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0aHNsLmNvbG9yWzJdIC09IGhzbC5jb2xvclsyXSAqIHJhdGlvO1xuXHRcdHJldHVybiBoc2w7XG5cdH0sXG5cblx0c2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdGhzbC5jb2xvclsxXSArPSBoc2wuY29sb3JbMV0gKiByYXRpbztcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdGRlc2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdGhzbC5jb2xvclsxXSAtPSBoc2wuY29sb3JbMV0gKiByYXRpbztcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdHdoaXRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMuaHdiKCk7XG5cdFx0aHdiLmNvbG9yWzFdICs9IGh3Yi5jb2xvclsxXSAqIHJhdGlvO1xuXHRcdHJldHVybiBod2I7XG5cdH0sXG5cblx0YmxhY2tlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMuaHdiKCk7XG5cdFx0aHdiLmNvbG9yWzJdICs9IGh3Yi5jb2xvclsyXSAqIHJhdGlvO1xuXHRcdHJldHVybiBod2I7XG5cdH0sXG5cblx0Z3JheXNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmF5c2NhbGUjQ29udmVydGluZ19jb2xvcl90b19ncmF5c2NhbGVcblx0XHR2YXIgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcblx0XHR2YXIgdmFsID0gcmdiWzBdICogMC4zICsgcmdiWzFdICogMC41OSArIHJnYlsyXSAqIDAuMTE7XG5cdFx0cmV0dXJuIENvbG9yLnJnYih2YWwsIHZhbCwgdmFsKTtcblx0fSxcblxuXHRmYWRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHRyZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYSAtICh0aGlzLnZhbHBoYSAqIHJhdGlvKSk7XG5cdH0sXG5cblx0b3BhcXVlcjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWxwaGEodGhpcy52YWxwaGEgKyAodGhpcy52YWxwaGEgKiByYXRpbykpO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24gKGRlZ3JlZXMpIHtcblx0XHR2YXIgaHNsID0gdGhpcy5oc2woKTtcblx0XHR2YXIgaHVlID0gaHNsLmNvbG9yWzBdO1xuXHRcdGh1ZSA9IChodWUgKyBkZWdyZWVzKSAlIDM2MDtcblx0XHRodWUgPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuXHRcdGhzbC5jb2xvclswXSA9IGh1ZTtcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdG1peDogZnVuY3Rpb24gKG1peGluQ29sb3IsIHdlaWdodCkge1xuXHRcdC8vIHBvcnRlZCBmcm9tIHNhc3MgaW1wbGVtZW50YXRpb24gaW4gQ1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXNzL2xpYnNhc3MvYmxvYi8wZTZiNGEyODUwMDkyMzU2YWEzZWNlMDdjNmIyNDlmMDIyMWNhY2VkL2Z1bmN0aW9ucy5jcHAjTDIwOVxuXHRcdHZhciBjb2xvcjEgPSB0aGlzLnJnYigpO1xuXHRcdHZhciBjb2xvcjIgPSBtaXhpbkNvbG9yLnJnYigpO1xuXHRcdHZhciBwID0gd2VpZ2h0ID09PSB1bmRlZmluZWQgPyAwLjUgOiB3ZWlnaHQ7XG5cblx0XHR2YXIgdyA9IDIgKiBwIC0gMTtcblx0XHR2YXIgYSA9IGNvbG9yMS5hbHBoYSgpIC0gY29sb3IyLmFscGhhKCk7XG5cblx0XHR2YXIgdzEgPSAoKCh3ICogYSA9PT0gLTEpID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcblx0XHR2YXIgdzIgPSAxIC0gdzE7XG5cblx0XHRyZXR1cm4gQ29sb3IucmdiKFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5yZWQoKSArIHcyICogY29sb3IyLnJlZCgpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ncmVlbigpICsgdzIgKiBjb2xvcjIuZ3JlZW4oKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuYmx1ZSgpICsgdzIgKiBjb2xvcjIuYmx1ZSgpLFxuXHRcdFx0XHRjb2xvcjEuYWxwaGEoKSAqIHAgKyBjb2xvcjIuYWxwaGEoKSAqICgxIC0gcCkpO1xuXHR9XG59O1xuXG4vLyBtb2RlbCBjb252ZXJzaW9uIG1ldGhvZHMgYW5kIHN0YXRpYyBjb25zdHJ1Y3RvcnNcbk9iamVjdC5rZXlzKGNvbnZlcnQpLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsKSB7XG5cdGlmIChza2lwcGVkTW9kZWxzLmluZGV4T2YobW9kZWwpICE9PSAtMSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBjaGFubmVscyA9IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuXG5cdC8vIGNvbnZlcnNpb24gbWV0aG9kc1xuXHRDb2xvci5wcm90b3R5cGVbbW9kZWxdID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLm1vZGVsID09PSBtb2RlbCkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcihhcmd1bWVudHMsIG1vZGVsKTtcblx0XHR9XG5cblx0XHR2YXIgbmV3QWxwaGEgPSB0eXBlb2YgYXJndW1lbnRzW2NoYW5uZWxzXSA9PT0gJ251bWJlcicgPyBjaGFubmVscyA6IHRoaXMudmFscGhhO1xuXHRcdHJldHVybiBuZXcgQ29sb3IoYXNzZXJ0QXJyYXkoY29udmVydFt0aGlzLm1vZGVsXVttb2RlbF0ucmF3KHRoaXMuY29sb3IpKS5jb25jYXQobmV3QWxwaGEpLCBtb2RlbCk7XG5cdH07XG5cblx0Ly8gJ3N0YXRpYycgY29uc3RydWN0aW9uIG1ldGhvZHNcblx0Q29sb3JbbW9kZWxdID0gZnVuY3Rpb24gKGNvbG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBjb2xvciA9PT0gJ251bWJlcicpIHtcblx0XHRcdGNvbG9yID0gemVyb0FycmF5KF9zbGljZS5jYWxsKGFyZ3VtZW50cyksIGNoYW5uZWxzKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihjb2xvciwgbW9kZWwpO1xuXHR9O1xufSk7XG5cbmZ1bmN0aW9uIHJvdW5kVG8obnVtLCBwbGFjZXMpIHtcblx0cmV0dXJuIE51bWJlcihudW0udG9GaXhlZChwbGFjZXMpKTtcbn1cblxuZnVuY3Rpb24gcm91bmRUb1BsYWNlKHBsYWNlcykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKG51bSkge1xuXHRcdHJldHVybiByb3VuZFRvKG51bSwgcGxhY2VzKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gZ2V0c2V0KG1vZGVsLCBjaGFubmVsLCBtb2RpZmllcikge1xuXHRtb2RlbCA9IEFycmF5LmlzQXJyYXkobW9kZWwpID8gbW9kZWwgOiBbbW9kZWxdO1xuXG5cdG1vZGVsLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcblx0XHQobGltaXRlcnNbbV0gfHwgKGxpbWl0ZXJzW21dID0gW10pKVtjaGFubmVsXSA9IG1vZGlmaWVyO1xuXHR9KTtcblxuXHRtb2RlbCA9IG1vZGVsWzBdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0dmFyIHJlc3VsdDtcblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRpZiAobW9kaWZpZXIpIHtcblx0XHRcdFx0dmFsID0gbW9kaWZpZXIodmFsKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzdWx0ID0gdGhpc1ttb2RlbF0oKTtcblx0XHRcdHJlc3VsdC5jb2xvcltjaGFubmVsXSA9IHZhbDtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0cmVzdWx0ID0gdGhpc1ttb2RlbF0oKS5jb2xvcltjaGFubmVsXTtcblx0XHRpZiAobW9kaWZpZXIpIHtcblx0XHRcdHJlc3VsdCA9IG1vZGlmaWVyKHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcbn1cblxuZnVuY3Rpb24gbWF4Zm4obWF4KSB7XG5cdHJldHVybiBmdW5jdGlvbiAodikge1xuXHRcdHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHYpKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXJyYXkodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXTtcbn1cblxuZnVuY3Rpb24gemVyb0FycmF5KGFyciwgbGVuZ3RoKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodHlwZW9mIGFycltpXSAhPT0gJ251bWJlcicpIHtcblx0XHRcdGFycltpXSA9IDA7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcbiIsIi8qIEZvbnQgRmFjZSBPYnNlcnZlciB2Mi4wLjEzIC0gwqkgQnJhbSBTdGVpbi4gTGljZW5zZTogQlNELTMtQ2xhdXNlICovKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gbChhLGIpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI/YS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsYiwhMSk6YS5hdHRhY2hFdmVudChcInNjcm9sbFwiLGIpfWZ1bmN0aW9uIG0oYSl7ZG9jdW1lbnQuYm9keT9hKCk6ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcj9kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uIGMoKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGMpO2EoKX0pOmRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24gaygpe2lmKFwiaW50ZXJhY3RpdmVcIj09ZG9jdW1lbnQucmVhZHlTdGF0ZXx8XCJjb21wbGV0ZVwiPT1kb2N1bWVudC5yZWFkeVN0YXRlKWRvY3VtZW50LmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsayksYSgpfSl9O2Z1bmN0aW9uIHIoYSl7dGhpcy5hPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dGhpcy5hLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpO3RoaXMuYS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKSk7dGhpcy5iPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO3RoaXMuYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTt0aGlzLmg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7dGhpcy5mPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO3RoaXMuZz0tMTt0aGlzLmIuc3R5bGUuY3NzVGV4dD1cIm1heC13aWR0aDpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7b3ZlcmZsb3c6c2Nyb2xsO2ZvbnQtc2l6ZToxNnB4O1wiO3RoaXMuYy5zdHlsZS5jc3NUZXh0PVwibWF4LXdpZHRoOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtvdmVyZmxvdzpzY3JvbGw7Zm9udC1zaXplOjE2cHg7XCI7XG50aGlzLmYuc3R5bGUuY3NzVGV4dD1cIm1heC13aWR0aDpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7b3ZlcmZsb3c6c2Nyb2xsO2ZvbnQtc2l6ZToxNnB4O1wiO3RoaXMuaC5zdHlsZS5jc3NUZXh0PVwiZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MjAwJTtoZWlnaHQ6MjAwJTtmb250LXNpemU6MTZweDttYXgtd2lkdGg6bm9uZTtcIjt0aGlzLmIuYXBwZW5kQ2hpbGQodGhpcy5oKTt0aGlzLmMuYXBwZW5kQ2hpbGQodGhpcy5mKTt0aGlzLmEuYXBwZW5kQ2hpbGQodGhpcy5iKTt0aGlzLmEuYXBwZW5kQ2hpbGQodGhpcy5jKX1cbmZ1bmN0aW9uIHQoYSxiKXthLmEuc3R5bGUuY3NzVGV4dD1cIm1heC13aWR0aDpub25lO21pbi13aWR0aDoyMHB4O21pbi1oZWlnaHQ6MjBweDtkaXNwbGF5OmlubGluZS1ibG9jaztvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6YXV0bzttYXJnaW46MDtwYWRkaW5nOjA7dG9wOi05OTlweDt3aGl0ZS1zcGFjZTpub3dyYXA7Zm9udC1zeW50aGVzaXM6bm9uZTtmb250OlwiK2IrXCI7XCJ9ZnVuY3Rpb24geShhKXt2YXIgYj1hLmEub2Zmc2V0V2lkdGgsYz1iKzEwMDthLmYuc3R5bGUud2lkdGg9YytcInB4XCI7YS5jLnNjcm9sbExlZnQ9YzthLmIuc2Nyb2xsTGVmdD1hLmIuc2Nyb2xsV2lkdGgrMTAwO3JldHVybiBhLmchPT1iPyhhLmc9YiwhMCk6ITF9ZnVuY3Rpb24geihhLGIpe2Z1bmN0aW9uIGMoKXt2YXIgYT1rO3koYSkmJmEuYS5wYXJlbnROb2RlJiZiKGEuZyl9dmFyIGs9YTtsKGEuYixjKTtsKGEuYyxjKTt5KGEpfTtmdW5jdGlvbiBBKGEsYil7dmFyIGM9Ynx8e307dGhpcy5mYW1pbHk9YTt0aGlzLnN0eWxlPWMuc3R5bGV8fFwibm9ybWFsXCI7dGhpcy53ZWlnaHQ9Yy53ZWlnaHR8fFwibm9ybWFsXCI7dGhpcy5zdHJldGNoPWMuc3RyZXRjaHx8XCJub3JtYWxcIn12YXIgQj1udWxsLEM9bnVsbCxFPW51bGwsRj1udWxsO2Z1bmN0aW9uIEcoKXtpZihudWxsPT09QylpZihKKCkmJi9BcHBsZS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnZlbmRvcikpe3ZhciBhPS9BcHBsZVdlYktpdFxcLyhbMC05XSspKD86XFwuKFswLTldKykpKD86XFwuKFswLTldKykpLy5leGVjKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtDPSEhYSYmNjAzPnBhcnNlSW50KGFbMV0sMTApfWVsc2UgQz0hMTtyZXR1cm4gQ31mdW5jdGlvbiBKKCl7bnVsbD09PUYmJihGPSEhZG9jdW1lbnQuZm9udHMpO3JldHVybiBGfVxuZnVuY3Rpb24gSygpe2lmKG51bGw9PT1FKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3RyeXthLnN0eWxlLmZvbnQ9XCJjb25kZW5zZWQgMTAwcHggc2Fucy1zZXJpZlwifWNhdGNoKGIpe31FPVwiXCIhPT1hLnN0eWxlLmZvbnR9cmV0dXJuIEV9ZnVuY3Rpb24gTChhLGIpe3JldHVyblthLnN0eWxlLGEud2VpZ2h0LEsoKT9hLnN0cmV0Y2g6XCJcIixcIjEwMHB4XCIsYl0uam9pbihcIiBcIil9XG5BLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxrPWF8fFwiQkVTYnN3eVwiLHE9MCxEPWJ8fDNFMyxIPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhLGIpe2lmKEooKSYmIUcoKSl7dmFyIE09bmV3IFByb21pc2UoZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBlKCl7KG5ldyBEYXRlKS5nZXRUaW1lKCktSD49RD9iKCk6ZG9jdW1lbnQuZm9udHMubG9hZChMKGMsJ1wiJytjLmZhbWlseSsnXCInKSxrKS50aGVuKGZ1bmN0aW9uKGMpezE8PWMubGVuZ3RoP2EoKTpzZXRUaW1lb3V0KGUsMjUpfSxmdW5jdGlvbigpe2IoKX0pfWUoKX0pLE49bmV3IFByb21pc2UoZnVuY3Rpb24oYSxjKXtxPXNldFRpbWVvdXQoYyxEKX0pO1Byb21pc2UucmFjZShbTixNXSkudGhlbihmdW5jdGlvbigpe2NsZWFyVGltZW91dChxKTthKGMpfSxmdW5jdGlvbigpe2IoYyl9KX1lbHNlIG0oZnVuY3Rpb24oKXtmdW5jdGlvbiB1KCl7dmFyIGI7aWYoYj0tMSE9XG5mJiYtMSE9Z3x8LTEhPWYmJi0xIT1ofHwtMSE9ZyYmLTEhPWgpKGI9ZiE9ZyYmZiE9aCYmZyE9aCl8fChudWxsPT09QiYmKGI9L0FwcGxlV2ViS2l0XFwvKFswLTldKykoPzpcXC4oWzAtOV0rKSkvLmV4ZWMod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLEI9ISFiJiYoNTM2PnBhcnNlSW50KGJbMV0sMTApfHw1MzY9PT1wYXJzZUludChiWzFdLDEwKSYmMTE+PXBhcnNlSW50KGJbMl0sMTApKSksYj1CJiYoZj09diYmZz09diYmaD09dnx8Zj09dyYmZz09dyYmaD09d3x8Zj09eCYmZz09eCYmaD09eCkpLGI9IWI7YiYmKGQucGFyZW50Tm9kZSYmZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpLGNsZWFyVGltZW91dChxKSxhKGMpKX1mdW5jdGlvbiBJKCl7aWYoKG5ldyBEYXRlKS5nZXRUaW1lKCktSD49RClkLnBhcmVudE5vZGUmJmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSxiKGMpO2Vsc2V7dmFyIGE9ZG9jdW1lbnQuaGlkZGVuO2lmKCEwPT09YXx8dm9pZCAwPT09YSlmPWUuYS5vZmZzZXRXaWR0aCxcbmc9bi5hLm9mZnNldFdpZHRoLGg9cC5hLm9mZnNldFdpZHRoLHUoKTtxPXNldFRpbWVvdXQoSSw1MCl9fXZhciBlPW5ldyByKGspLG49bmV3IHIoaykscD1uZXcgcihrKSxmPS0xLGc9LTEsaD0tMSx2PS0xLHc9LTEseD0tMSxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZC5kaXI9XCJsdHJcIjt0KGUsTChjLFwic2Fucy1zZXJpZlwiKSk7dChuLEwoYyxcInNlcmlmXCIpKTt0KHAsTChjLFwibW9ub3NwYWNlXCIpKTtkLmFwcGVuZENoaWxkKGUuYSk7ZC5hcHBlbmRDaGlsZChuLmEpO2QuYXBwZW5kQ2hpbGQocC5hKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGQpO3Y9ZS5hLm9mZnNldFdpZHRoO3c9bi5hLm9mZnNldFdpZHRoO3g9cC5hLm9mZnNldFdpZHRoO0koKTt6KGUsZnVuY3Rpb24oYSl7Zj1hO3UoKX0pO3QoZSxMKGMsJ1wiJytjLmZhbWlseSsnXCIsc2Fucy1zZXJpZicpKTt6KG4sZnVuY3Rpb24oYSl7Zz1hO3UoKX0pO3QobixMKGMsJ1wiJytjLmZhbWlseSsnXCIsc2VyaWYnKSk7XG56KHAsZnVuY3Rpb24oYSl7aD1hO3UoKX0pO3QocCxMKGMsJ1wiJytjLmZhbWlseSsnXCIsbW9ub3NwYWNlJykpfSl9KX07XCJvYmplY3RcIj09PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9QTood2luZG93LkZvbnRGYWNlT2JzZXJ2ZXI9QSx3aW5kb3cuRm9udEZhY2VPYnNlcnZlci5wcm90b3R5cGUubG9hZD1BLnByb3RvdHlwZS5sb2FkKTt9KCkpO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbmZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzXG4gICAgfVxuICAgIFxuICAgIGlmICh0b1N0cmluZy5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2VcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbn1cblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbaV0sIGksIGFycmF5KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoU3RyaW5nKHN0cmluZywgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZylcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqZWN0W2tdLCBrLCBvYmplY3QpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJ2YXIgd2luO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbiA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbiA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIHdpbiA9IHNlbGY7XG59IGVsc2Uge1xuICAgIHdpbiA9IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbjtcbiIsIm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvblxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQWRkcyB0aGUga2V5LXZhbHVlIGBwYWlyYCB0byBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXIgVGhlIGtleS12YWx1ZSBwYWlyIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG1hcGAuXG4gKi9cbmZ1bmN0aW9uIGFkZE1hcEVudHJ5KG1hcCwgcGFpcikge1xuICAvLyBEb24ndCByZXR1cm4gYG1hcC5zZXRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBtYXAuc2V0KHBhaXJbMF0sIHBhaXJbMV0pO1xuICByZXR1cm4gbWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZE1hcEVudHJ5O1xuIiwiLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBzZXRgLlxuICovXG5mdW5jdGlvbiBhZGRTZXRFbnRyeShzZXQsIHZhbHVlKSB7XG4gIC8vIERvbid0IHJldHVybiBgc2V0LmFkZGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIHNldC5hZGQodmFsdWUpO1xuICByZXR1cm4gc2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFNldEVudHJ5O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCIvKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzY2lpVG9BcnJheTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgfVxuICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xhbXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBiYXNlQ2xvbmUsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbHRlcjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXNOYU4gPSByZXF1aXJlKCcuL19iYXNlSXNOYU4nKSxcbiAgICBzdHJpY3RJbmRleE9mID0gcmVxdWlyZSgnLi9fc3RyaWN0SW5kZXhPZicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hTjtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVmFsdWVzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdEZ1bmN0aW9uO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgYmFzZVNsaWNlID0gcmVxdWlyZSgnLi9fYmFzZVNsaWNlJyk7XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFNsaWNlO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwidmFyIGFkZE1hcEVudHJ5ID0gcmVxdWlyZSgnLi9fYWRkTWFwRW50cnknKSxcbiAgICBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwLCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCBDTE9ORV9ERUVQX0ZMQUcpIDogbWFwVG9BcnJheShtYXApO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZE1hcEVudHJ5LCBuZXcgbWFwLmNvbnN0cnVjdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZU1hcDtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgYWRkU2V0RW50cnkgPSByZXF1aXJlKCcuL19hZGRTZXRFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovXG5mdW5jdGlvbiBjbG9uZVNldChzZXQsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhzZXRUb0FycmF5KHNldCksIENMT05FX0RFRVBfRkxBRykgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU2V0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBjYXN0U2xpY2UgPSByZXF1aXJlKCcuL19jYXN0U2xpY2UnKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHN0cmluZ1RvQXJyYXkgPSByZXF1aXJlKCcuL19zdHJpbmdUb0FycmF5JyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDYXNlRmlyc3Q7XG4iLCJ2YXIgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmluZDtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbjtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVbmljb2RlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpLFxuICAgIGNsb25lRGF0YVZpZXcgPSByZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksXG4gICAgY2xvbmVNYXAgPSByZXF1aXJlKCcuL19jbG9uZU1hcCcpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVNldCA9IHJlcXVpcmUoJy4vX2Nsb25lU2V0JyksXG4gICAgY2xvbmVTeW1ib2wgPSByZXF1aXJlKCcuL19jbG9uZVN5bWJvbCcpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGNsb25lRnVuYywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVNYXAob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIGNsb25lU2V0KG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaWN0SW5kZXhPZjtcbiIsInZhciBhc2NpaVRvQXJyYXkgPSByZXF1aXJlKCcuL19hc2NpaVRvQXJyYXknKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHVuaWNvZGVUb0FycmF5ID0gcmVxdWlyZSgnLi9fdW5pY29kZVRvQXJyYXknKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9BcnJheTtcbiIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaWNvZGVUb0FycmF5O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGV4dGVuZFdpdGhcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICogfVxuICpcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAqXG4gKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbkluV2l0aDtcbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKSxcbiAgICB1cHBlckZpcnN0ID0gcmVxdWlyZSgnLi91cHBlckZpcnN0Jyk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gKiB0byBsb3dlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICogLy8gPT4gJ0ZyZWQnXG4gKi9cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FwaXRhbGl6ZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpLFxuICAgIGFzc2lnbkluV2l0aCA9IHJlcXVpcmUoJy4vYXNzaWduSW5XaXRoJyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGN1c3RvbURlZmF1bHRzQXNzaWduSW4gPSByZXF1aXJlKCcuL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluJyk7XG5cbi8qKlxuICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcbiAgcmV0dXJuIGFwcGx5KGFzc2lnbkluV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZvckVhY2gnKTtcbiIsInZhciBiYXNlQ2xhbXAgPSByZXF1aXJlKCcuL19iYXNlQ2xhbXAnKSxcbiAgICBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggdXAgdG8uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG5cbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxuICAgID8gbGVuZ3RoXG4gICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcblxuICB2YXIgZW5kID0gcG9zaXRpb247XG4gIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5zbGljZShwb3NpdGlvbiwgZW5kKSA9PSB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW5kc1dpdGg7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgYmFzZUZpbHRlciA9IHJlcXVpcmUoJy4vX2Jhc2VGaWx0ZXInKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKiBAc2VlIF8ucmVqZWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICogXTtcbiAqXG4gKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICovXG5mdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjtcbiIsInZhciBjcmVhdGVGaW5kID0gcmVxdWlyZSgnLi9fY3JlYXRlRmluZCcpLFxuICAgIGZpbmRJbmRleCA9IHJlcXVpcmUoJy4vZmluZEluZGV4Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICovXG52YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG4iLCJ2YXIgY3JlYXRlRmluZCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUZpbmQnKSxcbiAgICBmaW5kTGFzdEluZGV4ID0gcmVxdWlyZSgnLi9maW5kTGFzdEluZGV4Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9Y29sbGVjdGlvbi5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gKiB9KTtcbiAqIC8vID0+IDNcbiAqL1xudmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kTGFzdDtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdwZWJibGVzJzsgfSk7XG4gKiAvLyA9PiAyXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDJcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMFxuICovXG5mdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgaW5kZXggPSBmcm9tSW5kZXggPCAwXG4gICAgICA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMClcbiAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4LCB0cnVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kTGFzdEluZGV4O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2hlYWQnKTtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGNhc3RGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2Nhc3RGdW5jdGlvbicpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBmaXJzdFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDFcbiAqXG4gKiBfLmhlYWQoW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGVhZDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzU3RyaW5nID0gcmVxdWlyZSgnLi9pc1N0cmluZycpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyksXG4gICAgdmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluY2x1ZGVzO1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZjtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRWxlbWVudDtcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXF1YWw7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bWJlcigzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVW5kZWZpbmVkO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGJhc2VDbGFtcCA9IHJlcXVpcmUoJy4vX2Jhc2VDbGFtcCcpLFxuICAgIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgID8gMFxuICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuICByZXR1cm4gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHRhcmdldC5sZW5ndGgpID09IHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFydHNXaXRoO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi9kZWJvdW5jZScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtemlwXG4gKiBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4yLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHppcHBlZCA9IF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAqXG4gKiBfLnVuemlwKHppcHBlZCk7XG4gKiAvLyA9PiBbWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdXVxuICovXG5mdW5jdGlvbiB1bnppcChhcnJheSkge1xuICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBsZW5ndGggPSAwO1xuICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChncm91cC5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bnppcDtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5JyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIHVuemlwID0gcmVxdWlyZSgnLi91bnppcCcpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy44LjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICogIHJlZ3JvdXBlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB6aXBwZWQgPSBfLnppcChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdKTtcbiAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAqXG4gKiBfLnVuemlwV2l0aCh6aXBwZWQsIF8uYWRkKTtcbiAqIC8vID0+IFszLCAzMCwgMzAwXVxuICovXG5mdW5jdGlvbiB1bnppcFdpdGgoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB1bmRlZmluZWQsIGdyb3VwKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW56aXBXaXRoO1xuIiwidmFyIGNyZWF0ZUNhc2VGaXJzdCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUNhc2VGaXJzdCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGUkVEJ1xuICovXG52YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cHBlckZpcnN0O1xuIiwidmFyIGJhc2VWYWx1ZXMgPSByZXF1aXJlKCcuL19iYXNlVmFsdWVzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIHVuemlwV2l0aCA9IHJlcXVpcmUoJy4vdW56aXBXaXRoJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuOC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICogIGdyb3VwZWQgdmFsdWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAqICAgcmV0dXJuIGEgKyBiICsgYztcbiAqIH0pO1xuICogLy8gPT4gWzExMSwgMjIyXVxuICovXG52YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgIGl0ZXJhdGVlID0gbGVuZ3RoID4gMSA/IGFycmF5c1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gemlwV2l0aDtcbiIsInZhciB0cmltID0gcmVxdWlyZSgndHJpbScpXG4gICwgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJylcbiAgLCBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3JFYWNoKFxuICAgICAgdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcbiAgICAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuICAgICAgICAgICwga2V5ID0gdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLCB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGluZGV4ICsgMSkpXG5cbiAgICAgICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IFsgcmVzdWx0W2tleV0sIHZhbHVlIF1cbiAgICAgICAgfVxuICAgICAgfVxuICApXG5cbiAgcmV0dXJuIHJlc3VsdFxufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJyYXlpc2ggPSByZXF1aXJlKCdpcy1hcnJheWlzaCcpO1xuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxudmFyIHN3aXp6bGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN3aXp6bGUoYXJncykge1xuXHR2YXIgcmVzdWx0cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0dmFyIGFyZyA9IGFyZ3NbaV07XG5cblx0XHRpZiAoaXNBcnJheWlzaChhcmcpKSB7XG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9qYXZhc2NyaXB0LWFycmF5LWNvbmNhdC12cy1wdXNoLzk4XG5cdFx0XHRyZXN1bHRzID0gY29uY2F0LmNhbGwocmVzdWx0cywgc2xpY2UuY2FsbChhcmcpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0cy5wdXNoKGFyZyk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG5zd2l6emxlLndyYXAgPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZm4oc3dpenpsZShhcmd1bWVudHMpKTtcblx0fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcnJheWlzaChvYmopIHtcblx0aWYgKCFvYmogfHwgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheShvYmopIHx8XG5cdFx0KG9iai5sZW5ndGggPj0gMCAmJiAob2JqLnNwbGljZSBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG5cdFx0XHQoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIChvYmoubGVuZ3RoIC0gMSkpICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnU3RyaW5nJykpKTtcbn07XG4iLCJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG59O1xuXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB3aW5kb3cgPSByZXF1aXJlKFwiZ2xvYmFsL3dpbmRvd1wiKVxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKFwiaXMtZnVuY3Rpb25cIilcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKFwicGFyc2UtaGVhZGVyc1wiKVxudmFyIHh0ZW5kID0gcmVxdWlyZShcInh0ZW5kXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlWEhSXG5jcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxuY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0ID0gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiAobmV3IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCgpKSA/IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA6IHdpbmRvdy5YRG9tYWluUmVxdWVzdFxuXG5mb3JFYWNoQXJyYXkoW1wiZ2V0XCIsIFwicHV0XCIsIFwicG9zdFwiLCBcInBhdGNoXCIsIFwiaGVhZFwiLCBcImRlbGV0ZVwiXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgY3JlYXRlWEhSW21ldGhvZCA9PT0gXCJkZWxldGVcIiA/IFwiZGVsXCIgOiBtZXRob2RdID0gZnVuY3Rpb24odXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXG4gICAgfVxufSlcblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0pXG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iail7XG4gICAgZm9yKHZhciBpIGluIG9iail7XG4gICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJhbXMgPSB1cmlcblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcGFyYW1zID0ge3VyaTp1cml9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMgPSB4dGVuZChvcHRpb25zLCB7dXJpOiB1cml9KVxuICAgIH1cblxuICAgIHBhcmFtcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgcmV0dXJuIHBhcmFtc1xufVxuXG5mdW5jdGlvbiBjcmVhdGVYSFIodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVhIUihvcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpXG4gICAgfVxuXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2JPbmNlKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuICAgICAgICBpZighY2FsbGVkKXtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWVcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soZXJyLCByZXNwb25zZSwgYm9keSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChsb2FkRnVuYywgMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICAgIC8vIENocm9tZSB3aXRoIHJlcXVlc3RUeXBlPWJsb2IgdGhyb3dzIGVycm9ycyBhcnJvdW5kIHdoZW4gZXZlbiB0ZXN0aW5nIGFjY2VzcyB0byByZXNwb25zZVRleHRcbiAgICAgICAgdmFyIGJvZHkgPSB1bmRlZmluZWRcblxuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dCB8fCBnZXRYbWwoeGhyKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3JGdW5jKGV2dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZighKGV2dCBpbnN0YW5jZW9mIEVycm9yKSl7XG4gICAgICAgICAgICBldnQgPSBuZXcgRXJyb3IoXCJcIiArIChldnQgfHwgXCJVbmtub3duIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpIClcbiAgICAgICAgfVxuICAgICAgICBldnQuc3RhdHVzQ29kZSA9IDBcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGV2dCwgZmFpbHVyZVJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkRnVuYygpIHtcbiAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxuICAgICAgICB2YXIgc3RhdHVzXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKG9wdGlvbnMudXNlWERSICYmIHhoci5zdGF0dXM9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vSUU4IENPUlMgR0VUIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lc24ndCBoYXZlIGEgc3RhdHVzIGZpZWxkLCBidXQgYm9keSBpcyBmaW5lXG4gICAgICAgICAgICBzdGF0dXMgPSAyMDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cylcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBmYWlsdXJlUmVzcG9uc2VcbiAgICAgICAgdmFyIGVyciA9IG51bGxcblxuICAgICAgICBpZiAoc3RhdHVzICE9PSAwKXtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGdldEJvZHkoKSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKXsgLy9yZW1lbWJlciB4aHIgY2FuIGluIGZhY3QgYmUgWERSIGZvciBDT1JTIGluIElFXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJJbnRlcm5hbCBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KVxuICAgIH1cblxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsXG5cbiAgICBpZiAoIXhocikge1xuICAgICAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0KClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlcbiAgICB2YXIgYWJvcnRlZFxuICAgIHZhciB1cmkgPSB4aHIudXJsID0gb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmxcbiAgICB2YXIgbWV0aG9kID0geGhyLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLmRhdGFcbiAgICB2YXIgaGVhZGVycyA9IHhoci5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9XG4gICAgdmFyIHN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICAgIHZhciBpc0pzb24gPSBmYWxzZVxuICAgIHZhciB0aW1lb3V0VGltZXJcbiAgICB2YXIgZmFpbHVyZVJlc3BvbnNlID0ge1xuICAgICAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICBzdGF0dXNDb2RlOiAwLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgdXJsOiB1cmksXG4gICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgIH1cblxuICAgIGlmIChcImpzb25cIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuanNvbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgaXNKc29uID0gdHJ1ZVxuICAgICAgICBoZWFkZXJzW1wiYWNjZXB0XCJdIHx8IGhlYWRlcnNbXCJBY2NlcHRcIl0gfHwgKGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gfHwgKGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24gPT09IHRydWUgPyBib2R5IDogb3B0aW9ucy5qc29uKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHJlYWR5c3RhdGVjaGFuZ2VcbiAgICB4aHIub25sb2FkID0gbG9hZEZ1bmNcbiAgICB4aHIub25lcnJvciA9IGVycm9yRnVuY1xuICAgIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb24uXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElFIG11c3QgZGllXG4gICAgfVxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHhoci5vbnRpbWVvdXQgPSBlcnJvckZ1bmNcbiAgICB4aHIub3BlbihtZXRob2QsIHVyaSwgIXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQpXG4gICAgLy9oYXMgdG8gYmUgYWZ0ZXIgb3BlblxuICAgIGlmKCFzeW5jKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdGlvbnMud2l0aENyZWRlbnRpYWxzXG4gICAgfVxuICAgIC8vIENhbm5vdCBzZXQgdGltZW91dCB3aXRoIHN5bmMgcmVxdWVzdFxuICAgIC8vIG5vdCBzZXR0aW5nIHRpbWVvdXQgb24gdGhlIHhociBvYmplY3QsIGJlY2F1c2Ugb2Ygb2xkIHdlYmtpdHMgZXRjLiBub3QgaGFuZGxpbmcgdGhhdCBjb3JyZWN0bHlcbiAgICAvLyBib3RoIG5wbSdzIHJlcXVlc3QgYW5kIGpxdWVyeSAxLnggdXNlIHRoaXMga2luZCBvZiB0aW1lb3V0LCBzbyB0aGlzIGlzIGJlaW5nIGNvbnNpc3RlbnRcbiAgICBpZiAoIXN5bmMgJiYgb3B0aW9ucy50aW1lb3V0ID4gMCApIHtcbiAgICAgICAgdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxuICAgICAgICAgICAgYWJvcnRlZCA9IHRydWUvL0lFOSBtYXkgc3RpbGwgY2FsbCByZWFkeXN0YXRlY2hhbmdlXG4gICAgICAgICAgICB4aHIuYWJvcnQoXCJ0aW1lb3V0XCIpXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcihcIlhNTEh0dHBSZXF1ZXN0IHRpbWVvdXRcIilcbiAgICAgICAgICAgIGUuY29kZSA9IFwiRVRJTUVET1VUXCJcbiAgICAgICAgICAgIGVycm9yRnVuYyhlKVxuICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQgKVxuICAgIH1cblxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICBmb3Ioa2V5IGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzICYmICFpc0VtcHR5KG9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKVxuICAgIH1cblxuICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlXG4gICAgfVxuXG4gICAgaWYgKFwiYmVmb3JlU2VuZFwiIGluIG9wdGlvbnMgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2VuZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpXG4gICAgfVxuXG4gICAgLy8gTWljcm9zb2Z0IEVkZ2UgYnJvd3NlciBzZW5kcyBcInVuZGVmaW5lZFwiIHdoZW4gc2VuZCBpcyBjYWxsZWQgd2l0aCB1bmRlZmluZWQgdmFsdWUuXG4gICAgLy8gWE1MSHR0cFJlcXVlc3Qgc3BlYyBzYXlzIHRvIHBhc3MgbnVsbCBhcyBib2R5IHRvIGluZGljYXRlIG5vIGJvZHlcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25hdWd0dXIveGhyL2lzc3Vlcy8xMDAuXG4gICAgeGhyLnNlbmQoYm9keSB8fCBudWxsKVxuXG4gICAgcmV0dXJuIHhoclxuXG5cbn1cblxuZnVuY3Rpb24gZ2V0WG1sKHhocikge1xuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgIH1cbiAgICB2YXIgZmlyZWZveEJ1Z1Rha2VuRWZmZWN0ID0geGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVhNTC5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGFyc2VyZXJyb3JcIlxuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcIlwiICYmICFmaXJlZm94QnVnVGFrZW5FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIi8vIFRoaXJkIHBhcnR5IGRlcGVuZGVuY2llc1xuLy8gaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuXG4vLyBaaW1wbGlzdCBEZXBlZGVuY2llc1xuaW1wb3J0IEJhc2VWaWV3IGZyb20gJ3ppbXBsaXN0L2Rpc3BsYXkvQmFzZVZpZXcnO1xuaW1wb3J0IFN0eWxlIGZyb20gJ3ppbXBsaXN0L3V0aWxzL1N0eWxlJztcblxuLypcbiBFbmNvZGVyIGNvbW1hbmRzIDpcblxuIFlvdSB3aWxsIG5lZWQgRkZNUEVHIHdpdGggcmVjZW50IGxpYnZweCBhbmQgbGliSDI2NCBzdXBwb3J0IGNvbXBpbGVkXG5cbiAvLyBmb3IgdGhlIGZhbGxiYWNrXG4gZmZtcGVnIC1pIGRhbmNlci5tb3YgLXZmIFwic3BsaXQgW3JnYl1bYWxwaGFdOyBbYWxwaGFdIGFscGhhZXh0cmFjdCBbYWxwaGFdOyBbcmdiXSBwYWQ9d2lkdGg9aXc6aGVpZ2h0PTIqaWg6eD0wOnk9MCBbcmdiXTsgW3JnYl1bYWxwaGFdIG92ZXJsYXk9eD0wOnk9aCwgc2NhbGU9NzIwOi0xXCIgLWM6diBsaWJ4MjY0IC1wcm9maWxlOnYgbWFpbiAtbGV2ZWwgNSAtcGl4X2ZtdCB5dXY0MjBwIC1jcmYgMjEgLW1vdmZsYWdzICtmYXN0c3RhcnQgLXkgb3V0cHV0Lm1wNFxuXG5cbiAvLyBuYXRpdmUgVlA5IGFscGhhIGNoYW5uZWxcbiBmZm1wZWcgLWkgcGFwaWxsb25zLm1vdiAtciAyNSAtYzp2IGxpYnZweC12cDkgLWI6diA1MDBrIC1jcmYgMjAgLXF1YWxpdHkgYmVzdCAtc3BlZWQgMCAtdGhyZWFkcyA4IC10aWxlLWNvbHVtbnMgMyAtcGl4X2ZtdCB5dXZhNDIwcCAteSBvdXRwdXQud2VibVxuXG4gKi9cblxuLy8gSGlkZGVuIGNvbnN0c1xuXG4vKipcbiAqXG4gKi9cbmNsYXNzIEFscGhhVmlkZW8gZXh0ZW5kcyBCYXNlVmlldyB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuXG4gICAgICAgIHN1cGVyKGVsLCBvcHRpb25zKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hdGl2ZSB2aWRlbyBwbGF5ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdGl2ZVZpZGVvID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuXG4gICAgICAgIC8vIERldGVjdCBpZiB3ZSBjYW4gdXNlIHRyYW5zcGFyZW50IFZQOSBlbmNvZGluZ1xuICAgICAgICB0aGlzLnVzZUZhbGxiYWNrID0gISh0aGlzLm5hdGl2ZVZpZGVvLmNhblBsYXlUeXBlKCd2aWRlby93ZWJtOyBjb2RlY3M9dnA5JykgPT09ICdwcm9iYWJseScpO1xuXG4gICAgICAgIC8vIFRPRE8gYWRkICdub0ZhbGxiYWNrJyBvcHRpb25cblxuICAgICAgICAvKipcbiAgICAgICAgICogQmFzZSBzb3VyY2UgcGF0aC4gcmVzb2xvdGlvbiBhbmQgZm9ybWF0IHNwZWNpZmllcnMgYXJlIGFwcGVuZGVkIHdoZW4gZGV0ZWN0ZWRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3JjQmFzZSA9IHRoaXMubmF0aXZlVmlkZW8uZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpO1xuXG4gICAgICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHNjYWxlIG9mIHRoZSBmYWxsIGJhY2suIFVzZSB0byBzY2FsZSB1cCBzbWFsbGVyIHZpZGVvcyB0aGF0IGFyZSBlYXNpZXIgdG8gcGFpbnRcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZmFsbGJhY2tTY2FsZSA9IHBhcnNlRmxvYXQoIHRoaXMubmF0aXZlVmlkZW8uZ2V0QXR0cmlidXRlKCdkYXRhLWZhbGxiYWNrLXNjYWxlJykpIHx8IDE7XG5cbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnZmFsbGJhY2snKTtcblxuICAgICAgICAgICAgdGhpcy5uYXRpdmVWaWRlby5zcmMgPSB0aGlzLnNyY0Jhc2UrJ19zbWFsbC5tcDQnO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5uYXRpdmVWaWRlby52aWRlb1dpZHRoICYmIHRoaXMubmF0aXZlVmlkZW8udmlkZW9IZWlnaHQgJiYgdGhpcy5uYXRpdmVWaWRlby5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlbmRlcmVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy5fbmF0aXZlVmlkZW9NZXRhZGF0YUhhbmRsZXIsIHRoaXMubmF0aXZlVmlkZW8pO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ3BsYXlpbmcnLCB0aGlzLl9uYXRpdmVWaWRlb1BsYXlpbmdIYW5kbGVyLCB0aGlzLm5hdGl2ZVZpZGVvKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ3BhdXNlJywgdGhpcy5fbmF0aXZlVmlkZW9QYXVzZUhhbmRsZXIsIHRoaXMubmF0aXZlVmlkZW8pO1xuXG4gICAgICAgICAgICAvLyBWaWRlbyBtaWdodCBhbHJlYWR5IGJlIGxvYWRlZFxuICAgICAgICAgICAgaWYgKCF0aGlzLm5hdGl2ZVZpZGVvLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlbmRlcmVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRSZW5kZXJMb29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMubmF0aXZlVmlkZW8uc3JjID0gdGhpcy5zcmNCYXNlKydfZnVsbC53ZWJtJztcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFB1YmxpYyBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIGJyZWFrcG9pbnRDaGFuZ2VkKGJyZWFrcG9pbnQsIHByZXZpb3VzQnJlYWtwb2ludCkge1xuICAgICAgICBzdXBlci5icmVha3BvaW50Q2hhbmdlZChicmVha3BvaW50LCBwcmV2aW91c0JyZWFrcG9pbnQpO1xuICAgIH1cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBQcml2YXRlIE1ldGhvZHNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9jcmVhdGVSZW5kZXJlcigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlckNhbnZhcykge1xuICAgICAgICAgICAgbGV0IHJlbmRlckNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgcmVuZGVyQ2FudmFzLndpZHRoID0gdGhpcy5uYXRpdmVWaWRlby52aWRlb1dpZHRoO1xuICAgICAgICAgICAgcmVuZGVyQ2FudmFzLmhlaWdodCA9IHRoaXMubmF0aXZlVmlkZW8udmlkZW9IZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICBsZXQgYWxwaGFDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGFscGhhQ2FudmFzLndpZHRoID0gdGhpcy5uYXRpdmVWaWRlby52aWRlb1dpZHRoO1xuICAgICAgICAgICAgYWxwaGFDYW52YXMuaGVpZ2h0ID0gdGhpcy5uYXRpdmVWaWRlby52aWRlb0hlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNhbnZhcyA9IHJlbmRlckNhbnZhcztcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSByZW5kZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgdGhpcy5fYWxwaGFDb250ZXh0ID0gYWxwaGFDYW52YXM7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYUNvbnRleHQgPSBhbHBoYUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHNjYWxlXG4gICAgICAgICAgICBTdHlsZS5zZXQoIHRoaXMuX3JlbmRlckNhbnZhcywge3RyYW5zZm9ybSA6IGBzY2FsZSgke3RoaXMuZmFsbGJhY2tTY2FsZX0pYH0pO1xuXG4gICAgICAgICAgICBTdHlsZS5zZXQoIHRoaXMuZWwsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5uYXRpdmVWaWRlby52aWRlb1dpZHRoICogdGhpcy5mYWxsYmFja1NjYWxlLFxuICAgICAgICAgICAgICAgIGhlaWdodDogKHRoaXMubmF0aXZlVmlkZW8udmlkZW9IZWlnaHQgLyAyKSAqIHRoaXMuZmFsbGJhY2tTY2FsZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHJlbmRlckNhbnZhcyk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIF9yZW5kZXIoKSB7XG5cbiAgICAgICAgbGV0IGZyYW1lV2lkdGggPSB0aGlzLm5hdGl2ZVZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgIGxldCBmcmFtZUhlaWdodCA9IHRoaXMubmF0aXZlVmlkZW8udmlkZW9IZWlnaHQgLyAyO1xuXG4gICAgICAgIC8vIENvcHkgUkdCIERhdGFcbiAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dC5kcmF3SW1hZ2UodGhpcy5uYXRpdmVWaWRlbywgMCwgMCwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIDAsIDAsIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0KTtcblxuICAgICAgICAvLyBDb3B5IEFscGhhIERhdGFcbiAgICAgICAgdGhpcy5fYWxwaGFDb250ZXh0LmRyYXdJbWFnZSh0aGlzLm5hdGl2ZVZpZGVvLCAwLCBmcmFtZUhlaWdodCwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIDAsIDAsIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0KTtcblxuICAgICAgICBsZXQgcmdiRGF0YSA9IHRoaXMuX3JlbmRlckNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0KTtcbiAgICAgICAgbGV0IGFscGhhRGF0YSA9IHRoaXMuX2FscGhhQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQpO1xuXG4gICAgICAgIGxldCByZ2JEYXRhTGVuID0gcmdiRGF0YS5kYXRhLmxlbmd0aDtcblxuICAgICAgICAvLyBHZXQgZ3JheXNjYWxlIHZhbHVlIGZyb20gYWxwaGEgZGF0YVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChyZ2JEYXRhTGVuIC0gMyk7IGkgKz0gNCkge1xuXG4gICAgICAgICAgICBsZXQgYVIgPSBhbHBoYURhdGEuZGF0YVtpXTtcbiAgICAgICAgICAgIGxldCBhQiA9IGFscGhhRGF0YS5kYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGxldCBhRyA9IGFscGhhRGF0YS5kYXRhW2kgKyAyXTtcblxuICAgICAgICAgICAgLy8gU2V0IHJnYmEncyBBbHBoYSB2YWx1ZSB0byB0aGUgZ3JheXNjYWxlIHZhbHVlXG4gICAgICAgICAgICByZ2JEYXRhLmRhdGFbaSArIDNdID0gKGFSICsgYUIgKyBhRykgLyAzOyAvLyBBdmVyYWdlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0LnB1dEltYWdlRGF0YShyZ2JEYXRhLCAwLCAwKTtcbiAgICB9XG5cbiAgICBfc3RhcnRSZW5kZXJMb29wKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3F1ZXVlZEZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZWRGcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlZEZyYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFJlbmRlckxvb3AoKTtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc3RvcFJlbmRlckxvb3AoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdzdG9wIHJlbmRlcicpO1xuICAgICAgICBpZiAodGhpcy5fcXVldWVkRnJhbWUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnF1ZXVlZEZyYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9uYXRpdmVWaWRlb01ldGFkYXRhSGFuZGxlcihldmVudCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuICAgIH1cblxuICAgIF9uYXRpdmVWaWRlb1BsYXlpbmdIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFJlbmRlckxvb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9uYXRpdmVWaWRlb1BhdXNlSGFuZGxlcihldmVudCkge1xuICAgICAgICBpZiAodGhpcy51c2VGYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFJlbmRlckxvb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFscGhhVmlkZW87XG4iLCJcbi8vIFppbXBsaXN0IERlcGVuZGVuY2llc1xuaW1wb3J0IEJhc2VWaWV3IGZyb20gJ3ppbXBsaXN0L2Rpc3BsYXkvQmFzZVZpZXcnO1xuaW1wb3J0IFN0eWxlIGZyb20gJ3ppbXBsaXN0L3V0aWxzL1N0eWxlJztcbmltcG9ydCBXaW5kb3dNYW5hZ2VyIGZyb20gJ3ppbXBsaXN0L3V0aWxzL1dpbmRvd01hbmFnZXInO1xuaW1wb3J0IFRvdWNoIGZyb20gJ3ppbXBsaXN0L2lucHV0L1RvdWNoJztcblxuLy8gaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L2dldERvY3VtZW50UmVjdCc7XG5cbmNsYXNzIENhcmVlclNsaWRlciBleHRlbmRzIEJhc2VWaWV3IHtcblxuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgc3VwZXIoZWwsIHsgYnJlYWtwb2ludHMgOiBbJ3h4cycsICdzJywgJ20nXX0pO1xuXG4gICAgICAgIHRoaXMuaXRlbUNvbnRhaW5lciA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNsaWRlci1pdGVtLWNvbnRhaW5lcicpO1xuXG4gICAgICAgIHRoaXMuaXRlbXMgPSBBcnJheS5mcm9tKCB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbGlkZXItaXRlbScpICk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmNvdW50VmlzaWJsZUl0ZW1zKCk7XG5cbiAgICAgICAgdGhpcy5nb3RvSXRlbSgwKTtcblxuICAgICAgICAvLyBzZXR1cCBET00gZXZlbnRzXG4gICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ2NsaWNrJywgdGhpcy5fbmF2Q2xpY2tIYW5kbGVyLCAnYnV0dG9uJyk7XG5cbiAgICAgICAgLy8gU2V0dXAgdG91Y2ggZGV0ZWN0aW9uXG4gICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlciA9IG5ldyBUb3VjaCggdGhpcy5lbCApO1xuXG4gICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5vbignc3dpcGUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBpdGVtSW5kZXggPSB0aGlzLmN1cnJlbnRJbmRleCArICgoZXZlbnQuZGlzdGFuY2UueCA+IDApID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGl0ZW1JbmRleCA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbih0aGlzLml0ZW1zLmxlbmd0aCAtIDEsIGl0ZW1JbmRleCApKTtcblxuICAgICAgICAgICAgdGhpcy5nb3RvSXRlbSggaXRlbUluZGV4ICk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgY291bnRWaXNpYmxlSXRlbXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jdXJyZW50QnJlYWtwb2ludC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlICd4eHMnOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2l6ZSgpIHtcblxuICAgICAgICAvLyBtZWFzdXJlIGl0ZW0gd2lkdGggYnkgZ2V0dGluZ1xuICAgICAgICB0aGlzLml0ZW1XaWR0aCA9IHRoaXMuaXRlbXNbMV0ub2Zmc2V0TGVmdDtcblxuICAgIH1cblxuXG4gICAgYnJlYWtwb2ludENoYW5nZWQoYnJlYWtwb2ludCwgcHJldmlvdXNCcmVha3BvaW50KSB7XG4gICAgICAgIHN1cGVyLmJyZWFrcG9pbnRDaGFuZ2VkKGJyZWFrcG9pbnQsIHByZXZpb3VzQnJlYWtwb2ludCk7XG4gICAgICAgIHRoaXMuY291bnRWaXNpYmxlSXRlbXMoKTtcbiAgICAgICAgdGhpcy5nb3RvSXRlbSh0aGlzLmN1cnJlbnRJbmRleCk7XG4gICAgfVxuXG4gICAgZ290b0l0ZW0oaXRlbUluZGV4KSB7XG5cbiAgICAgICAgU3R5bGUuc2V0KHRoaXMuaXRlbUNvbnRhaW5lciwge1xuICAgICAgICAgICAgdHJhbnNmb3JtIDogYHRyYW5zbGF0ZVgoLSR7aXRlbUluZGV4ICogdGhpcy5pdGVtV2lkdGh9cHgpYFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzaG93IGhpZGUgZWxlbWVudHNcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKCAoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPj0gaXRlbUluZGV4ICYmIGkgPD0gaXRlbUluZGV4ICsgdGhpcy52aXNpYmxlSXRlbXMgLSAxICkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2hvdy9oaWRlIG5hdiBidXR0b25zXG4gICAgICAgIGlmIChpdGVtSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnaGlkZS1wcmV2Jyk7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUtbmV4dCcpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1JbmRleCA9PT0gdGhpcy5pdGVtcy5sZW5ndGggLSB0aGlzLnZpc2libGVJdGVtcykge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlLXByZXYnKTtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnaGlkZS1uZXh0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUtcHJldicpO1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlLW5leHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gaXRlbUluZGV4O1xuXG4gICAgfVxuXG4gICAgLypcblxuICAgIEV2ZW50IEhhbmRsZXJzXG5cbiAgICAgKi9cblxuICAgIF9uYXZDbGlja0hhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgbGV0IGl0ZW1JbmRleDtcbiAgICAgICAgaWYgKCBldmVudC5kZWxlZ2F0ZVRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3ByZXYnKSApIHtcbiAgICAgICAgICAgIGl0ZW1JbmRleCA9IE1hdGgubWF4KCAwLCB0aGlzLmN1cnJlbnRJbmRleCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbUluZGV4ID0gTWF0aC5taW4oIHRoaXMuaXRlbXMubGVuZ3RoIC0gdGhpcy52aXNpYmxlSXRlbXMsIHRoaXMuY3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nb3RvSXRlbSggaXRlbUluZGV4ICk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcmVlclNsaWRlcjsiLCIvLyBUaGlyZCBwYXJ0eSBkZXBlbmRlbmNpZXNcblxuLy8gVVpJSyBEZXBlZGVuY2llc1xuaW1wb3J0IEJhc2VWaWV3IGZyb20gJ3ppbXBsaXN0L2Rpc3BsYXkvQmFzZVZpZXcnO1xuXG4vLyBMb2NhbCBhcHAgRGVwZW5kZW5jaWVzXG5cblxuLyoqXG4gKiBTZWxlY3Qgc3R5bGUgbGluayBsaXN0XG4gKi9cbmNsYXNzIExpbmtTZWxlY3QgZXh0ZW5kcyBCYXNlVmlldyB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuXG4gICAgICAgIHN1cGVyKGVsLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmFkZERvbUV2ZW50KCdjbGljaycsIHRoaXMuX2xhYmVsQ2xpY2tIYW5kbGVyLCAnLmxhYmVsJyk7XG4gICAgfVxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBQdWJsaWMgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHJpdmF0ZSBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9sYWJlbENsaWNrSGFuZGxlcihldmVudCkge1xuXG5cbiAgICAgICAgaWYgKCB0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucygnZXhwYW5kZWQnKSApIHtcblxuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdleHBhbmRlZCcpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjbG9zZScsIHt9KTtcbiAgICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2V4cGFuZGVkJyk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ29wZW4nLCB7fSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtTZWxlY3Q7XG4iLCIvLyBUaGlyZCBwYXJ0eSBkZXBlbmRlbmNpZXNcbmltcG9ydCB6aXBXaXRoIGZyb20gJ2xvZGFzaC96aXBXaXRoJztcbmltcG9ydCBhbmltZSBmcm9tICdhbmltZWpzJztcblxuLy8gWmltcGxpc3QgRGVwZWRlbmNpZXNcbmltcG9ydCBCYXNlVmlldyBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L0Jhc2VWaWV3JztcbmltcG9ydCBTdHlsZSBmcm9tICd6aW1wbGlzdC91dGlscy9TdHlsZSc7XG5cbi8vIExvY2FsIGFwcCBEZXBlbmRlbmNpZXNcbmltcG9ydCBZb3V0dWJlUGxheWVyIGZyb20gJ2FwcC9jb21wb25lbnRzL1lvdXR1YmVQbGF5ZXInO1xuXG4vLyBIaWRkZW4gY29uc3RzXG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgTWVkaWFHYWxsZXJ5IGV4dGVuZHMgQmFzZVZpZXcge1xuXG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcihlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy52aXN1YWxDb250YWluZXIgICAgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5nYWxsZXJ5LXZpc3VhbC1hbmltYXRvcicpO1xuICAgICAgICB0aGlzLnRleHRDb250YWluZXIgICAgICA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmdhbGxlcnktdGV4dC1jb250ZW50Jyk7XG5cbiAgICAgICAgdGhpcy52aXN1YWxJdGVtcyA9IEFycmF5LmZyb20oIHRoaXMudmlzdWFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5nYWxsZXJ5LWl0ZW0nKSApO1xuICAgICAgICB0aGlzLnRleHRJdGVtcyA9IEFycmF5LmZyb20oIHRoaXMudGV4dENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuZ2FsbGVyeS1pdGVtLXRleHQnKSApO1xuXG4gICAgICAgIHRoaXMuaW5kZXhFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmdhbGxlcnktaXRlbS1pbmRleCA+IC52YWx1ZScpO1xuXG4gICAgICAgIC8vIG1lcmdlIHR3byBhcnJheXMgdG9nZXRoZXIgaW50byBvYmplY3RcbiAgICAgICAgdGhpcy5pdGVtcyA9IHppcFdpdGgoIHRoaXMudmlzdWFsSXRlbXMsIHRoaXMudGV4dEl0ZW1zLCAodmlzdWFsLCB0ZXh0KSA9PiAge1xuICAgICAgICAgICAgdmlzdWFsLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIHJldHVybiB7dmlzdWFsOiB2aXN1YWwsIHRleHQ6IHRleHR9O1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IDA7XG5cbiAgICAgICAgdGhpcy50ZXh0SXRlbXNbIHRoaXMuY3VycmVudEluZGV4IF0uY2xhc3NMaXN0LmFkZCgnY3VycmVudCcpO1xuXG4gICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ2NsaWNrJywgdGhpcy5fbmF2Q2xpY2tIYW5kbGVyLCAnLmdhbGxlcnktbmF2IGJ1dHRvbicpO1xuXG4gICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ2NsaWNrJywgdGhpcy5fdmlkZW9JdGVtQ2xpY2tIYW5kbGVyLCAnLmdhbGxlcnktaXRlbS5pdGVtLXZpZGVvJyk7XG5cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFB1YmxpYyBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIGJyZWFrcG9pbnRDaGFuZ2VkKGJyZWFrcG9pbnQsIHByZXZpb3VzQnJlYWtwb2ludCkge1xuXG4gICAgfVxuXG5cbiAgICByZXNpemUoKSB7XG5cbiAgICAgICAgLy8gcGxhY2UgYWxsIGl0ZW1zIGluIGEgcm93XG4gICAgICAgIHRoaXMudmlzdWFsSXRlbXMuZm9yRWFjaCggKGl0ZW0sIGkpID0+IHtcblxuICAgICAgICAgICAgU3R5bGUuc2V0KCBpdGVtLCB7bGVmdDogYCR7aSoxMDB9JWB9ICk7XG5cbiAgICAgICAgfSApO1xuXG4gICAgfVxuXG4gICAgZ290b0l0ZW0oaXRlbUluZGV4KSB7XG4gICAgICAgIGlmIChpdGVtSW5kZXggIT09IHRoaXMuY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SXRlbSA9IHRoaXMuaXRlbXNbIHRoaXMuY3VycmVudEluZGV4IF07XG4gICAgICAgICAgICBjb25zdCBxdWV1ZWRJdGVtID0gdGhpcy5pdGVtc1sgaXRlbUluZGV4IF07XG5cbiAgICAgICAgICAgIC8vIGdldCBkaXJjdGlvbiBvZiB0cmFuc2l0aW9uIC8vIFRPRE8gYWRhcHQgZm9yIGluZmluaXRlIHNsaWRlclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gKGl0ZW1JbmRleCA8IHRoaXMuY3VycmVudEluZGV4KSA/IC0xIDogMTsgLy8gVE9ETyB1c2UgZGlyZWN0aW9uIGZvciBzbGlkaW5nIHdpbmRvdyBlZmZldFxuXG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGguYWJzKCBpdGVtSW5kZXggLSB0aGlzLmN1cnJlbnRJbmRleCkgKiA1MDA7XG5cbiAgICAgICAgICAgIGFuaW1lKHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzIDogdGhpcy52aXN1YWxDb250YWluZXIsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYIDogYCR7IC0oaXRlbUluZGV4ICogMTAwKSB9JWAsXG4gICAgICAgICAgICAgICAgZWFzaW5nIDogJ2Vhc2VJbk91dEN1YmljJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0ZXh0c1xuICAgICAgICAgICAgdGhpcy50ZXh0SXRlbXNbIHRoaXMuY3VycmVudEluZGV4IF0uY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudCcpO1xuICAgICAgICAgICAgdGhpcy50ZXh0SXRlbXNbIGl0ZW1JbmRleCBdLmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnQnKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGluZGV4XG4gICAgICAgICAgICB0aGlzLmluZGV4RWwudGV4dENvbnRlbnQgPSBgJHtpdGVtSW5kZXgrMX0gLyAke3RoaXMuaXRlbXMubGVuZ3RofWA7XG5cbiAgICAgICAgICAgIC8vIFN0cCB2aWRlbyBwbGF5ZXIgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VmlkZW9QbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWRlb1BsYXllci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWRlb1BsYXllciA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN3YXAgcmVmZXJlbmNlcyBhdCB0aGUgZW5kXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGl0ZW1JbmRleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHJpdmF0ZSBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIEV2ZW50IEhhbmRsZXJzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgICBfbmF2Q2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIGxldCBxdWV1ZWRJdGVtID0gKCBldmVudC5kZWxlZ2F0ZVRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3ByZXYnKSApID8gdGhpcy5jdXJyZW50SW5kZXggLSAxOiB0aGlzLmN1cnJlbnRJbmRleCArIDE7XG5cbiAgICAgICAgLy8gY2xhbXAgdmFsdWVzXG4gICAgICAgIHF1ZXVlZEl0ZW0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLml0ZW1zLmxlbmd0aCAtIDEsIHF1ZXVlZEl0ZW0pKTtcblxuICAgICAgICB0aGlzLmdvdG9JdGVtKCBxdWV1ZWRJdGVtICk7XG4gICAgfVxuXG4gICAgX3ZpZGVvSXRlbUNsaWNrSGFuZGxlcihldmVudCkge1xuXG4gICAgICAgIGNvbnN0IHZpZGVvQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZpZGVvQ29udGFpbmVyLmNsYXNzTmFtZSA9ICd5b3V0dWJlLXBsYXllcic7XG5cbiAgICAgICAgY29uc3QgeW91dHViZVBsYXllciA9IG5ldyBZb3V0dWJlUGxheWVyKCB2aWRlb0NvbnRhaW5lciwge1xuICAgICAgICAgICAgdmlkZW9JZDogZXZlbnQuZGVsZWdhdGVUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXZpZGVvLWlkJyksXG4gICAgICAgICAgICBhdXRvUGxheTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRWaWRlb1BsYXllciA9IHlvdXR1YmVQbGF5ZXI7XG5cbiAgICAgICAgLy8gQXBwZW5kIHBsYXllciB0byBjb250YWluZXJcbiAgICAgICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQuYXBwZW5kQ2hpbGQoIHlvdXR1YmVQbGF5ZXIuZWwgKTtcblxuICAgIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lZGlhR2FsbGVyeTtcbiIsIi8vIFRoaXJkIHBhcnR5IGRlcGVuZGVuY2llc1xuaW1wb3J0IGFuaW1lIGZyb20gJ2FuaW1lanMnO1xuXG4vLyBaaW1wbGlzdCBEZXBlZGVuY2llc1xuaW1wb3J0IEJhc2VWaWV3IGZyb20gJ3ppbXBsaXN0L2Rpc3BsYXkvQmFzZVZpZXcnO1xuaW1wb3J0IFRvdWNoIGZyb20gJ3ppbXBsaXN0L2lucHV0L1RvdWNoJztcbmltcG9ydCBTdHlsZSBmcm9tICd6aW1wbGlzdC91dGlscy9TdHlsZSc7XG5pbXBvcnQgV2luZG93TWFuYWdlciBmcm9tICd6aW1wbGlzdC91dGlscy9XaW5kb3dNYW5hZ2VyJztcblxuLy8gTG9jYWwgYXBwIERlcGVuZGVuY2llc1xuXG5cbi8vIEhpZGRlbiBjb25zdHNcbmNvbnN0IFRSQU5TSVRJT05fU1BFRUQgPSAxLjI1O1xuXG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgUHJvZmlsZVNsaWRlciBleHRlbmRzIEJhc2VWaWV3IHtcblxuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgc3VwZXIoZWwsIHticmVha3BvaW50cyA6IFsneHhzJywgJ20nXX0pO1xuXG4gICAgICAgIC8vIFNhdmUgRE9NIHJlZmVyZW5jZXNcbiAgICAgICAgdGhpcy5faXRlbUNvbnRhaW5lciA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLml0ZW0tY29udGFpbmVyJyk7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gQXJyYXkuZnJvbSggdGhpcy5faXRlbUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuY2FyZWVyLXByb2ZpbGUnKSApO1xuXG4gICAgICAgIC8vIFN0YXRlIHZhcnNcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRPZmZzZXQgPSAwO1xuXG4gICAgICAgIC8vIFRvdWNoIGhhbmRsaW5nXG4gICAgICAgIHRoaXMuX3RvdWNoVHJhY2tlciA9IG5ldyBUb3VjaCh0aGlzLmVsKTtcblxuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuX3RvdWNoVHJhY2tlciwgJ21vdmUnLCB0aGlzLl90b3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLl90b3VjaFRyYWNrZXIsICdlbmQnLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIpO1xuXG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFB1YmxpYyBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIGJyZWFrcG9pbnRDaGFuZ2VkKGJyZWFrcG9pbnQsIHByZXZpb3VzQnJlYWtwb2luKSB7XG5cbiAgICAgICAgaWYgKCBicmVha3BvaW50Lm5hbWUgPT09ICdtJykge1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmVzaXplKCkge1xuXG4gICAgICAgIGlmICggIXRoaXMubWluV2lkdGgoJ20nKSApIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1XaWR0aCA9IHRoaXMuX2l0ZW1zWzBdLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faXRlbU1hcmdpbiA9IHRoaXMuX2l0ZW1zWzFdLm9mZnNldExlZnQgLSB0aGlzLl9pdGVtc1swXS5vZmZzZXRMZWZ0IC0gdGhpcy5faXRlbVdpZHRoO1xuXG4gICAgICAgICAgICB0aGlzLl9pdGVtT2Zmc2V0ID0gdGhpcy5faXRlbVdpZHRoICsgdGhpcy5faXRlbU1hcmdpbjtcblxuICAgICAgICAgICAgLy8gb2Zmc2V0IGNvbnRhaW5lciB0byBtYWludGFpbiBpdGVtIGNlbnRlcmluZ1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IChXaW5kb3dNYW5hZ2VyLndpZHRoIC0gdGhpcy5faXRlbVdpZHRoKSAvIDI7XG4gICAgICAgICAgICBTdHlsZS5zZXQoIHRoaXMuX2l0ZW1Db250YWluZXIsIHsgbGVmdDogb2Zmc2V0IH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIFN0eWxlLnNldCggdGhpcy5faXRlbUNvbnRhaW5lciwge2xlZnQ6IG51bGwsIHRyYW5zZm9ybTogbnVsbH0pO1xuXG4gICAgICAgICAgICAvLyB0aGlzLl9pdGVtQ29udGFpbmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdsZWZ0Jyk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZ290b0l0ZW0oaXRlbUluZGV4LCBhbmltYXRlID0gdHJ1ZSkge1xuXG4gICAgICAgIC8vIGNhbGMgcHggb2ZmZXN0IGZvciBpbmRleFxuICAgICAgICBsZXQgb2Zmc2V0ID0gLShpdGVtSW5kZXggKiB0aGlzLl9pdGVtT2Zmc2V0KTtcblxuICAgICAgICAvLyBEdXJhdGlvbiByZWxhdGl2ZSB0byB0aGUgZGlzdGFuY2UgdG8gc2Nyb2xsXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IE1hdGgubWF4KCAxNTAsIE1hdGguYWJzKCBvZmZzZXQgLSB0aGlzLmN1cnJlbnRPZmZzZXQpICogVFJBTlNJVElPTl9TUEVFRCk7IC8vIGF0IGxlYXN0IDEwMG1zIHRvIHNuYXAgYmFjayBmcm9tIGVuZFxuXG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICBhbmltZSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0cyA6IHRoaXMuX2l0ZW1Db250YWluZXIsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYIDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVhc2luZyA6ICdlYXNlT3V0Q3ViaWMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFN0eWxlLnNldCggdGhpcy5faXRlbUNvbnRhaW5lciwgeyB0cmFuc2Zvcm0gOiBgdHJhbnNsYXRlWCgke29mZnNldH1weClgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2F2ZSBzdGF0ZSB2YXJzXG4gICAgICAgIHRoaXMuY3VycmVudE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBpdGVtSW5kZXg7XG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFByaXZhdGUgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF90b3VjaE1vdmVIYW5kbGVyKCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1pbldpZHRoKCdtJykpIHJldHVybjtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZVggPSB0aGlzLl90b3VjaFRyYWNrZXIuZGlzdGFuY2VYO1xuICAgICAgICBjb25zdCBkaXN0YW5jZVkgPSB0aGlzLl90b3VjaFRyYWNrZXIuZGlzdGFuY2VZO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVgpID4gTWF0aC5hYnMoZGlzdGFuY2VZKSkge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuY3VycmVudE9mZnNldCArIGRpc3RhbmNlWDtcbiAgICAgICAgICAgIFN0eWxlLnNldCh0aGlzLl9pdGVtQ29udGFpbmVyLCB7dHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke29mZnNldH1weClgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdG91Y2hFbmRIYW5kbGVyKCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1pbldpZHRoKCdtJykpIHJldHVybjtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZVggPSB0aGlzLl90b3VjaFRyYWNrZXIuZGlzdGFuY2VYO1xuICAgICAgICBjb25zdCBkaXN0YW5jZVkgPSB0aGlzLl90b3VjaFRyYWNrZXIuZGlzdGFuY2VZO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVgpID4gMzAgJiYgTWF0aC5hYnMoZGlzdGFuY2VYKSA+IE1hdGguYWJzKGRpc3RhbmNlWSkpIHtcblxuICAgICAgICAgICAgbGV0IHF1ZXVlZEluZGV4ID0gKGRpc3RhbmNlWCA+IDApID8gdGhpcy5jdXJyZW50SW5kZXggLSAxIDogdGhpcy5jdXJyZW50SW5kZXggKyAxO1xuXG4gICAgICAgICAgICAvLyBDbGFtcCB0byBpdGVtIHJhbmdlXG4gICAgICAgICAgICBxdWV1ZWRJbmRleCA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggdGhpcy5faXRlbXMubGVuZ3RoIC0gMSwgcXVldWVkSW5kZXgpICk7XG5cbiAgICAgICAgICAgIHRoaXMuZ290b0l0ZW0oIHF1ZXVlZEluZGV4ICk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gc25hcCBiYWNrIHRvIHRoZSBjdXJyZW50IGl0ZW0gaWYgaXQgaGFzbid0IG1vdmVkIG11Y2hcbiAgICAgICAgICAgIHRoaXMuZ290b0l0ZW0oIHRoaXMuY3VycmVudEluZGV4ICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2ZpbGVTbGlkZXI7XG4iLCIvLyBUaGlyZCBwYXJ0eSBkZXBlbmRlbmNpZXNcbmltcG9ydCBmbGF0dGVuIGZyb20gJ2xvZGFzaC9mbGF0dGVuJztcblxuLy8gWmltcGxpc3QgRGVwZW5kZW5jaWVzXG5pbXBvcnQgQmFzZVZpZXcgZnJvbSAnemltcGxpc3QvZGlzcGxheS9CYXNlVmlldyc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gJ3ppbXBsaXN0L2Rpc3BsYXkvZ2V0RG9jdW1lbnRSZWN0JztcbmltcG9ydCBTdHlsZSBmcm9tICd6aW1wbGlzdC91dGlscy9TdHlsZSc7XG5pbXBvcnQgV2luZG93TWFuYWdlciBmcm9tICd6aW1wbGlzdC91dGlscy9XaW5kb3dNYW5hZ2VyJztcblxuLy8gTG9jYWwgYXBwIERlcGVuZGVuY2llc1xuXG5cbi8vIEhpZGRlbiBjb25zdHNcbmNvbnN0IFBBVEhfV0lEVEhfUkFUSU8gPSAwLjM2O1xuY29uc3QgV0FZUE9JTlRfSEVJR0hUX1JBVElPID0gMC42OyAvLyBUaGlzIGlzIHVzZWQgYmVjYXVzZSB0aGUgd2F5IHBvaW50cyB2aXN1YWwgY2VudGVycyBhcmVuJ3QgdGhlIHdob2xlIGRpbWVuc2lvbnMgY2VudGVyXG5jb25zdCBDVVRPVVRfUEFERElORyA9IDEwO1xuY29uc3QgU0NST0xMX1BBRERJTkcgPSAyNjYgKyAod2luZG93LmlubmVySGVpZ2h0ICogMC4yKTsgLy8gMjY2ID0gaGVpZ2h0IG9mIHRoZSBoZWFkZXJcbmNvbnN0IE1BU0tfU1BFRUQgPSA3NTA7XG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgUHJvZ3Jlc3NQYXRoIGV4dGVuZHMgQmFzZVZpZXcge1xuXG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcihlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBlbGVtZW50cyB0aGF0IGRlZmluZSB0aGUgcHJvZ3Jlc3MgcGF0aHMgd2F5cG9pbnRzXG4gICAgICAgIHRoaXMud2F5cG9pbnRzID0gb3B0aW9ucy53YXlwb2ludHM7XG5cbiAgICAgICAgLy8gY3V0b3V0cyBhcmUgZWxlbXMgdGhhdCBtYXNrIHRoZSByZW5kZXJlcnMgKGluIHJlYWxpdHkgdGhleSBnbyBiYWNrIGFuZCBjbGVhciB6b25lcyBvbiB0aGUgcmVuZGVyZXJzKVxuICAgICAgICB0aGlzLmN1dG91dHMgPSBvcHRpb25zLmN1dG91dHM7XG5cbiAgICAgICAgLy8gY3JlYXRlIHNjcm9sbGluZyBUcmFja2VyIGZvciBhbmltYXRpb25cbiAgICAgICAgdGhpcy5jdXJyZW50TWFza0hlaWdodCA9IDA7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlUGF0aHNET00oKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG5cbiAgICAgICAgLy8gQWZ0ZXIgZmlyc3QgcmVuZGVyIHN0YXJ0IGxpc3RlbmluZyBmb3IgZXZlbnRzIHRvIHRyaWdnZXIgYW5pbWF0ZWQgbWFza3NcbiAgICAgICAgdGhpcy5saXN0ZW5UbyggV2luZG93TWFuYWdlciwgJ3Njcm9sbCcsIHRoaXMuX3Njcm9sbEhhbmRsZXIpO1xuXG4gICAgICAgIHRoaXMuYnJlYWtwb2ludENoYW5nZWQoKTtcbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFB1YmxpYyBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIGJyZWFrcG9pbnRDaGFuZ2VkKGJyZWFrcG9pbnQsIHByZXZpb3VzQnJlYWtwb2ludCkge1xuICAgICAgICBzdXBlci5icmVha3BvaW50Q2hhbmdlZChicmVha3BvaW50LCBwcmV2aW91c0JyZWFrcG9pbnQpO1xuXG4gICAgICAgIGlmICggdGhpcy5taW5XaWR0aCgncycpICkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWFza0hlaWdodCA9IE1hdGgubWF4KCB0aGlzLmN1cnJlbnRNYXNrSGVpZ2h0LCBXaW5kb3dNYW5hZ2VyLnNjcm9sbFBvc2l0aW9uLnRvcCArIChXaW5kb3dNYW5hZ2VyLmhlaWdodCAqIDAuOSkpO1xuXG4gICAgICAgICAgICBTdHlsZS5zZXQoIHRoaXMuX3BhdGhDb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuY3VycmVudE1hc2tIZWlnaHQsIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IHRoaXMuY3VycmVudE1hc2tIZWlnaHQgKiBNQVNLX1NQRUVEXG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgU3R5bGUuc2V0KCB0aGlzLl9wYXRoQ29udGFpbmVyLCB7aGVpZ2h0OiAnYXV0bycsIG92ZXJmbG93OiAndmlzaWJsZSd9KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmVzaXplKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFByaXZhdGUgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gICAgX2NyZWF0ZVBhdGhzRE9NKCkge1xuICAgICAgICBsZXQgcGF0aENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwYXRoQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdwcm9ncmVzcy1wYXRoLW1hc2snO1xuXG4gICAgICAgIGxldCByZW5kZXJlcnMgPSBbXTtcblxuICAgICAgICAvLyBDcmVhdGUgYSByZW5kZXJlciBjYW52YXMgYmV0d2VlbiBlYWNoIHdheXBvaW50XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53YXlwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcGF0aFJlbmRlcmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBwYXRoQ29udGFpbmVyLmFwcGVuZENoaWxkKHBhdGhSZW5kZXJlcik7XG4gICAgICAgICAgICByZW5kZXJlcnMucHVzaChwYXRoUmVuZGVyZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZSBET00gcmVmZXJlbmNlc1xuICAgICAgICB0aGlzLl9wYXRoQ29udGFpbmVyID0gcGF0aENvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fcGF0aFJlbmRlcmVycyA9IHJlbmRlcmVycztcblxuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuX3BhdGhDb250YWluZXIpO1xuICAgIH1cblxuICAgIF9yZW5kZXIoKSB7XG4gICAgICAgIGxldCByb290RWxPZmZzZXQgPSBnZXREb2N1bWVudFJlY3QodGhpcy5lbCkudG9wO1xuXG4gICAgICAgIC8vIGdldCBvZmZzZXRzIGZvciBhbGwgdGhlIHdheXBvaW50c1xuICAgICAgICBsZXQgd2F5cG9pbnRPZmZzZXRzID0gdGhpcy53YXlwb2ludHMubWFwKHdheXBvaW50ID0+IGdldERvY3VtZW50UmVjdCh3YXlwb2ludCkpO1xuXG4gICAgICAgIC8vIEdldCBkaXNwbGF5ZWQgY2xpZW50IHJlY3RzIGZyb20gY3V0b3V0c1xuICAgICAgICBsZXQgY3V0b3V0UmVjdHMgPSB0aGlzLmN1dG91dHMubWFwKGN1dG91dCA9PiB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY3V0b3V0OiAnLCBjdXRvdXQpO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY3V0b3V0LmdldENsaWVudFJlY3RzKCkpLm1hcChyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgV2luZG93TWFuYWdlci5zY3JvbGxQb3NpdGlvbi50b3AgLSBDVVRPVVRfUEFERElORyxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgV2luZG93TWFuYWdlci5zY3JvbGxQb3NpdGlvbi5sZWZ0IC0gQ1VUT1VUX1BBRERJTkcsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoICsgKDIgKiBDVVRPVVRfUEFERElORyksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKyAoMiAqIENVVE9VVF9QQURESU5HKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZmxhdHRlbiBhcnJheSBmb3Igc2ltcGxlIGxvb3BpbmdcbiAgICAgICAgY3V0b3V0UmVjdHMgPSBmbGF0dGVuKGN1dG91dFJlY3RzKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhdGhSZW5kZXJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZW5kZXJlciA9IHRoaXMuX3BhdGhSZW5kZXJlcnNbaV07XG4gICAgICAgICAgICBsZXQgY3VycmVudFdheXBvaW50ID0gd2F5cG9pbnRPZmZzZXRzW2ldO1xuICAgICAgICAgICAgbGV0IG5leHRXYXlwb2ludCA9IHdheXBvaW50T2Zmc2V0c1tpICsgMV07XG5cbiAgICAgICAgICAgIC8vIFJlbmRlcmVycyBoYXZlIGFsdGVybmF0aW5nIGRpcmVjdGlvbnNcbiAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSAoaSAlIDIgPT09IDApID8gLTEgOiAxO1xuXG4gICAgICAgICAgICAvLyBHZXQgZGltZW5zaW9ucyBhbmQgcG9zaXRpb24gZm9yIG5ldyByZW5kZXJlclxuICAgICAgICAgICAgbGV0IHJlbmRlcmVySGVpZ2h0ID0gbmV4dFdheXBvaW50LnRvcCAtIGN1cnJlbnRXYXlwb2ludC50b3AgLSAoY3VycmVudFdheXBvaW50LmhlaWdodCAqIFdBWVBPSU5UX0hFSUdIVF9SQVRJTyk7XG4gICAgICAgICAgICBsZXQgcmVuZGVyZXJXaWR0aCA9IHJlbmRlcmVySGVpZ2h0ICogUEFUSF9XSURUSF9SQVRJTztcbiAgICAgICAgICAgIGxldCByZW5kZXJlckxlZnQgPSAoZGlyZWN0aW9uID4gMCkgPyAoV2luZG93TWFuYWdlci53aWR0aCArIGN1cnJlbnRXYXlwb2ludC53aWR0aCkgLyAyIDogKFdpbmRvd01hbmFnZXIud2lkdGggLyAyICkgLSAocmVuZGVyZXJXaWR0aCArIChjdXJyZW50V2F5cG9pbnQud2lkdGggLyAyKSk7XG4gICAgICAgICAgICBsZXQgcmVuZGVyZXJUb3AgPSBjdXJyZW50V2F5cG9pbnQudG9wICsgY3VycmVudFdheXBvaW50LmhlaWdodDtcblxuICAgICAgICAgICAgLy8gU2V0IGRpbWVuc2lvbnMgYXMgQ1NTIHZhbHVlcyBhbmQgcHJvcGVydGllcyAoY2FudmFzIG5lZWRzIHByb3BlcnR5IHRvIHNpemUgcHJvcGVybHkpXG4gICAgICAgICAgICBTdHlsZS5zZXQocmVuZGVyZXIsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVuZGVyZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlbmRlcmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRvcDogcmVuZGVyZXJUb3AgLSByb290RWxPZmZzZXQsXG4gICAgICAgICAgICAgICAgbGVmdDogcmVuZGVyZXJMZWZ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlbmRlcmVyLndpZHRoID0gcmVuZGVyZXJXaWR0aDtcbiAgICAgICAgICAgIHJlbmRlcmVyLmhlaWdodCA9IHJlbmRlcmVySGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBEcmF3IGRhc2hlZCBsaW5lIGFsb25nIHBhdGhcbiAgICAgICAgICAgIGxldCBjdHggPSByZW5kZXJlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCByZW5kZXJlcldpZHRoLCByZW5kZXJlckhlaWdodCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuNjUpJztcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLm1pbldpZHRoKCdzJykgPyBbNywgMTBdIDogWzQsIDhdKTsgLy8gc21hbGxlciBkYXNoZXMgb24gbW9iaWxlXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyV2lkdGggKiAxLjI1LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlckhlaWdodCAqIDAuMjUsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyV2lkdGggKiAxLjI1LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlckhlaWdodCAqIDAuNzUsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVySGVpZ2h0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhyZW5kZXJlcldpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJXaWR0aCAtIChyZW5kZXJlcldpZHRoICogMS4yNSksXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVySGVpZ2h0ICogMC4yNSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJXaWR0aCAtIChyZW5kZXJlcldpZHRoICogMS4yNSksXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVySGVpZ2h0ICogMC43NSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJIZWlnaHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAvLyBJbnRlcnNlY3Qgd2l0aCBjdXRvdXRzIHRvIGhpZGUvY2xlYXIgcGFydHMgb2YgdGhlIHJlbmRlcmVyXG4gICAgICAgICAgICBjdXRvdXRSZWN0cy5mb3JFYWNoKCBjdXRvdXQgPT4ge1xuXG4gICAgICAgICAgICAgICAgbGV0IGFYID0gTWF0aC5tYXgoY3V0b3V0LmxlZnQsIHJlbmRlcmVyTGVmdCk7XG4gICAgICAgICAgICAgICAgbGV0IGFZID0gTWF0aC5tYXgoY3V0b3V0LnRvcCwgcmVuZGVyZXJUb3ApO1xuXG4gICAgICAgICAgICAgICAgbGV0IGJYID0gTWF0aC5taW4oY3V0b3V0LmxlZnQgKyBjdXRvdXQud2lkdGgsIHJlbmRlcmVyTGVmdCArIHJlbmRlcmVyV2lkdGgpO1xuICAgICAgICAgICAgICAgIGxldCBiWSA9IE1hdGgubWluKGN1dG91dC50b3AgKyBjdXRvdXQuaGVpZ2h0LCByZW5kZXJlclRvcCArIHJlbmRlcmVySGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGN1dG91dCBhbmQgcmVuZGVyZXIgaW50ZXJzZWN0LCBjbGVhciB0aGUgaW50ZXJzZWN0aW5nIHBhcnQgZnJvbSB0aGUgcmVuZGVyZXJcbiAgICAgICAgICAgICAgICBpZiAoICEoYVggPj0gYlggfHwgYVkgPj0gYlkpICkge1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KGN1dG91dC5sZWZ0IC0gcmVuZGVyZXJMZWZ0LCBjdXRvdXQudG9wIC0gcmVuZGVyZXJUb3AsIGN1dG91dC53aWR0aCwgY3V0b3V0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9zY3JvbGxIYW5kbGVyKCkge1xuXG4gICAgICAgIC8vIFVwZGF0ZSBtYXNrIGhlaWdodFxuICAgICAgICBpZiAoIHRoaXMubWluV2lkdGgoJ3MnKSApIHtcbiAgICAgICAgICAgIGxldCBuZXdNYXNrSGVpZ2h0ID0gTWF0aC5tYXgoIHRoaXMuY3VycmVudE1hc2tIZWlnaHQsIFdpbmRvd01hbmFnZXIuc2Nyb2xsUG9zaXRpb24udG9wICsgV2luZG93TWFuYWdlci5oZWlnaHQgLSBTQ1JPTExfUEFERElORyk7XG5cbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IG5ld01hc2tIZWlnaHQgLSB0aGlzLmN1cnJlbnRNYXNrSGVpZ2h0O1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNYXNrSGVpZ2h0ID0gbmV3TWFza0hlaWdodDtcbiAgICAgICAgICAgIFN0eWxlLnNldCggdGhpcy5fcGF0aENvbnRhaW5lciwge1xuICAgICAgICAgICAgICAgIGhlaWdodCA6IHRoaXMuY3VycmVudE1hc2tIZWlnaHQsXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNpdGlvbkR1cmF0aW9uIDogZGlzdGFuY2UgKiBNQVNLX1NQRUVEXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2dyZXNzUGF0aDtcbiIsIi8vIFRoaXJkIHBhcnR5IGRlcGVuZGVuY2llc1xuaW1wb3J0IGZvckVhY2ggZnJvbSAnbG9kYXNoL2ZvckVhY2gnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJ2xvZGFzaC9kZWZhdWx0cyc7XG5cbi8vIFVaSUsgRGVwZWRlbmNpZXNcbmltcG9ydCBCYXNlVmlldyBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L0Jhc2VWaWV3JztcblxuLy8gTG9jYWwgYXBwIERlcGVuZGVuY2llc1xuXG5cbi8vIEhpZGRlbiBjb25zdHNcblxuXG4vKlxuXG4gU1RBVElDIEFQSSBNQU5JUFVMQVRJT05cblxuICovXG5jb25zdCBZT1VUVUJFX0FQSV9VUkwgPSBcImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2lmcmFtZV9hcGlcIjtcbmxldCBsb2FkaW5nU2NyaXB0O1xubGV0IHF1ZXVlZEluc3RhbmNlcyA9IFtdO1xuXG5mdW5jdGlvbiBsb2FkQVBJKGluc3RhbmNlKSB7XG5cbiAgICAvLyBxdWV1ZSB0aGUgcGxheWVyIGluc3RhbmNlXG4gICAgcXVldWVkSW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBjYWxsIGJhY2sgZm9yIHRoZSBBUEkuIG5hbWUgc3BlY2lmaWVkIGJ5IFlUIEFQSSBkb2NzXG4gICAgd2luZG93Lm9uWW91VHViZUlmcmFtZUFQSVJlYWR5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgY29uc29sZS5sb2coJ1lUOiAnLCB3aW5kb3cuWVQgKTtcbiAgICAgICAgLy8gY2FsbCBjcmVhdGUgcGxheWVyIG9uIGFsbCBxdWV1ZWQgaW5zdGFuY2VzXG4gICAgICAgIHdoaWxlICggcXVldWVkSW5zdGFuY2VzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0ID0gcXVldWVkSW5zdGFuY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoaW5zdC5vcHRpb25zLmF1dG9Mb2FkKSB7XG4gICAgICAgICAgICAgICAgaW5zdC5fY3JlYXRlUGxheWVyLmNhbGwoaW5zdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbG9hZCBBUEkgKG9uY2UpXG4gICAgaWYgKCAhbG9hZGluZ1NjcmlwdCApIHtcblxuICAgICAgICAvLyBjcmVhdGUgc2NyaXB0XG4gICAgICAgIGxvYWRpbmdTY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICAgICAgICBjb25zdCBmaXJzdFNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgICAgICAgZmlyc3RTY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGxvYWRpbmdTY3JpcHQsIGZpcnN0U2NyaXB0KTtcblxuICAgICAgICBsb2FkaW5nU2NyaXB0LmFzeW5jID0gZmFsc2U7XG4gICAgICAgIGxvYWRpbmdTY3JpcHQuc3JjID0gWU9VVFVCRV9BUElfVVJMO1xuXG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBhdXRvTG9hZCA6IHRydWVcbn07XG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgWW91dHViZVBsYXllciBleHRlbmRzIEJhc2VWaWV3IHtcblxuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgc3VwZXIoZWwsIGRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSApO1xuXG4gICAgICAgIHRoaXMudmlkZW9JZCA9ICggJ3ZpZGVvSWQnIGluIG9wdGlvbnMpID8gb3B0aW9ucy52aWRlb0lkIDogdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmlkZW8taWQnKTtcblxuICAgICAgICB0aGlzLnBsYXllckNvbnRhaW5lciA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnBsYXllci1jb250YWluZXInKTtcblxuICAgICAgICBpZiAoICF0aGlzLnBsYXllckNvbnRhaW5lciApIHtcbiAgICAgICAgICAgIHRoaXMucGxheWVyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLnBsYXllckNvbnRhaW5lci5jbGFzc05hbWUgPSAncGxheWVyLWNvbnRhaW5lcic7XG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKCB0aGlzLnBsYXllckNvbnRhaW5lciApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgQVBJIGhhcyBhbHJlYWR5IGxvYWRlZCwgY3JlYXRlIHRoZSBwbGF5ZXIgaW1lYWRpYXRseSBvdGhlcndpc2UsIHF1ZXVlIGl0XG4gICAgICAgIGlmICggd2luZG93LllUICYmIHRoaXMub3B0aW9ucy5hdXRvTG9hZCApIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVBsYXllcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZEFQSSggdGhpcyApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFB1YmxpYyBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIGJyZWFrcG9pbnRDaGFuZ2VkKGJyZWFrcG9pbnQsIHByZXZpb3VzQnJlYWtwb2ludCkge1xuXG4gICAgfVxuXG4gICAgcGxheSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BsYXllcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BsYXllclJlYWR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheWVyLnBsYXlWaWRlbygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JlcXVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXliYWNrUmVxdXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUGxheWVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BsYXllcikge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLnBhdXNlVmlkZW8oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wbGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllci5zdG9wVmlkZW8oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3BsYXllci5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFByaXZhdGUgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gICAgX2NyZWF0ZVBsYXllcigpIHtcbiAgICAgICAgdGhpcy5fcGxheWVyID0gbmV3IFlULlBsYXllciggdGhpcy5wbGF5ZXJDb250YWluZXIsIHtcbiAgICAgICAgICAgIHdpZHRoICAgOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQgIDogJzEwMCUnLFxuICAgICAgICAgICAgdmlkZW9JZCA6IHRoaXMudmlkZW9JZCxcbiAgICAgICAgICAgIHBsYXllclZhcnMgOiB7XG4gICAgICAgICAgICAgICAgbW9kZXN0YnJhbmRpbmcgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVsICAgICAgICAgICAgIDogZmFsc2UsIC8vIGRpc3BsYXkgcmVsYXRlZCB2aWRlb3MgYXQgdGhlIGVuZCBvZiB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICBzaG93aW5mbyAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aGVtZSAgICAgICAgICAgOiAnbGlnaHQnLFxuICAgICAgICAgICAgICAgIG9yaWdpbiAgICAgICAgICA6IHdpbmRvdy5sb2NhdGlvbi5kb21haW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXZlbnRzICA6IHtcbiAgICAgICAgICAgICAgICBvblJlYWR5ICAgICAgIDogdGhpcy5fcGxheWVyUmVhZHlIYW5kbGVyLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgb25TdGF0ZUNoYW5nZSA6IHRoaXMuX3BsYXllclN0YXRlQ2hhbmdlSGFuZGxlci5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYW4gYXV0b2xvYWQgdmlkZW8uIEluIGNhc2UgaXQgaXNuJ3QgdHJpZ2dlciBhIGxvYWRpbmcgZXZlbnQgYW55d2F5IHRvIGdldCBhbiBpbW1lZGlhdGUgVUkgcmVzcG9uc2UgZm9yIHRoZSB1c2VyXG4gICAgICAgIGlmICggIXRoaXMub3B0aW9ucy5hdXRvTG9hZCApIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlKCBZb3V0dWJlUGxheWVyLlNUQVRFLkxPQURJTkcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5vcHRpb25zLmF1dG9QbGF5ICkge1xuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIF91cGRhdGVTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICAvLyBjaGFuZ2UgY2xhc3MgbmFtZVxuICAgICAgICBsZXQgc3RhdGVDbGFzcyA9ICdzdGF0ZS0nICsgbmV3U3RhdGU7XG5cbiAgICAgICAgLy8gdXBkYXRlIGNsYXNzZXNcbiAgICAgICAgZm9yRWFjaChZb3V0dWJlUGxheWVyLlNUQVRFLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gbmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3N0YXRlLScgKyBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChzdGF0ZUNsYXNzKTtcblxuICAgICAgICAvLyB1cGRhdGUgaW50ZXJuYWwgdmFyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcblxuICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50IGZvciBzdGF0ZVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3U3RhdGUpO1xuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9wbGF5ZXJSZWFkeUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgLy8gcmUgYXNzaWduIHZhciBiZWNhdXNlIGl0IGhhcyBiZWVuIHJlcGxhY2VkIGJ5IHRoZSBZVCBpRnJhbWVcbiAgICAgICAgdGhpcy5wbGF5ZXJDb250YWluZXIgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5wbGF5ZXItY29udGFpbmVyJyk7XG5cbiAgICAgICAgdGhpcy5fcGxheWVyUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIGlmIHRoZSBwbGF5ZXIgd2FzIGxvYWRlZCB3aGVuIHRyeWluZyB0byBwbGF5IHRoZSB2aWRlbywgaXQgZ2V0cyBwbGF5ZWQgaGVyZVxuICAgICAgICBpZiAodGhpcy5fcGxheWJhY2tSZXF1c3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLnBsYXlWaWRlbygpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWJhY2tSZXF1c3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZWFkeScpO1xuICAgIH1cblxuICAgIF9wbGF5ZXJTdGF0ZUNoYW5nZUhhbmRsZXIoZXZlbnQpIHtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmRhdGEpIHtcbiAgICAgICAgICAgIGNhc2UgWVQuUGxheWVyU3RhdGUuUExBWUlORyA6XG5cbiAgICAgICAgICAgICAgIC8qIGlmIChWaWNoeS5Db25maWcuZW52ID09ICdkZXYnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BsYXllci5tdXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lTW9uaXRvcigpOyovXG5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZShZb3V0dWJlUGxheWVyLlNUQVRFLlBMQVlJTkcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFlULlBsYXllclN0YXRlLkJVRkZFUklORyA6XG4gICAgICAgICAgICAgICAgLy90aGlzLnNob3dQbGF5ZXIoKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9zdG9wVGltZU1vbml0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZShZb3V0dWJlUGxheWVyLlNUQVRFLkxPQURJTkcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFlULlBsYXllclN0YXRlLlBBVVNFRCA6XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fc3RvcFRpbWVNb25pdG9yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUoWW91dHViZVBsYXllci5TVEFURS5QQVVTRUQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFlULlBsYXllclN0YXRlLkVOREVEIDpcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9zdG9wVGltZU1vbml0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZShZb3V0dWJlUGxheWVyLlNUQVRFLkVOREVEKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5cbllvdXR1YmVQbGF5ZXIuU1RBVEUgPSB7XG4gICAgUEVORElORzogJ3BlbmRpbmcnLFxuICAgIExPQURJTkc6ICdsb2FkaW5nJyxcbiAgICBQTEFZSU5HOiAncGxheWluZycsXG4gICAgUEFVU0VEOiAncGF1c2VkJyxcbiAgICBFTkRFRDogJ2VuZGVkJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgWW91dHViZVBsYXllcjtcbiIsIi8vIFRoaXJkIHBhcnR5IGRlcGVuZGVuY2llc1xuaW1wb3J0IENvbG9yIGZyb20gJ2NvbG9yJztcbmltcG9ydCBhbmltZSBmcm9tICdhbmltZWpzJztcblxuLy8gWmltcGxpc3QgRGVwZWRlbmNpZXNcbmltcG9ydCBCYXNlVmlldyBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L0Jhc2VWaWV3JztcbmltcG9ydCBQb2ludCBmcm9tICd6aW1wbGlzdC9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQgU3R5bGUgZnJvbSAnemltcGxpc3QvdXRpbHMvU3R5bGUnO1xuaW1wb3J0IGluZGV4IGZyb20gJ3ppbXBsaXN0L2Rpc3BsYXkvZG9tL2luZGV4JztcbmltcG9ydCBlbXB0eSBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L2RvbS9lbXB0eSc7XG5pbXBvcnQgU3ByaXRlQW5pbWF0b3IgZnJvbSAnemltcGxpc3QvZGlzcGxheS9hbmltYXRpb24vU3ByaXRlQW5pbWF0b3InO1xuXG4vLyBMb2NhbCBhcHAgRGVwZW5kZW5jaWVzXG5pbXBvcnQgcmVuZGVyQmFja2dyb3VuZCBmcm9tICdhcHAvY29tcG9uZW50cy92YWx1ZXMtd2hlZWwvcmVuZGVyQmFja2dyb3VuZCc7XG5pbXBvcnQgZ2VuZXJhdGVQb2ludHMgZnJvbSAnYXBwL2NvbXBvbmVudHMvdmFsdWVzLXdoZWVsL2dlbmVyYXRlUG9pbnRzJztcblxuLy8gSGlkZGVuIGNvbnN0c1xuY29uc3QgV0hFRUxfUkFESVVTID0gMjUwO1xuY29uc3QgSU5UUk9fREVMQVkgPSAyNjA7XG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgVmFsdWVzV2hlZWwgZXh0ZW5kcyBCYXNlVmlldyB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuXG4gICAgICAgIHN1cGVyKGVsLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBDYW52YXNlc1xuICAgICAgICB0aGlzLmJnUmVuZGVyZXIgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5iZy1yZW5kZXJlcicpO1xuICAgICAgICB0aGlzLmxpbmVSZW5kZXJlciA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmxpbmUtcmVuZGVyZXInKTtcblxuICAgICAgICB0aGlzLnZhbHVlSXRlbXMgPSBBcnJheS5mcm9tKCB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy52YWx1ZXMtd2hlZWwtbGFyZ2UgLnZhbHVlLWl0ZW0nKSApO1xuICAgICAgICB0aGlzLmNvbG9ycyA9IHRoaXMudmFsdWVJdGVtcy5tYXAoIGxhYmVsID0+IGxhYmVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xvcicpICk7XG5cbiAgICAgICAgdGhpcy50ZXh0Q29udGFpbmVyID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcudmFsdWVzLXdoZWVsLWxhcmdlIC52YWx1ZS10ZXh0LWNvbnRhaW5lcicpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiAwLTIgdmFsdWVzIGNvbnRhaW5pbmcgc2VsZWN0ZWQgdmFsdWVzIChyZXByZXNlbnRlZCBieSB0aGVpciBET00gbm9kZXMpXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlVmFsdWVzID0gW107XG5cbiAgICAgICAgLy8gb2JqZWN0IHdpdGggYSBub3JtYWxpemVkIG51bWJlciBmb3IgZXZlcnkgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBsaW5lcyBwcm9ncmVzc1xuICAgICAgICB0aGlzLmxpbmVQcm9ncmVzcyA9IHt9O1xuXG4gICAgICAgIHRoaXMudmFsdWVJdGVtcy5tYXAoIHZhbHVlID0+IHZhbHVlLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZS1pZCcpICkuZm9yRWFjaCggdmFsdWVJZCA9PiB0aGlzLmxpbmVQcm9ncmVzc1sgdmFsdWVJZCBdID0gMCk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZSA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnZhbHVlcy13aGVlbC1sYXJnZSAudmFsdWUtdGV4dC1jb250YWluZXIgLm1lc3NhZ2UnKTtcblxuICAgICAgICAvLyBTZXR1cCBwb2ludHMgb24gdGhlIGNpcmNsZVxuICAgICAgICAvKmxldCBzdGVwUmFkID0gKE1hdGguUEkgKiAyKSAvIHRoaXMudmFsdWVJdGVtcy5sZW5ndGg7XG4gICAgICAgIGxldCBxdWF0ZXJSYWQgPSAoTWF0aC5QSSAqIDIpIC8gNDtcblxuICAgICAgICB0aGlzLndoZWVsUG9pbnRzID0gdGhpcy52YWx1ZUl0ZW1zLm1hcCggKHN0ZXAsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBhbmdsZSA9IChzdGVwUmFkICogaSkgLSBxdWF0ZXJSYWQ7XG4gICAgICAgICAgICBsZXQgeCA9IFdIRUVMX1JBRElVUyAqIE1hdGguY29zKCBhbmdsZSApICsgV0hFRUxfUkFESVVTO1xuICAgICAgICAgICAgbGV0IHkgPSBXSEVFTF9SQURJVVMgKiBNYXRoLnNpbiggYW5nbGUgKSArIFdIRUVMX1JBRElVUztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoIHgsIHksIGFuZ2xlLCBXSEVFTF9SQURJVVMgKTtcbiAgICAgICAgfSk7Ki9cblxuICAgICAgICB0aGlzLndoZWVsUG9pbnRzID0gZ2VuZXJhdGVQb2ludHMoIHRoaXMudmFsdWVJdGVtcy5sZW5ndGgsIFdIRUVMX1JBRElVUyk7XG5cbiAgICAgICAgdGhpcy5sYWJlbFNwcml0ZXMgPSB0aGlzLnZhbHVlSXRlbXMubWFwKCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGxldCBzcHJpdGVDYW52YXMgPSB2YWx1ZS5xdWVyeVNlbGVjdG9yKCcuc3ByaXRlJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwcml0ZUFuaW1hdG9yKCBzcHJpdGVDYW52YXMsIHtmcHM6IDI1LCBhdXRvcGxheTogZmFsc2UsIGxvb3A6IGZhbHNlLCBudW1GcmFtZXM6IDM2LCB1cmw6IHNwcml0ZUNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyl9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2V0dXAgRE9NIGV2ZW50c1xuICAgICAgICB0aGlzLmFkZERvbUV2ZW50KCdjbGljaycsIHRoaXMuX3ZhbHVlSXRlbUNsaWNrSGFuZGxlciwgJy52YWx1ZS1pdGVtJyk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZCgpO1xuXG5cblxuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHVibGljIE1ldGhvZHNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgaW50cm9BbmltYXRpb24oKSB7XG5cbiAgICAgICAgLy8gVE9ETyBBZGQgc3ByaXRlIG1hc2tcblxuICAgICAgICBzZXRUaW1lb3V0KCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJnUmVuZGVyZXIuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgICAgICBsZXQgZmlyc3RIaW50ID0gdGhpcy50ZXh0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5tZXNzYWdlOmZpcnN0LWNoaWxkJyk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBmaXJzdCBoaW50XG4gICAgICAgICAgICBhbmltZSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0cyA6IGZpcnN0SGludCxcbiAgICAgICAgICAgICAgICBvcGFjaXR5IDogWzAsIDFdLFxuICAgICAgICAgICAgICAgIGVhc2luZyA6ICdlYXNlSW5DdWJpYycsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBJTlRST19ERUxBWSk7XG5cbiAgICAgICAgdGhpcy52YWx1ZUl0ZW1zLmZvckVhY2goIChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxhYmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICAgICAgfSwgKChpICsgMSkgKiAxMjApICsgSU5UUk9fREVMQVkpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHJpdmF0ZSBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIF9yZW5kZXJCYWNrZ3JvdW5kKCkge1xuICAgICAgICAvLyBEcmF3IGJhY2tncm91bmRcbiAgICAgICAgbGV0IGN0eCA9IHRoaXMuYmdSZW5kZXJlci5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIHJlbmRlckJhY2tncm91bmQoY3R4LCB0aGlzLmNvbG9ycywgdGhpcy53aGVlbFBvaW50cywgV0hFRUxfUkFESVVTKTtcblxuICAgICAgICAvKi8vIENyZWF0ZSBtYXNrXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgMiAqIFdIRUVMX1JBRElVUywgMiAqIFdIRUVMX1JBRElVUyk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyggV0hFRUxfUkFESVVTLCBXSEVFTF9SQURJVVMsIFdIRUVMX1JBRElVUywgMCwgTWF0aC5QSSAqMiwgZmFsc2UgKTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzY3JlZW4nO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBncmFkaWVudHMgZm9yIHRoZSBjb2xvcnNcbiAgICAgICAgdGhpcy5jb2xvcnMuZm9yRWFjaCggKGNvbG9yLCBpKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCB4ID0gdGhpcy53aGVlbFBvaW50c1tpXS54O1xuICAgICAgICAgICAgbGV0IHkgPSB0aGlzLndoZWVsUG9pbnRzW2ldLnk7XG5cbiAgICAgICAgICAgIGxldCBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCBXSEVFTF9SQURJVVMgKTtcbiAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBjb2xvciApO1xuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIENvbG9yKGNvbG9yKS5mYWRlKDEpICk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgV0hFRUxfUkFESVVTICogMiwgV0hFRUxfUkFESVVTICogMik7XG5cbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBMYXN0IHdoaXRlIGdyYWRpZW50IGluIGNlbnRlclxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgbGV0IHdoaXRlR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoV0hFRUxfUkFESVVTLCBXSEVFTF9SQURJVVMsIDAsIFdIRUVMX1JBRElVUywgV0hFRUxfUkFESVVTLCBXSEVFTF9SQURJVVMpO1xuXG4gICAgICAgIHdoaXRlR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTUnKTtcbiAgICAgICAgd2hpdGVHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMCcpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB3aGl0ZUdyYWRpZW50O1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgV0hFRUxfUkFESVVTICogMiwgV0hFRUxfUkFESVVTICogMik7Ki9cblxuICAgICAgICAvLyBQb3NpdGlvbiBMYWJlbHNcbiAgICAgICAgdGhpcy52YWx1ZUl0ZW1zLmZvckVhY2goIChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IHBvaW50ID0gdGhpcy53aGVlbFBvaW50c1tpXTtcblxuICAgICAgICAgICAgU3R5bGUuc2V0KCBsYWJlbCwge1xuICAgICAgICAgICAgICAgIHRvcCA6IHBvaW50LnksXG4gICAgICAgICAgICAgICAgbGVmdDogcG9pbnQueFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgX3JlbmRlckxpbmVzKCkge1xuICAgICAgICBsZXQgY3R4ID0gdGhpcy5saW5lUmVuZGVyZXIuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAvLyBDbGVhciBjYW52YXNcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBXSEVFTF9SQURJVVMgKiAyLCBXSEVFTF9SQURJVVMgKiAyKTtcblxuICAgICAgICB0aGlzLmFjdGl2ZVZhbHVlcy5mb3JFYWNoKCAodmFsdWUpID0+IHtcblxuICAgICAgICAgICAgLy8gZ2V0IG90aGVyIGVsZW1lbnRzIHRpZWQgdG8gdGhlIHZhbHVlXG4gICAgICAgICAgICBsZXQgdmFsdWVJZCA9IHZhbHVlLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZS1pZCcpO1xuICAgICAgICAgICAgbGV0IHZhbHVlSW5kZXggPSB0aGlzLnZhbHVlSXRlbXMuaW5kZXhPZiggdmFsdWUgKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZVBvaW50ID0gdGhpcy53aGVlbFBvaW50c1sgdmFsdWVJbmRleCBdO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBzdHJva2Ugc3R5bGVcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMC42NSknO1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFs3LCAxMF0pO1xuXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgaXMgcG9pbnRzIDAgYW5kIDMgd2hpY2ggYXJlIHN0cmFpZ2h0IGxpbmVzXG4gICAgICAgICAgICBpZiAodmFsdWVJbmRleCA9PT0gMCB8fCB2YWx1ZUluZGV4ID09PSAzKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgd2hlZWxQb2ludCA9IHRoaXMud2hlZWxQb2ludHNbIHZhbHVlSW5kZXggXTtcblxuICAgICAgICAgICAgICAgIGxldCBlbmRYID0gV0hFRUxfUkFESVVTO1xuICAgICAgICAgICAgICAgIGxldCBlbmRZID0gV0hFRUxfUkFESVVTICsgKCh3aGVlbFBvaW50LnkgLSBXSEVFTF9SQURJVVMpICogKDEgLSB0aGlzLmxpbmVQcm9ncmVzc1t2YWx1ZUlkXSkgKTtcblxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oIHdoZWVsUG9pbnQueCwgd2hlZWxQb2ludC55ICk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyggZW5kWCwgZW5kWSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGFkamFjZW50IHBvaW50IHRvIGJ1aWxkIGNpcmNsZSB3aXRoXG4gICAgICAgICAgICAgICAgbGV0IGFkamFjZW50UG9pbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBkaXJlY3Rpb24gb2YgdGhlIGFyYyBkZXBlbmRpbmcgb24gd2hpY2ggcG9pbnQgaXMgYmVpbmcgY2xpY2tlZFxuICAgICAgICAgICAgICAgIGxldCBhcmNDbG9ja3dpc2U7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50UG9pbnQgPSB0aGlzLndoZWVsUG9pbnRzW3ZhbHVlSW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyY0Nsb2Nrd2lzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFBvaW50ID0gdGhpcy53aGVlbFBvaW50c1t2YWx1ZUluZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmNDbG9ja3dpc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFBvaW50ID0gdGhpcy53aGVlbFBvaW50c1t2YWx1ZUluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmNDbG9ja3dpc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRQb2ludCA9IHRoaXMud2hlZWxQb2ludHNbdmFsdWVJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJjQ2xvY2t3aXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRQb2ludCA9IHRoaXMud2hlZWxQb2ludHNbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGNlbnRlciBwb2ludCBvZiBhIGNpcmNsZSB2aWEgYXZlcmFnZSBvZiB0aGUgdGhyZWUgcG9pbnRzXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHBvaW50IG9iamVjdHMgZm9yIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgICAgIGxldCBjZW50ZXJQb2ludCA9IG5ldyBQb2ludCggKFdIRUVMX1JBRElVUyArIHZhbHVlUG9pbnQueCArIGFkamFjZW50UG9pbnQueCkgLyAzLCAoV0hFRUxfUkFESVVTICsgdmFsdWVQb2ludC55ICsgYWRqYWNlbnRQb2ludC55KSAvIDMpO1xuICAgICAgICAgICAgICAgIGxldCB3aGVlbFBvaW50ID0gbmV3IFBvaW50KCBXSEVFTF9SQURJVVMsIFdIRUVMX1JBRElVUyApOyAvL1RPRE8gbW92ZSBmb3Igb3B0aW1pemF0aW9uXG5cbiAgICAgICAgICAgICAgICAvLyBSYWRpdXMgb2YgY2lyY3VtYnNjcmliaW5nIGNpcmNsZVxuICAgICAgICAgICAgICAgIGxldCBhcmNSYWRpdXMgPSBXSEVFTF9SQURJVVMgLyBNYXRoLnNxcnQoIDMgKTtcblxuICAgICAgICAgICAgICAgIC8vIGdldCBzaWRlIGRpc3RhbmNlcyB0byBjYWxjIHRoZSBhbmdsZSBvZiB0aGUgYXJjXG4gICAgICAgICAgICAgICAgLy8gbG9uZ2VzdCBzaWRlIHdpbGwgYWx3YXlzIGJlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjZW50ZXIgYW5kIHRoZSB2YWx1ZSBwb2ludFxuICAgICAgICAgICAgICAgIGxldCBzaWRlQyA9IFBvaW50LmRpc3RhbmNlKCB2YWx1ZVBvaW50LCB3aGVlbFBvaW50ICk7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGVBID0gUG9pbnQuZGlzdGFuY2UoIHZhbHVlUG9pbnQsIGNlbnRlclBvaW50ICk7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGVCID0gUG9pbnQuZGlzdGFuY2UoIHdoZWVsUG9pbnQsIGNlbnRlclBvaW50ICk7XG5cbiAgICAgICAgICAgICAgICAvLyBNZWFzdXJlIG9idHVzZSBhbmdsZSBvZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgICAgICBsZXQgYXJjQW5nbGUgPSBNYXRoLmFjb3MoICgoc2lkZUEgKiBzaWRlQSkgKyAoc2lkZUIgKiBzaWRlQikgLSAoc2lkZUMgKiBzaWRlQykpIC8gKDIgKiBzaWRlQSAqIHNpZGVCKSApO1xuICAgICAgICAgICAgICAgIGxldCBzdGVwUmFkID0gKE1hdGguUEkgKiAyKSAvIHRoaXMudmFsdWVJdGVtcy5sZW5ndGg7IC8vIFRPRE8gbW92ZSBmb3Igb3B0aW1pemF0aW9uXG5cbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRBbmdsZSwgZW5kQW5nbGU7XG5cbiAgICAgICAgICAgICAgICAvLyBsZXQgYXJjUHJvZ3Jlc3MgPSAodGhpcy5hY3RpdmVWYWx1ZXMubGVuZ3RoID09PSAwIHx8IGkgPiAwKSA/IGFyY0FuZ2xlICogdGhpcy5saW5lUHJvZ3Jlc3MucHJvZ3Jlc3MgOiBhcmNBbmdsZTtcbiAgICAgICAgICAgICAgICBsZXQgYXJjUHJvZ3Jlc3MgPSBhcmNBbmdsZSAqIHRoaXMubGluZVByb2dyZXNzW3ZhbHVlSWRdO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBNYXRoLlBJICsgYXJjQW5nbGU7IC8vIE1hdGguUEkgKyAoc3RlcFJhZCAqICh2YWx1ZUluZGV4IC0gMSkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSAtIGFyY1Byb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBNYXRoLlBJIC0gKHN0ZXBSYWQgKiAodmFsdWVJbmRleCApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBhcmNQcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gc3RlcFJhZCAqIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgLSBhcmNQcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gTWF0aC5QSSAtIChzdGVwUmFkICogKHZhbHVlSW5kZXggKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgYXJjUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguYXJjKCBjZW50ZXJQb2ludC54LCBjZW50ZXJQb2ludC55LCBhcmNSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhYXJjQ2xvY2t3aXNlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjdXRvdXQgY3VycmVudCBtZXNzYWdlXG4gICAgICAgIC8vIFRPRE8gbGluZSBieSBsaW5lIGNsZWFyXG4gICAgICAgIGN0eC5jbGVhclJlY3QoXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlLm9mZnNldExlZnQsXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlLm9mZnNldFRvcCxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lc3NhZ2Uub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlLm9mZnNldEhlaWdodFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSB2YWx1ZSAtIFZhbHVlIGVsZW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWN0aXZhdGVWYWx1ZSggdmFsdWUgKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdhY3RpdmF0ZSB2YWx1ZScpO1xuICAgICAgICBpZiAoIHRoaXMuYWN0aXZlVmFsdWVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gZGlzYWJsZSBmaXJzdFxuICAgICAgICAgICAgdGhpcy5fZGVhY3RpdmF0ZVZhbHVlKCB0aGlzLmFjdGl2ZVZhbHVlc1swXSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGhpbnRzXG4gICAgICAgIGxldCB2YWx1ZUluZGV4ID0gaW5kZXgoIHZhbHVlICk7XG5cbiAgICAgICAgbGV0IGJ1dHRvbiA9IHZhbHVlLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbicpO1xuICAgICAgICBsZXQgYnV0dG9uQmcgPSBidXR0b24ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKTtcblxuICAgICAgICB2YWx1ZS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgU3R5bGUuc2V0KCBidXR0b25CZywge2JhY2tncm91bmRDb2xvcjogdGhpcy5jb2xvcnNbdmFsdWVJbmRleF0gfSk7XG5cbiAgICAgICAgLy8gQWRkIHRvIFNlbGVjdGVkIHZhbHVlc1xuICAgICAgICB0aGlzLmFjdGl2ZVZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXG4gICAgICAgIGxldCBsYWJlbFNwcml0ZSA9IHRoaXMubGFiZWxTcHJpdGVzWyB2YWx1ZUluZGV4IF07XG4gICAgICAgIGxhYmVsU3ByaXRlLmVsLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBsYWJlbFNwcml0ZS5wbGF5KCk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlVGV4dENvbnRlbnQoKTtcbiAgICB9XG5cbiAgICBfZGVhY3RpdmF0ZVZhbHVlKCB2YWx1ZSApIHtcbiAgICAgICAgLy8gcmVtb3ZlIGZvcm0gbGlzdCBvZiBhY3RpdmUgdmFsdWVzXG4gICAgICAgIGxldCB2YWx1ZUluZGV4ID0gaW5kZXgoIHZhbHVlICk7XG4gICAgICAgIGxldCB2YWx1ZUlkID0gdmFsdWUuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlLWlkJyk7XG4gICAgICAgIGxldCBidXR0b24gPSB2YWx1ZS5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgbGV0IGJ1dHRvbkJnID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kJyk7XG5cbiAgICAgICAgdGhpcy5hY3RpdmVWYWx1ZXMuc3BsaWNlKCB0aGlzLmFjdGl2ZVZhbHVlcy5pbmRleE9mKHZhbHVlKSwgMSk7XG4gICAgICAgIHZhbHVlLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICBTdHlsZS5zZXQoIGJ1dHRvbkJnLCB7YmFja2dyb3VuZENvbG9yOiBudWxsIH0pO1xuXG4gICAgICAgIC8vIHJlbW92ZSBkb3R0ZWQgbGluZVxuICAgICAgICB0aGlzLmxpbmVQcm9ncmVzc1sgdmFsdWVJZCBdID0gMDtcblxuICAgICAgICAvLyByZW1vdmUgYnV0dGVyZmxpZXMgbGFiZWwgc3ByaXRlXG4gICAgICAgIGFuaW1lKHtcbiAgICAgICAgICAgIHRhcmdldHMgOiB0aGlzLmxhYmVsU3ByaXRlc1sgdmFsdWVJbmRleCBdLmVsLFxuICAgICAgICAgICAgZHVyYXRpb24gOiAxMDAwLFxuICAgICAgICAgICAgb3BhY2l0eSA6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlVGV4dENvbnRlbnQoKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlQ3VycmVudE1lc3NhZ2UoY2FsbGJhY2spIHtcblxuICAgICAgICBpZiAoIHRoaXMuY3VycmVudE1lc3NhZ2UgKSB7XG4gICAgICAgICAgICBhbmltZSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0cyAgICAgOiB0aGlzLmN1cnJlbnRNZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHkgICAgIDogMCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiAgICA6IDUwMCxcbiAgICAgICAgICAgICAgICBlYXNpbmcgICAgICA6ICdlYXNlT3V0Q3ViaWMnLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlICAgIDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgZm9yIGFjdGl2ZSB2YWx1ZShzKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVRleHRDb250ZW50KCkge1xuXG4gICAgICAgIC8vIGdldCBpZCBmcm9tIHBhaXIgb2YgYXR0cmlidXRlc1xuICAgICAgICBsZXQgdmFsdWVJZDtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmVWYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZUlkID0gdGhpcy5hY3RpdmVWYWx1ZXNbMF0uZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlLWlkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hY3RpdmVWYWx1ZXMubGVuZ3RoID09PSAyKSB7XG5cbiAgICAgICAgICAgIGxldCB2YWx1ZUEgPSB0aGlzLmFjdGl2ZVZhbHVlc1swXTtcbiAgICAgICAgICAgIGxldCB2YWx1ZUIgPSB0aGlzLmFjdGl2ZVZhbHVlc1sxXTtcblxuICAgICAgICAgICAgbGV0IGluZGV4QSA9IGluZGV4KHZhbHVlQSk7XG4gICAgICAgICAgICBsZXQgaW5kZXhCID0gaW5kZXgodmFsdWVCKTtcblxuICAgICAgICAgICAgLy8gZ2V0IHBhaXIgb2YgaWQncyBhcyBhIHNpbmdsZSBpZCBcImlkQS1pZEJcIi4gVGhlIG9yZGVyIGlzIGRldGVybWluZWQgYnkgdGhlIERPTSwgbm90IGFscGhhYmV0aWNhbGx5XG4gICAgICAgICAgICB2YWx1ZUlkID0gKCBpbmRleEEgPCBpbmRleEIgKSA/IGAke3ZhbHVlQS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUtaWQnKX0tJHt2YWx1ZUIuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlLWlkJyl9YCA6IGAke3ZhbHVlQi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUtaWQnKX0tJHt2YWx1ZUEuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlLWlkJyl9YFxuXG4gICAgICAgICAgICAvLyBnZXQgbnVtYmVyIG9mIHBvaW50cyBiZXR3ZWVuIHBvaW50c1xuICAgICAgICAgICAgLy8gbGV0IGRpc3RhbmNlID0gTWF0aC5hYnMoIGluZGV4QSAtIGluZGV4QiApO1xuICAgICAgICAgICAgLy8gbGV0IHNob3J0RGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIHRoaXMudmFsdWVJdGVtcy5sZW5ndGggLSBkaXN0YW5jZSk7XG5cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRW1wdHkgdGhlIGJsb2NrXG4gICAgICAgICAgICB0aGlzLmxpbmVSZW5kZXJlci5nZXRDb250ZXh0KCcyZCcpLmNsZWFyUmVjdCgwLCAwLCBXSEVFTF9SQURJVVMgKiAyLCBXSEVFTF9SQURJVVMgKiAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgZm91bmQgYW4gZWxlbWVudFxuICAgICAgICBpZiAodmFsdWVJZCkge1xuXG4gICAgICAgICAgICAvLyBHZXQgY2xvbmUgb2YgZWxlbWVudFxuICAgICAgICAgICAgbGV0IG1lc3NhZ2VFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihgLnZhbHVlLW1lc3NhZ2UtbGlicmFyeSAudmFsdWUtbWVzc2FnZVtkYXRhLXZhbHVlLWlkPVwiJHt2YWx1ZUlkfVwiXWApLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ3VycmVudE1lc3NhZ2UoICgpID0+IHtcbiAgICAgICAgICAgICAgICBlbXB0eSggdGhpcy50ZXh0Q29udGFpbmVyICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTYXZlIGN1cnJlbnQgbWVzc2FnZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZSA9IG1lc3NhZ2VFbDtcblxuICAgICAgICAgICAgICAgIG1lc3NhZ2VFbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgICBhbmltZSh7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHMgICAgIDogbWVzc2FnZUVsLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ICAgICA6IFswLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gICAgOiAzNTAsXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZyAgICAgIDogJ2Vhc2VJbkN1YmljJ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0Q29udGFpbmVyLmFwcGVuZENoaWxkKCBtZXNzYWdlRWwgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBtdWx0cGxlIGxpbmVzIHRvIGFuaW1hdGU/XG4gICAgICAgICAgICB2YWx1ZUlkLnNwbGl0KCctJykuZm9yRWFjaCggdmFsdWVQcm9wID0+IHtcblxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSB0aGlzLmxpbmVQcm9ncmVzc1sgdmFsdWVQcm9wIF07XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCByZWFuaW1hdGUgY29tcGxldGUgbGluZXNcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgYmFzaWMgcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFuaW1Qcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHMgOiB0aGlzLmxpbmVQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uIDogMTQwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZyA6ICdlYXNlSW5PdXRDaXJjJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSA6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJMaW5lcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGR5bmFtaWMgcHJvcGVydHkgY3JlYXRpb24gZm9yIHRoaXMgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BzWyB2YWx1ZVByb3AgXSA9IFtjdXJyZW50VmFsdWUsIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGFuaW1cbiAgICAgICAgICAgICAgICAgICAgYW5pbWUoYW5pbVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IGxpbmVzIHRvIGJsb2NcbiAgICAgICAgdGhpcy5fcmVuZGVyTGluZXMoKTtcblxuICAgIH1cblxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIEV2ZW50IEhhbmRsZXJzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgICBfdmFsdWVJdGVtQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG5cbiAgICAgICAgaWYgKCBldmVudC5kZWxlZ2F0ZVRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICkge1xuICAgICAgICAgICAgdGhpcy5fZGVhY3RpdmF0ZVZhbHVlKCBldmVudC5kZWxlZ2F0ZVRhcmdldCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVWYWx1ZSggZXZlbnQuZGVsZWdhdGVUYXJnZXQgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmFsdWVzV2hlZWw7XG4iLCIvLyBUaGlyZCBwYXJ0eSBkZXBlbmRlbmNpZXNcbmltcG9ydCBhbmltZSBmcm9tICdhbmltZWpzJztcblxuLy8gVVpJSyBEZXBlZGVuY2llc1xuaW1wb3J0IEJhc2VWaWV3IGZyb20gJ3ppbXBsaXN0L2Rpc3BsYXkvQmFzZVZpZXcnO1xuaW1wb3J0IFN0eWxlIGZyb20gXCJ6aW1wbGlzdC91dGlscy9TdHlsZVwiO1xuaW1wb3J0IFBvaW50IGZyb20gJ3ppbXBsaXN0L2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCBpbmRleCBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L2RvbS9pbmRleCc7XG5pbXBvcnQgZW1wdHkgZnJvbSAnemltcGxpc3QvZGlzcGxheS9kb20vZW1wdHknO1xuaW1wb3J0IHJlbW92ZUNsYXNzZXMgZnJvbSAnemltcGxpc3QvZGlzcGxheS9kb20vcmVtb3ZlQ2xhc3Nlcyc7XG5cbi8vIExvY2FsIGFwcCBEZXBlbmRlbmNpZXNcbmltcG9ydCByZW5kZXJCYWNrZ3JvdW5kIGZyb20gXCIuL3JlbmRlckJhY2tncm91bmRcIjtcbmltcG9ydCBnZW5lcmF0ZVBvaW50cyBmcm9tIFwiLi9nZW5lcmF0ZVBvaW50c1wiO1xuXG4vLyBIaWRkZW4gY29uc3RzXG5jb25zdCBXSEVFTF9SQURJVVMgPSAxNzA7IC8vIE11c3QgbWF0Y2ggdmFsdWUgaW4gU0NTU1xuY29uc3QgV0hFRUxfUE9JTlRfQU5HTEUgPSA0NSAqIChNYXRoLlBJIC8gMTgwKTtcblxuLyoqXG4gKlxuICovXG5jbGFzcyBWYWx1ZXNXaGVlbFNtYWxsIGV4dGVuZHMgQmFzZVZpZXcge1xuXG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcihlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gdGhpcy5hZGREb21FdmVudCgnY2xpY2snLCB0aGlzLl9jaGlsZENsaWNrSGFuZGxlcik7XG4gICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ2NsaWNrJywgdGhpcy5faXRlbUNsaWNrSGFuZGxlciwgJy52YWx1ZXMtd2hlZWwtc21hbGwgLnZhbHVlLWl0ZW0nKTtcblxuICAgICAgICAvLyBHZXQgcmVmZW5jZSB0byB0aGUgb3JpZ2luYWwgdmFsdWUgbGlzdCBhbmQgaGlkZSBpdFxuICAgICAgICB0aGlzLnZhbHVlTGlzdCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnZhbHVlcy1saXN0Jyk7XG4gICAgICAgIHRoaXMudmFsdWVFbGVtZW50cyA9ICBBcnJheS5mcm9tKCB0aGlzLnZhbHVlTGlzdC5xdWVyeVNlbGVjdG9yQWxsKCcudmFsdWUtaXRlbScpICk7XG5cbiAgICAgICAgdGhpcy52YWx1ZUxpc3RBID0gdGhpcy52YWx1ZUxpc3QuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICB0aGlzLnZhbHVlTGlzdEIgPSB0aGlzLnZhbHVlTGlzdC5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgICAgLy8gSGlkZSBsaXN0IGFmdGVyIGNsb25pbmcgaXRcbiAgICAgICAgU3R5bGUuc2V0KCB0aGlzLnZhbHVlTGlzdCwge2Rpc3BsYXk6ICdub25lJ30pO1xuXG4gICAgICAgIHRoaXMud2hlZWxDb250YWluZXJBID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcud2hlZWwtY29udGFpbmVyLXNtYWxsOmZpcnN0LWNoaWxkJyk7XG4gICAgICAgIHRoaXMud2hlZWxDb250YWluZXJCID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcud2hlZWwtY29udGFpbmVyLXNtYWxsOmxhc3QtY2hpbGQnKTtcblxuICAgICAgICAvLyBHZXQgYmFja2dyb3VuZHNcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQSA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLndoZWVsLWNvbnRhaW5lci1zbWFsbDpmaXJzdC1jaGlsZCAuYmctcmVuZGVyZXItc21hbGwnKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQiA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLndoZWVsLWNvbnRhaW5lci1zbWFsbDpsYXN0LWNoaWxkIC5iZy1yZW5kZXJlci1zbWFsbCcpO1xuXG4gICAgICAgIHRoaXMud2hlZWxDb250YWluZXJBLmFwcGVuZENoaWxkKCB0aGlzLnZhbHVlTGlzdEEgKTtcbiAgICAgICAgdGhpcy53aGVlbENvbnRhaW5lckIuYXBwZW5kQ2hpbGQoIHRoaXMudmFsdWVMaXN0QiApO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZUEgPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWVCID0gMDtcblxuICAgICAgICB0aGlzLl9hY3RpdmVWYWx1ZXMgPSB7XG4gICAgICAgICAgICBhIDogbnVsbCxcbiAgICAgICAgICAgIGIgOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50ZXh0Q29udGFpbmVyID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcudmFsdWUtdGV4dC1jb250YWluZXIuc21hbGwnKTtcblxuICAgICAgICAvLyBHZXQgdmFsdWVzXG4gICAgICAgIC8vIHRoaXMudmFsdWVzID0ge307XG5cbiAgICAgICAgLyp0aGlzLnZhbHVlRWxlbWVudHNBLmZvckVhY2goICh2YWx1ZSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGlkICAgICAgPSB2YWx1ZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUtaWQnKTtcbiAgICAgICAgICAgIGxldCBjb2xvciAgID0gdmFsdWUuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbG9yJyk7XG5cbiAgICAgICAgICAgIHRoaXMudmFsdWVzWyBpZCBdID0ge1xuICAgICAgICAgICAgICAgIGVsIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIGluZGV4IDogaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7Ki9cblxuICAgICAgICAvLyBnZXQgYW4gYXJyYXkgb2YgY29sb3JzIGZyb20gZWFjaCBwb2ludFxuICAgICAgICB0aGlzLmNvbG9ycyA9IHRoaXMudmFsdWVFbGVtZW50cy5tYXAoIGVsID0+IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xvcicpICk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHdoZWVsIHBvaW50c1xuICAgICAgICAvLyB0aGlzLndoZWVsUG9pbnRzID0gZ2VuZXJhdGVQb2ludHMoIHRoaXMudmFsdWVFbGVtZW50cy5sZW5ndGgsIFdIRUVMX1JBRElVUywgMzAgKTtcblxuICAgICAgICB0aGlzLndoZWVsUG9pbnRzID0gW107XG5cbiAgICAgICAgbGV0IGZpcnN0UG9pbnRPZmZzZXQgPSAgMCAtIChNYXRoLmZsb29yKCA1IC8gMikgKiAoV0hFRUxfUE9JTlRfQU5HTEUpICk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZUVsZW1lbnRzLmxlbmd0aDsgaSArKykge1xuXG4gICAgICAgICAgICAvLyBnZXQgb2Zmc2V0IGZvclxuICAgICAgICAgICAgbGV0IGFuZ2xlID0gZmlyc3RQb2ludE9mZnNldCArIChpICogV0hFRUxfUE9JTlRfQU5HTEUpO1xuICAgICAgICAgICAgbGV0IHggPSBXSEVFTF9SQURJVVMgKyBNYXRoLmNvcyhhbmdsZSkgKiBXSEVFTF9SQURJVVM7XG4gICAgICAgICAgICBsZXQgeSA9IFdIRUVMX1JBRElVUyArIE1hdGguc2luKGFuZ2xlKSAqIFdIRUVMX1JBRElVUztcblxuICAgICAgICAgICAgdGhpcy53aGVlbFBvaW50cy5wdXNoKCBuZXcgUG9pbnQoeCwgeSwgYW5nbGUsIFdIRUVMX1JBRElVUykgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZCgpO1xuXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBQdWJsaWMgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gICAgaW50cm9BbmltYXRpb24oKSB7XG5cbiAgICAgICAgQXJyYXkuZnJvbSggdGhpcy52YWx1ZUxpc3RBLnF1ZXJ5U2VsZWN0b3JBbGwoJy52YWx1ZS1pdGVtLmhpZGRlbicpICkuZm9yRWFjaCggaXRlbSA9PiBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpIClcbiAgICAgICAgQXJyYXkuZnJvbSggdGhpcy52YWx1ZUxpc3RCLnF1ZXJ5U2VsZWN0b3JBbGwoJy52YWx1ZS1pdGVtLmhpZGRlbicpICkuZm9yRWFjaCggaXRlbSA9PiBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpIClcblxuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHJpdmF0ZSBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIF9hY3RpdmF0ZVZhbHVlKHZhbHVlSW5kZXgsIGdyb3VwID0gJ2EnKSB7XG5cbiAgICAgICAgdGhpc1snc2VsZWN0ZWRWYWx1ZScrZ3JvdXAudG9VcHBlckNhc2UoKV0gPSB2YWx1ZUluZGV4O1xuXG4gICAgICAgIHRoaXMuX2FjdGl2ZVZhbHVlc1tncm91cF0gPSB2YWx1ZUluZGV4O1xuXG4gICAgICAgIHRoaXNbJ3ZhbHVlTGlzdCcrZ3JvdXAudG9VcHBlckNhc2UoKV0uY2hpbGRyZW5bdmFsdWVJbmRleF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG5cbiAgICB9XG5cbiAgICBfZGVhY3RpdmF0ZVZhbHVlKHZhbHVlSW5kZXgsIGdyb3VwID0gJ2EnKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVZhbHVlc1tncm91cF0gPSBudWxsO1xuXG4gICAgICAgIHRoaXNbJ3ZhbHVlTGlzdCcrZ3JvdXAudG9VcHBlckNhc2UoKV0uY2hpbGRyZW5bdmFsdWVJbmRleF0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG5cbiAgICAgICAgLy8gdGhpcy5fcG9zaXRpb25MYWJlbHMoKTtcbiAgICAgICAgLy8gdGhpcy5fdXBkYXRlVGV4dENvbnRlbnQoKTtcbiAgICB9XG5cbiAgICBfcG9zaXRpb25MYWJlbHMoKSB7XG5cbiAgICAgICAgLypcblxuICAgICAgICBBXG5cbiAgICAgICAgICovXG5cbiAgICAgICAgbGV0IG9yZGVyZWRWYWx1ZXNBID0gW107XG4gICAgICAgIGxldCBvcmRlckluZGV4QSA9IDIgLSB0aGlzLnNlbGVjdGVkVmFsdWVBOyAvLyA1LzJcbiAgICAgICAgb3JkZXJJbmRleEEgPSAob3JkZXJJbmRleEEgPCAwKSA/IG9yZGVySW5kZXhBICsgdGhpcy52YWx1ZUVsZW1lbnRzLmxlbmd0aCA6IG9yZGVySW5kZXhBO1xuXG4gICAgICAgIGxldCBsYWJlbHNBID0gQXJyYXkuZnJvbSggdGhpcy52YWx1ZUxpc3RBLnF1ZXJ5U2VsZWN0b3JBbGwoJy52YWx1ZS1pdGVtJykgKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhYmVsc0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGFiZWwgPSBsYWJlbHNBW2ldO1xuXG4gICAgICAgICAgICAvLyBUT0RPIHJlZmFjdG9yIHdpdGggc2FtZSBjb2RlIGJlbG93XG4gICAgICAgICAgICByZW1vdmVDbGFzc2VzKCBjdXJyZW50TGFiZWwsICdzdGF0ZS0qJyk7XG4gICAgICAgICAgICBpZiAoIG9yZGVySW5kZXhBID09PSAyICkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbC5jbGFzc0xpc3QuYWRkKCdzdGF0ZS1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggIShvcmRlckluZGV4QSA9PT0gMSB8fCBvcmRlckluZGV4QSA9PT0gMykgKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExhYmVsLmNsYXNzTGlzdC5hZGQoJ3N0YXRlLW9mZicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcmRlcmVkVmFsdWVzQVsgb3JkZXJJbmRleEErKyBdID0gY3VycmVudExhYmVsO1xuICAgICAgICAgICAgb3JkZXJJbmRleEEgPSAoIG9yZGVySW5kZXhBIDwgbGFiZWxzQS5sZW5ndGgpID8gb3JkZXJJbmRleEEgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgb3JkZXJlZFZhbHVlc0EuZm9yRWFjaCggKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIFN0eWxlLnNldChpdGVtLCB7XG4gICAgICAgICAgICAgICAgdG9wIDogdGhpcy53aGVlbFBvaW50c1sgaSBdLnksXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy53aGVlbFBvaW50c1sgaSBdLngsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvKlxuXG4gICAgICAgIEJcblxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG9yZGVyZWRWYWx1ZXNCID0gW107XG4gICAgICAgIGxldCBvcmRlckluZGV4QiA9IDIgLSB0aGlzLnNlbGVjdGVkVmFsdWVCOyAvLyA1LzJcbiAgICAgICAgb3JkZXJJbmRleEIgPSAob3JkZXJJbmRleEIgPCAwKSA/IG9yZGVySW5kZXhCICsgdGhpcy52YWx1ZUVsZW1lbnRzLmxlbmd0aCA6IG9yZGVySW5kZXhCO1xuXG4gICAgICAgIGxldCBsYWJlbHNCID0gQXJyYXkuZnJvbSggdGhpcy52YWx1ZUxpc3RCLnF1ZXJ5U2VsZWN0b3JBbGwoJy52YWx1ZS1pdGVtJykgKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhYmVsc0IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGFiZWwgPSBsYWJlbHNCW2ldO1xuXG4gICAgICAgICAgICAvLyBUT0RPIHJlZmFjdG9yIHdpdGggc2FtZSBjb2RlIGFib3ZlXG4gICAgICAgICAgICByZW1vdmVDbGFzc2VzKCBjdXJyZW50TGFiZWwsICdzdGF0ZS0qJyk7XG4gICAgICAgICAgICBpZiAoIG9yZGVySW5kZXhCID09PSAyICkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbC5jbGFzc0xpc3QuYWRkKCdzdGF0ZS1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggIShvcmRlckluZGV4QiA9PT0gMSB8fCBvcmRlckluZGV4QiA9PT0gMykgKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExhYmVsLmNsYXNzTGlzdC5hZGQoJ3N0YXRlLW9mZicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcmRlcmVkVmFsdWVzQlsgb3JkZXJJbmRleEIrKyBdID0gY3VycmVudExhYmVsO1xuICAgICAgICAgICAgb3JkZXJJbmRleEIgPSAoIG9yZGVySW5kZXhCIDwgbGFiZWxzQi5sZW5ndGgpID8gb3JkZXJJbmRleEIgOiAwO1xuICAgICAgICB9XG5cblxuICAgICAgICBvcmRlcmVkVmFsdWVzQi5mb3JFYWNoKCAoaXRlbSwgaSkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgeCA9IHRoaXMud2hlZWxQb2ludHNbIGkgXS54O1xuICAgICAgICAgICAgbGV0IHkgPSB0aGlzLndoZWVsUG9pbnRzWyBpIF0ueTtcblxuICAgICAgICAgICAgeCA9IFdIRUVMX1JBRElVUyAtICh4IC0gV0hFRUxfUkFESVVTKTtcblxuICAgICAgICAgICAgU3R5bGUuc2V0KCBpdGVtLCB7XG4gICAgICAgICAgICAgICAgdG9wIDogeSxcbiAgICAgICAgICAgICAgICBsZWZ0OiB4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBfcmVtb3ZlQ3VycmVudE1lc3NhZ2UoY2FsbGJhY2spIHtcblxuICAgICAgICBpZiAoIHRoaXMuY3VycmVudE1lc3NhZ2UgKSB7XG4gICAgICAgICAgICBhbmltZSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0cyAgICAgOiB0aGlzLmN1cnJlbnRNZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHkgICAgIDogMCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiAgICA6IDUwMCxcbiAgICAgICAgICAgICAgICBlYXNpbmcgICAgICA6ICdlYXNlT3V0Q3ViaWMnLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlICAgIDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgX3VwZGF0ZVRleHRDb250ZW50KCkge1xuXG4gICAgICAgIC8vIHZhbHVlIGlkIHdpbGwgYmUgZWl0aGVyIHNpbmdsZSBpZCBvciBjb21iaW5hdGlvblxuICAgICAgICBsZXQgdmFsdWVJZDtcblxuICAgICAgICAvLyBnZXQgc2VsZWN0ZWQgdmFsdWVzXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVWYWx1ZXMuYSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmFsdWVzLmIgIT09IG51bGwgJiYgdGhpcy5fYWN0aXZlVmFsdWVzLmEgIT09IHRoaXMuX2FjdGl2ZVZhbHVlcy5iKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4QSA9IHRoaXMuX2FjdGl2ZVZhbHVlcy5hO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleEIgPSB0aGlzLl9hY3RpdmVWYWx1ZXMuYjtcblxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZUEgPSB0aGlzLnZhbHVlRWxlbWVudHNbaW5kZXhBXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUtaWQnKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVCID0gdGhpcy52YWx1ZUVsZW1lbnRzW2luZGV4Ql0uZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlLWlkJyk7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZUlkID0gKGluZGV4QSA8IGluZGV4QikgPyB2YWx1ZUErJy0nK3ZhbHVlQiA6IHZhbHVlQisnLScrdmFsdWVBO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZUlkID0gdGhpcy52YWx1ZUVsZW1lbnRzW3RoaXMuX2FjdGl2ZVZhbHVlcy5hXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUtaWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBtZXNzYWdlIGZvciB0aGlzIHZhbHVlc1xuICAgICAgICBsZXQgbWVzc2FnZUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKGAudmFsdWUtbWVzc2FnZS1saWJyYXJ5IC52YWx1ZS1tZXNzYWdlW2RhdGEtdmFsdWUtaWQ9XCIke3ZhbHVlSWR9XCJdYCkuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIGlmIChtZXNzYWdlRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUN1cnJlbnRNZXNzYWdlKCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZW1wdHkoIHRoaXMudGV4dENvbnRhaW5lciApO1xuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBjdXJyZW50IG1lc3NhZ2UgZWxlbWVudFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1lc3NhZ2UgPSBtZXNzYWdlRWw7XG5cbiAgICAgICAgICAgICAgICBtZXNzYWdlRWwuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgYW5pbWUoe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzICAgICA6IG1lc3NhZ2VFbCxcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eSAgICAgOiBbMCwgMV0sXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uICAgIDogMzUwLFxuICAgICAgICAgICAgICAgICAgICBlYXNpbmcgICAgICA6ICdlYXNlSW5DdWJpYydcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMudGV4dENvbnRhaW5lci5hcHBlbmRDaGlsZCggbWVzc2FnZUVsICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgX3JlbmRlckJhY2tncm91bmQoKSB7XG5cbiAgICAgICAgcmVuZGVyQmFja2dyb3VuZCggdGhpcy5iYWNrZ3JvdW5kQS5nZXRDb250ZXh0KCcyZCcpLCB0aGlzLmNvbG9ycywgdGhpcy53aGVlbFBvaW50cywgV0hFRUxfUkFESVVTICk7XG4gICAgICAgIHJlbmRlckJhY2tncm91bmQoIHRoaXMuYmFja2dyb3VuZEIuZ2V0Q29udGV4dCgnMmQnKSwgdGhpcy5jb2xvcnMsIHRoaXMud2hlZWxQb2ludHMsIFdIRUVMX1JBRElVUyApO1xuXG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIEV2ZW50IEhhbmRsZXJzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgICBfY2hpbGRDbGlja0hhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlQSsrO1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkVmFsdWVBID49IHRoaXMudmFsdWVFbGVtZW50cy5sZW5ndGggKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWVBID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZUIrKztcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFZhbHVlQiA+PSB0aGlzLnZhbHVlRWxlbWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlQiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3NpdGlvbkxhYmVscygpO1xuICAgIH1cblxuICAgIF9pdGVtQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG5cbiAgICAgICAgbGV0IGl0ZW1Hcm91cCA9ICggdGhpcy52YWx1ZUxpc3RBLmNvbnRhaW5zKCBldmVudC5kZWxlZ2F0ZVRhcmdldCApICkgPyAnYScgOiAnYic7XG4gICAgICAgIGxldCBpdGVtSWQgPSBldmVudC5kZWxlZ2F0ZVRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUtaWQnKTtcbiAgICAgICAgbGV0IGl0ZW1JbmRleCA9IGluZGV4KCBldmVudC5kZWxlZ2F0ZVRhcmdldCApO1xuXG4gICAgICAgIC8vIFRPRE8gY2hlY2sgZGlzYWJsZWQgaXRlbXNcblxuICAgICAgICAvLyBXZSBjYW4ndCBkaXNhYmxlIEEsIG90aGVyd2lzZSBub3RoaW5nIHdpbGwgYmUgZGlzcGxheWVkXG4gICAgICAgIC8qaWYgKHRoaXMuX2FjdGl2ZVZhbHVlc1tpdGVtR3JvdXBdICE9PSBudWxsICYmIHRoaXMuX2FjdGl2ZVZhbHVlc1tpdGVtR3JvdXBdID09PSBpdGVtSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYWN0aXZhdGVWYWx1ZShpdGVtSW5kZXgsIGl0ZW1Hcm91cCk7XG4gICAgICAgIH0gZWxzZSAqL2lmICh0aGlzLl9hY3RpdmVWYWx1ZXNbaXRlbUdyb3VwXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGVhY3RpdmF0ZVZhbHVlKCB0aGlzLl9hY3RpdmVWYWx1ZXNbaXRlbUdyb3VwXSwgaXRlbUdyb3VwICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmF0ZVZhbHVlKGl0ZW1JbmRleCwgaXRlbUdyb3VwKTtcblxuICAgICAgICB0aGlzLl9wb3NpdGlvbkxhYmVscygpO1xuICAgICAgICB0aGlzLl91cGRhdGVUZXh0Q29udGVudCgpO1xuXG4gICAgfVxuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmFsdWVzV2hlZWxTbWFsbDtcbiIsImltcG9ydCBQb2ludCBmcm9tICd6aW1wbGlzdC9nZW9tZXRyeS9Qb2ludCc7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUG9pbnRzKGxlbmd0aCwgcmFkaXVzKSB7XG5cbiAgICBsZXQgc3RlcFJhZCA9IChNYXRoLlBJICogMikgLyBsZW5ndGg7XG4gICAgbGV0IHF1YXRlclJhZCA9IChNYXRoLlBJICogMikgLyA0O1xuXG4gICAgbGV0IHBvaW50cyA9IFtdO1xuXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYW5nbGUgPSAoc3RlcFJhZCAqIGkpIC0gcXVhdGVyUmFkO1xuICAgICAgICBsZXQgeCA9IHJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApICsgcmFkaXVzO1xuICAgICAgICBsZXQgeSA9IHJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApICsgcmFkaXVzO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKCBuZXcgUG9pbnQoIHgsIHksIGFuZ2xlLCByYWRpdXMgKSApO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdlbmVyYXRlUG9pbnRzOyIsImltcG9ydCBDb2xvciBmcm9tICdjb2xvcic7XG5cbmZ1bmN0aW9uIHJlbmRlckJhY2tncm91bmQoY3R4LCBjb2xvcnMsIHdoZWVsUG9pbnRzLCByYWRpdXMpIHtcblxuICAgIC8vIENyZWF0ZSBtYXNrXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCAyICogcmFkaXVzLCAyICogcmFkaXVzKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyggcmFkaXVzLCByYWRpdXMsIHJhZGl1cywgMCwgTWF0aC5QSSAqMiwgZmFsc2UgKTtcbiAgICBjdHguY2xpcCgpO1xuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc2NyZWVuJztcblxuICAgIC8vIGNyZWF0ZSBncmFkaWVudHMgZm9yIHRoZSBjb2xvcnNcbiAgICBjb2xvcnMuZm9yRWFjaCggKGNvbG9yLCBpKSA9PiB7XG5cbiAgICAgICAgbGV0IHdoZWVsUG9pbnQgPSB3aGVlbFBvaW50c1tpXTtcblxuICAgICAgICBsZXQgeCA9IHdoZWVsUG9pbnQueDtcbiAgICAgICAgbGV0IHkgPSB3aGVlbFBvaW50Lnk7XG5cbiAgICAgICAgbGV0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHgsIHksIHJhZGl1cyApO1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgY29sb3IgKTtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIENvbG9yKGNvbG9yKS5mYWRlKDEpICk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHJhZGl1cyAqIDIsIHJhZGl1cyAqIDIpO1xuXG4gICAgfSk7XG5cblxuICAgIC8vIExhc3Qgd2hpdGUgZ3JhZGllbnQgaW4gY2VudGVyXG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgbGV0IHdoaXRlR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQocmFkaXVzLCByYWRpdXMsIDAsIHJhZGl1cywgcmFkaXVzLCByYWRpdXMpO1xuXG4gICAgd2hpdGVHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNScpO1xuICAgIHdoaXRlR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAnKTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSB3aGl0ZUdyYWRpZW50O1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCByYWRpdXMgKiAyLCByYWRpdXMgKiAyKTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJCYWNrZ3JvdW5kOyIsImltcG9ydCBGb250RmFjZU9ic2VydmVyIGZyb20gXCJmb250ZmFjZW9ic2VydmVyXCI7XG5pbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIjtcblxuLy8gSW1wb3J0c1xuaW1wb3J0IFdpbmRvd01hbmFnZXIgZnJvbSAnemltcGxpc3QvdXRpbHMvV2luZG93TWFuYWdlcic7XG5pbXBvcnQgQ29uZmlnIGZyb20gJ3ppbXBsaXN0L3V0aWxzL0NvbmZpZyc7XG5pbXBvcnQgc3RyaW5nVG9FbGVtZW50IGZyb20gJ3ppbXBsaXN0L2Rpc3BsYXkvZG9tL3N0cmluZ1RvRWxlbWVudCc7XG5cbmltcG9ydCBwYWdlTGlzdCBmcm9tICdhcHAvcGFnZXMvcGFnZUxpc3QnO1xuaW1wb3J0IFBhZ2VEcmF3IGZyb20gJ2FwcC91aS9QYWdlRHJhdyc7XG5pbXBvcnQgSGVhZGVyIGZyb20gJ2FwcC91aS9IZWFkZXInO1xuaW1wb3J0IEZvb3RlciBmcm9tICdhcHAvdWkvRm9vdGVyJztcblxuLy8gQ3JlYXRlIG1haW4gb2JqZWN0XG5jb25zdCBWQ0EgPSB7XG4gICAgc3RhcnQoKSB7XG5cbiAgICAgICAgLy8gSW5pdCBnbG9iYWwgY29uZmlnIHdpdGggcGFnZSBkYXRhXG4gICAgICAgIGxldCBib290c3RyYXBDb25maWcgPSB3aW5kb3cuVkNBX0NPTkZJRztcblxuICAgICAgICBpZiAoICFib290c3RyYXBDb25maWcgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIGJvb3RzdHJhcCBjb25maWcgcHJvdmlkZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIENvbmZpZy5pbml0aWFsaXplKCBib290c3RyYXBDb25maWcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHVwIFdpbmRvd01hbmFnZXJcbiAgICAgICAgV2luZG93TWFuYWdlci5pbml0aWFsaXplKHtcbiAgICAgICAgICAgIGJyZWFrcG9pbnRzIDogW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAneHhzJywgICB2YWx1ZTogMCAgIH0sIC8vIG5lZWRzIHRvIGJlIDAgdG8gYXZvaWQgc2NyZXdpbmcgdXAgdGhlIGRldGVjdGlvblxuICAgICAgICAgICAgICAgIHtuYW1lOiAneHMnLCAgICB2YWx1ZTogNTUwIH0sXG4gICAgICAgICAgICAgICAge25hbWU6ICdzJywgICAgIHZhbHVlOiA3NTAgfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ20nLCAgICAgdmFsdWU6IDk4MCB9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnbCcsICAgICB2YWx1ZTogMTIwMH0sXG4gICAgICAgICAgICAgICAge25hbWU6ICd4bCcsICAgIHZhbHVlOiAxNDAwfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3h4bCcsICAgdmFsdWU6IDE2MDB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldHVwIGZvbnQtZmFjZSBvYnNlcnZlclxuICAgICAgICB0aGlzLmluaXRGb250RmFjZU9ic2VydmVycygpO1xuXG4gICAgICAgIC8vIExvYWQgU1ZHIFNwcml0ZVxuICAgICAgICB0aGlzLmluaXRTVkdTcHJpdGUoKTtcblxuICAgICAgICAvLyBJbml0IHN0YXRpYyB1aSBlbGVtZW50c1xuICAgICAgICB0aGlzLmhlYWRlciA9IG5ldyBIZWFkZXIoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaXRlLWhlYWRlcicpICk7XG5cbiAgICAgICAgdGhpcy5mb290ZXIgPSBuZXcgRm9vdGVyKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2l0ZS1mb290ZXInKSApO1xuXG4gICAgICAgIHRoaXMucGFnZURyYXcgPSBuZXcgUGFnZURyYXcoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWdlLWRyYXcnKSApO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgcGFnZSBpbiBwbGFjZSBhbmQgY3JlYXRlIG5ldyBoaXN0b3J5IGVudHJ5XG4gICAgICAgIC8vIFdBUk5JTkcgOiBtYWtlIHN1cmUgdGhlcmUgYXJlIGlzIG9ubHkgb25lICcucGFnZScgbG9hZGVkIGluIHRoZSBsYXlvdXRcbiAgICAgICAgbGV0IHBhZ2UgPSB0aGlzLmluaXRQYWdlKCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZScpICk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coIHdpbmRvdy5sb2NhdGlvbi5ocmVmICk7XG5cbiAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHtwYWdlSWQ6IHBhZ2UuaWR9LCB3aW5kb3cudGl0bGUsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgICAvKlxuXG4gICAgICAgIFNldHVwIEFKQVggbmF2aWdhdGlvblxuXG4gICAgICAgICovXG4gICAgICAgIC8vIGRlY2xhcmUgcmVnZXggdG8gZGV0ZWN0IGludGVybmFsIGxpbmtzXG4gICAgICAgIC8vIFRPRE8gbW92ZSB0byBjb25maWc/XG4gICAgICAgIHRoaXMubG9hZGFibGVSZWdleCA9IG5ldyBSZWdFeHAoYCheL3wke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59Ly4qKWApO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuX3BvcHN0YXRlSGFuZGxlci5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBiaW5kIGxpbmsgRE9NIGV2ZW50cyB0byBoaWphY2sgbmF2IGV2ZW50c1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9nbG9iYWxDbGlja0hhbmRsZXIuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgbG9hZCB0byB0cmlnZ2VyIGFub3RoZXIgcmUtcmVuZGVyXG4gICAgICAgIFdpbmRvd01hbmFnZXIub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBXaW5kb3dNYW5hZ2VyLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuICAgICAgICB9KTtcblxuICAgIH0sXG5cbiAgICBpbml0Rm9udEZhY2VPYnNlcnZlcnMoKSB7XG4gICAgICAgIGxldCBmb250T2JzZXJ2ZXJOZXV0cmFmYWNlU2VtaSAgICAgID0gbmV3IEZvbnRGYWNlT2JzZXJ2ZXIoJ25ldXRyYWZhY2V0ZXh0Jywge3dlaWdodDogNjAwfSk7XG4gICAgICAgIGxldCBmb250T2JzZXJ2ZXJOZXV0cmFmYWNlQm9sZCAgICAgID0gbmV3IEZvbnRGYWNlT2JzZXJ2ZXIoJ25ldXRyYWZhY2V0ZXh0Jywge3dlaWdodDogNzAwfSk7XG5cbiAgICAgICAgbGV0IGZvbnRPYnNlcnZlckZpbG9zb2ZpYVJlZ3VsYXIgICAgPSBuZXcgRm9udEZhY2VPYnNlcnZlcignZmlsb3NvZmlhJywge3dlaWdodDogNDAwfSk7XG4gICAgICAgIGxldCBmb250T2JzZXJ2ZXJGaWxvc29maWFJdGFsaWMgICAgID0gbmV3IEZvbnRGYWNlT2JzZXJ2ZXIoJ2ZpbG9zb2ZpYScsIHt3ZWlnaHQ6IDQwMCwgc3R5bGU6ICdpdGFsaWMnfSk7XG4gICAgICAgIGxldCBmb250T2JzZXJ2ZXJGaWxvc29maWFCb2xkICAgICAgID0gbmV3IEZvbnRGYWNlT2JzZXJ2ZXIoJ2ZpbG9zb2ZpYScsIHt3ZWlnaHQ6IDcwMCx9KTtcblxuICAgICAgICAvLyBMb2FkIGFsbCBGaWxvc29maWEgZm9udHNcbiAgICAgICAgbGV0IGZpbG9zb2ZpYUFsbCA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGZvbnRPYnNlcnZlckZpbG9zb2ZpYVJlZ3VsYXIubG9hZCgpLFxuICAgICAgICAgICAgZm9udE9ic2VydmVyRmlsb3NvZmlhSXRhbGljLmxvYWQoKSxcbiAgICAgICAgICAgIGZvbnRPYnNlcnZlckZpbG9zb2ZpYUJvbGQubG9hZCgpXG4gICAgICAgIF0pLnRoZW4oICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmb250LWZpbG9zb2ZpYS1sb2FkZWQnKSApO1xuXG4gICAgICAgIC8vIExvYWQgYWxsIE5ldXRyYWZhY2UgZm9udHNcbiAgICAgICAgbGV0IG5ldXRyYWZhY2VBbGwgPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBmb250T2JzZXJ2ZXJOZXV0cmFmYWNlU2VtaS5sb2FkKCksXG4gICAgICAgICAgICBmb250T2JzZXJ2ZXJOZXV0cmFmYWNlQm9sZC5sb2FkKClcbiAgICAgICAgXSkudGhlbiggKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZvbnQtbmV1dHJhZmFjZS1sb2FkZWQnKSApO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgd2luZG93IHJlc2l6ZSB0byBmb3JjZSByZS1yZW5kZXIgd2hlbiBhbGwgZm9udHMgYXJlIGxvYWRlZDtcbiAgICAgICAgUHJvbWlzZS5hbGwoWyBmaWxvc29maWFBbGwsIG5ldXRyYWZhY2VBbGwgXSkudGhlbiggKCkgPT4ge1xuICAgICAgICAgICAgV2luZG93TWFuYWdlci50cmlnZ2VyKCdyZXNpemUnKTtcbiAgICAgICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdmb250c0xvYWRlZCcsIHRydWUpOyAvLyBUaGkgaXMgY2hlY2tlZCBkaXJlY3RseSBpbiB0aGUgbGF5b3V0IHRvIGF2b2lkIEZPVVQgZHVyaW5nIHJlZnJlc2hlc1xuICAgICAgICB9KTtcblxuICAgIH0sXG5cbiAgICBpbml0U1ZHU3ByaXRlKCkge1xuXG4gICAgICAgIGxldCBzdmdEYXRhID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3N2Zy1zcHJpdGUnKTtcbiAgICAgICAgaWYgKHN2Z0RhdGEgJiYgc3ZnRGF0YS5sZW5ndGggJiYgQ29uZmlnLmVudiAhPT0gJ2RldmVsb3BtZW50JyApIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBTVkcgZWxlbWVudCBmcm9tIHN0cmluZyBhbmQgaW5qZWN0IGF0IHRoZSBzdGFydCBvZiB0aGUgYm9keVxuICAgICAgICAgICAgbGV0IHN2Z0RvYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc3ZnRG9jLmlubmVySFRNTCA9IHN2Z0RhdGE7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZSggc3ZnRG9jLmZpcnN0Q2hpbGQsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN2Z0xvYWRlciA9IGZldGNoKGAke0NvbmZpZy5hc3NldFBhdGh9aW1nL3N2Zy9pY29uLXNwcml0ZS5zdmdgKTtcbiAgICAgICAgICAgIHN2Z0xvYWRlclxuICAgICAgICAgICAgICAgIC50aGVuKCByZXNwb25zZSA9PiByZXNwb25zZS50ZXh0KCkgKVxuICAgICAgICAgICAgICAgIC50aGVuKCByZXNwb25zZURhdGEgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDb250YWluZXIuaW5uZXJIVE1MID0gcmVzcG9uc2VEYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdmdEYXRhID0gdGVtcENvbnRhaW5lci5maXJzdENoaWxkO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIFNWRyBzcHJpdGVcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ3N2Zy1zcHJpdGUnLCByZXNwb25zZURhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGluamVjdCBTVkdcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoc3ZnRGF0YSwgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTtcblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgIH0sXG5cbiAgICBsb2FkUGFnZSh1cmwpIHtcblxuICAgICAgICAvLyBUT0RPIHJlcGxhY2Ugd2l0aCBsb2FkZXJcblxuICAgICAgICBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzIDogJ3NhbWUtb3JpZ2luJ1xuICAgICAgICB9KS50aGVuKCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vIGRlY2lkZSBpZiB3ZSdyZSByZXR1cm5pbmcgSlNPTiBvciBzdHJpbmdcbiAgICAgICAgICAgIHJldHVybiAoIHJlc3BvbnNlLmhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKSAmJiByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSApID8gcmVzcG9uc2UuanNvbigpIDogcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9KS50aGVuKCAocmVzcG9uc2VEYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgZG9jdW1lbnRFbCA9IHN0cmluZ1RvRWxlbWVudCggcmVzcG9uc2VEYXRhICk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gQ2hhbmdlIHBhZ2UgdGl0bGVcbiAgICAgICAgICAgIGxldCBwYWdlRWwgPSBkb2N1bWVudEVsLnF1ZXJ5U2VsZWN0b3IoJy5wYWdlJyk7XG5cbiAgICAgICAgICAgIGxldCBwYWdlID0gdGhpcy5pbml0UGFnZSggcGFnZUVsICk7XG5cbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHN0YXRlIGluIGhpc3RvcnlcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7cGFnZUlkOiBwYWdlLmlkfSwgd2luZG93LnRpdGxlLCB1cmwpO1xuXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpbml0UGFnZShwYWdlRWwpIHtcblxuICAgICAgICAvLyBnZXQgdW5pcXVlIHN0cmluZyB0aGF0IGlkJ3MgdGhlIHBhZ2VcbiAgICAgICAgbGV0IHBhZ2VJZCA9IHBhZ2VFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFnZS1pZCcpO1xuXG4gICAgICAgIC8vIEFwcGVuZCBwYWdlIGVsZW1lbnQgYmVmb3JlXG4gICAgICAgIGlmIChwYWdlSWQgIT09ICdob21lJykge1xuICAgICAgICAgICAgdGhpcy5wYWdlRHJhdy5pbmplY3RQYWdlRWwoIHBhZ2VFbCApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGFuIGluc3RhbmNlIGZvciB0aGUgY2xhc3MgYXR0cmlidXRlZCBmb3IgdGhpcyBwYWdlXG4gICAgICAgIGxldCBwYWdlT2JqO1xuICAgICAgICBpZiAoIHBhZ2VMaXN0W3BhZ2VJZF0gKSB7XG4gICAgICAgICAgICBwYWdlT2JqID0gbmV3IHBhZ2VMaXN0W3BhZ2VJZF0oIHBhZ2VFbCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFnZU9iaiA9IG5ldyBwYWdlTGlzdFsnZGVmYXVsdCddKCBwYWdlRWwgKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENhbid0IGZpbmQgcGFnZSBjbGFzcyBmb3IgaWQ6ICR7cGFnZUlkfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwYWdlSWQgPT09ICdob21lJykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2VPYmo7XG4gICAgICAgICAgICB0aGlzLmNsb3NlUGFnZURyYXcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdQYWdlID0gcGFnZU9iajtcbiAgICAgICAgICAgIHRoaXMub3BlblBhZ2VEcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFnZU9iajtcbiAgICB9LFxuXG5cbiAgICBvcGVuUGFnZURyYXcoKSB7XG4gICAgICAgIC8vIFRPRE8gcGF1c2UgY3VycmVudFBhZ2VcblxuICAgICAgICB0aGlzLnBhZ2VEcmF3Lm9wZW4oKTtcbiAgICB9LFxuXG4gICAgY2xvc2VQYWdlRHJhdygpIHtcblxuICAgICAgICAvLyBUT0RPIGlmIHRoZXJlIGlzIG5vIGN1cnJlbnQgcGFnZSwgcmVkaXJlY3Q/XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYXdQYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2VEcmF3LmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3UGFnZS5yZW1vdmUoKTsgLy8gVE9ETyB3YWl0IGZvciB0cmFuc2l0aW9uIHRvIGVuZCA/XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3UGFnZSA9IG51bGw7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFRPRE8gdW4tcGF1c2UgY3VycmVudFBhZ2VcblxuICAgICAgICAvLyBUT0RPIEVtcHR5IHRoZSBkcmF3XG5cbiAgICB9LFxuXG4gICAgX3BvcHN0YXRlSGFuZGxlcihldmVudCkge1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCB3aW5kb3cubG9jYXRpb24uaHJlZiApO1xuXG4gICAgICAgIGlmIChldmVudC5zdGF0ZS5wYWdlSWQgJiYgZXZlbnQuc3RhdGUucGFnZUlkID09PSAnaG9tZScpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQYWdlRHJhdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETyBsb2FkIHBhZ2UgYW5kIHJlb3BlbiBkcmF3XG4gICAgICAgICAgICB0aGlzLmxvYWRQYWdlKCB3aW5kb3cubG9jYXRpb24uaHJlZiApO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgX2dsb2JhbENsaWNrSGFuZGxlcihldmVudCkge1xuICAgICAgICAvLyBpdGVyYXRlIHVwIHRoZSBET00gdG8gZmluZCBpZiBhIGxpbmsgd2FzIGNsaWNrZWRcbiAgICAgICAgbGV0IGxpbmtUYXJnZXQ7XG4gICAgICAgIGxldCBkb21JdGVyID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB3aGlsZSggZG9tSXRlciAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICkge1xuICAgICAgICAgICAgaWYgKGRvbUl0ZXIgJiYgZG9tSXRlci50YWdOYW1lICYmIGRvbUl0ZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICBsaW5rVGFyZ2V0ID0gZG9tSXRlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9tSXRlciA9IGRvbUl0ZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoaXMgdGFyZ2V0XG4gICAgICAgIC8vIC0gaXMgYSBsaW5rLFxuICAgICAgICAvLyAtIGhhcyBhIGhyZWYgYXR0clxuICAgICAgICAvLyAtIHRoZSB1c2VyIGlzbid0IHByZXNzaW5nIGFueSBrZXlib2FyZCBidXR0b25zIHRvIG9wZW4gdGFiIGluIG5ldyB3aW5kb3cuXG4gICAgICAgIC8vIC0gZG9lc24ndCBoYXZlIHRoZSBmb3JjZS1yZWxvYWQgY2xhc3MgKGxpa2UgdGhlIGxhbmcgc2VsZWN0IGZvciBleGFtcGxlKVxuICAgICAgICBpZiAoIGxpbmtUYXJnZXQgJiYgIWV2ZW50Lm1ldGFLZXkgJiYgIWV2ZW50LmN0cmxLZXkgJiYgbGlua1RhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJyAmJiBsaW5rVGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaHJlZicpICYmICFsaW5rVGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZm9yY2UtcmVsb2FkJykgKSB7XG5cbiAgICAgICAgICAgIGlmICggbGlua1RhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2Nsb3NlLXBhZ2UtZHJhdycpKSAge1xuXG4gICAgICAgICAgICAgICAgLy8gR28gYmFjayB0byBob21lIHBhZ2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUGFnZURyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHtwYWdlSWQ6IHRoaXMuY3VycmVudFBhZ2UuaWR9LCB3aW5kb3cudGl0bGUsIGxpbmtUYXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERPIG5vdGhpbmcuIExldCBpdCBoYXBwZW4uICh0ZW1wb3JhcnkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsaW5rSHJlZiA9IGxpbmtUYXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgaWYgKCB3aW5kb3cubG9jYXRpb24uaHJlZiAhPT0gbGlua0hyZWYgJiYgdGhpcy5sb2FkYWJsZVJlZ2V4LnRlc3QoIGxpbmtIcmVmKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY3VycmVudERyYXdQYWdlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHMgOiB0aGlzLmN1cnJlbnREcmF3UGFnZS5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA6IDEwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBXaWxsIHByb2JhYmx5IGJlIGEgY29udGVudCBwYWdlLCBkaXNwbGF5IHRoZSBtYXNrXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZURyYXcucHJlcGFyZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZFBhZ2UoIGxpbmtIcmVmICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8vIFN0YXJ0IEFwcC5cblZDQS5zdGFydCgpOyIsIi8vIFRoaXJkIHBhcnR5IGRlcGVuZGVuY2llc1xuLy8gaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuXG5cbmltcG9ydCBDb25maWcgZnJvbSAnemltcGxpc3QvdXRpbHMvQ29uZmlnJztcblxuLy8gTG9jYWwgYXBwIERlcGVuZGVuY2llc1xuaW1wb3J0IFBhZ2UgZnJvbSAnYXBwL3BhZ2VzL1BhZ2UuYWJzdHJhY3QnO1xuXG5cbi8vIEhpZGRlbiBjb25zdHNcblxuLyoqXG4gKlxuICovXG5jbGFzcyBDYW5kaWRhdGVQYWdlIGV4dGVuZHMgUGFnZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuXG4gICAgICAgIHN1cGVyKGVsLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAod2luZG93LmRhdGFMYXllciB8fCBDb25maWcuZW52ID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygndHJhY2tpbmcgdGltZScpO1xuICAgICAgICAgICAgdGhpcy5faW5pdEdUTVRyYWNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICBcbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFB1YmxpYyBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIGJyZWFrcG9pbnRDaGFuZ2VkKGJyZWFrcG9pbnQsIHByZXZpb3VzQnJlYWtwb2ludCkge1xuXG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFByaXZhdGUgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gICAgX2luaXRHVE1UcmFja2luZygpIHtcbiAgICAgICAgdGhpcy5hZGREb21FdmVudCgnY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSBldmVudC5kZWxlZ2F0ZVRhcmdldDtcblxuICAgICAgICAgICAgbGV0IGxpbmtUeXBlID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS1saW5rLXR5cGUnKTtcbiAgICAgICAgICAgIGxldCBleHRlcm5hbFBsYXRmb3JtID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS1leHRlcm5hbC1wbGF0Zm9ybScpO1xuXG4gICAgICAgICAgICB3aW5kb3cuZGF0YUxheWVyLnB1c2goe1xuICAgICAgICAgICAgICAgICdldmVudCc6ICdleHRlcm5hbENsaWNrJyxcbiAgICAgICAgICAgICAgICAncGFnZUdyb3VwaW5nTWFpc29uJzogJ0h1bWFuIFJlc291cmNlcycsXG4gICAgICAgICAgICAgICAgJ2xpbmtUeXBlJzogbGlua1R5cGUsXG4gICAgICAgICAgICAgICAgJ2V4dGVybmFsUGxhdGZvcm0nOiBleHRlcm5hbFBsYXRmb3JtLFxuICAgICAgICAgICAgICAgICdwYWdlTGFuZ3VhZ2UnIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcsXG4gICAgICAgICAgICAgICAgJ3VyaScgIDogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgJy5idXR0b24nKTtcbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9jaGlsZENsaWNrSGFuZGxlcihldmVudCkge1xuXG4gICAgfVxuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FuZGlkYXRlUGFnZTtcbiIsIi8vIFRoaXJkIHBhcnR5IGRlcGVuZGVuY2llc1xuLy8gaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuXG5pbXBvcnQgU2Nyb2xsaW5nVHJhY2tlciBmcm9tICd6aW1wbGlzdC91dGlscy9TY3JvbGxpbmdUcmFja2VyJztcblxuLy8gTG9jYWwgYXBwIERlcGVuZGVuY2llc1xuaW1wb3J0IFBhZ2UgZnJvbSAnYXBwL3BhZ2VzL1BhZ2UuYWJzdHJhY3QnO1xuaW1wb3J0IFByb2ZpbGVzU2xpZGVyIGZyb20gJ2FwcC9jb21wb25lbnRzL1Byb2ZpbGVTbGlkZXInO1xuaW1wb3J0IE1lZGlhR2FsbGVyeSBmcm9tICdhcHAvY29tcG9uZW50cy9NZWRpYUdhbGxlcnknO1xuXG4vLyBIaWRkZW4gY29uc3RzXG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgQ2FyZWVyc1BhZ2UgZXh0ZW5kcyBQYWdlIHtcblxuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgc3VwZXIoZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIGxldCBwcm9maWxlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5jYXJlZXItcHJvZmlsZXMnKTtcbiAgICAgICAgaWYgKHByb2ZpbGVFbCkge1xuICAgICAgICAgICAgdGhpcy5wcm9maWxlc1NsaWRlciA9IG5ldyBQcm9maWxlc1NsaWRlciggcHJvZmlsZUVsICk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlclN1YlZpZXcoIHRoaXMucHJvZmlsZXNTbGlkZXIgKTtcblxuICAgICAgICAgICAgbGV0IHByb2ZpbGVUcmFja2VyID0gdGhpcy5zY3JvbGxUcmFja2VyLnRyYWNrRWxlbWVudCggcHJvZmlsZUVsLCAxICk7XG5cbiAgICAgICAgICAgIGlmICggcHJvZmlsZVRyYWNrZXIuc3RhdGUgIT09IFNjcm9sbGluZ1RyYWNrZXIuU1RBVEUuT0ZGKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZVByb2ZpbGVzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb2ZpbGVUcmFja2VyLm9uKCdzdGF0ZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RhdGUgIT09IFNjcm9sbGluZ1RyYWNrZXIuU1RBVEUuT0ZGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlUHJvZmlsZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVUcmFja2VyLm9mZignc3RhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZWRpYUdhbGxlcnlFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLm1lZGlhLWdhbGxlcnknKTtcbiAgICAgICAgaWYgKG1lZGlhR2FsbGVyeUVsKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhR2FsbGVyeSA9IG5ldyBNZWRpYUdhbGxlcnkoIG1lZGlhR2FsbGVyeUVsICk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlclN1YlZpZXcoIHRoaXMubWVkaWFHYWxsZXJ5ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2luZG93LmRhdGFMYXllcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdEdUTVRyYWNraW5nKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHVibGljIE1ldGhvZHNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFByaXZhdGUgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBfaW5pdEdUTVRyYWNraW5nKCkge1xuXG4gICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuZGF0YUxheWVyLnB1c2goe1xuICAgICAgICAgICAgICAgICdldmVudCc6ICd2aWRlb1BsYXknLFxuICAgICAgICAgICAgICAgICdwYWdlR3JvdXBpbmdNYWlzb24nICAgIDogJ0h1bWFuIFJlc291cmNlcycsXG4gICAgICAgICAgICAgICAgJ3BhZ2VMYW5ndWFnZScgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAnLmdhbGxlcnktaXRlbS5pdGVtLXZpZGVvLnZpc2libGUnKVxuXG4gICAgfVxuXG4gICAgX2FuaW1hdGVQcm9maWxlcygpIHtcbiAgICAgICAgQXJyYXkuZnJvbSggdGhpcy5wcm9maWxlc1NsaWRlci5lbC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FyZWVyLXByb2ZpbGUnKSApLmZvckVhY2goIGNhcmQgPT4gY2FyZC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKSApO1xuICAgIH1cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBFdmVudCBIYW5kbGVyc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gICAgX2NoaWxkQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG5cbiAgICB9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXJlZXJzUGFnZTtcbiIsIi8vIFRoaXJkIHBhcnR5IGRlcGVuZGVuY2llc1xuaW1wb3J0IHhociBmcm9tIFwieGhyXCI7XG5cbi8vIExvY2FsIGFwcCBEZXBlbmRlbmNpZXNcbmltcG9ydCBQYWdlIGZyb20gJ2FwcC9wYWdlcy9QYWdlLmFic3RyYWN0JztcbmltcG9ydCBlbXB0eSBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L2RvbS9lbXB0eSc7XG5cbi8vIEhpZGRlbiBjb25zdHNcbmNvbnN0IFJFQ0FQVENIQV9BUElfVVJMID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20vcmVjYXB0Y2hhL2FwaS5qcyc7XG5cbmxldCBpbnN0YW5jZXMgPSBbXTtcblxuZnVuY3Rpb24gbG9hZFJlY2FwdGNoYUFwaShpbnN0YW5jZSkge1xuICAgIGlmICggIXdpbmRvdy5ncmVjYXB0Y2hhICkge1xuXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKCBpbnN0YW5jZSApO1xuXG4gICAgICAgIGxldCBzY3JpcHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHRFbC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgd2luZG93LlZDQV9DT05GSUcuY3NwTm9uY2VSZWNhcHRjaGEpO1xuICAgICAgICBzY3JpcHRFbC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdEVsLmRlZmVyID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0RWwuc3JjID0gUkVDQVBUQ0hBX0FQSV9VUkwrJz9vbmxvYWQ9cmVjYXB0Y2hhTG9hZGVkJnJlbmRlcj1leHBsaWNpdCZobD0nK2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRFbCApO1xuXG5cblxuICAgIH1cbn1cblxud2luZG93LnJlY2FwdGNoYUxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHdoaWxlKCBpbnN0YW5jZXMubGVuZ3RoICkge1xuICAgICAgICBpbnN0YW5jZXMuc2hpZnQoKS5faW5pdENhcHRjaGEoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqXG4gKiBDb250YWN0IFBhZ2UgQ2xhc3NcbiAqXG4gKi9cbmNsYXNzIENvbnRhY3RQYWdlIGV4dGVuZHMgUGFnZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5jb250YWN0Rm9ybSA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignZm9ybScpO1xuXG4gICAgICAgIGlmICggd2luZG93LmdyZWNhcHRjaGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRDYXB0Y2hhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkUmVjYXB0Y2hhQXBpKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0dXAgRE9NIGV2ZW50c1xuICAgICAgICB0aGlzLmFkZERvbUV2ZW50KCdzdWJtaXQnLCB0aGlzLl9mb3JtU3VibWl0SGFuZGxlciwgdGhpcy5jb250YWN0Rm9ybSk7XG4gICAgfVxuXG4gICAgX2luaXRDYXB0Y2hhKCkge1xuICAgICAgICB0aGlzLl9jYXB0Y2hhTG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICBsZXQgY2FwdGNoYUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZy1yZWNhcHRjaGEnKTtcblxuICAgICAgICBlbXB0eShjYXB0Y2hhRWwpO1xuXG4gICAgICAgIGxldCBjYXB0Y2hhUmVuZGVyZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY2FwdGNoYUVsLmFwcGVuZENoaWxkKCBjYXB0Y2hhUmVuZGVyZXIgKTtcbiAgICAgICAgd2luZG93LmdyZWNhcHRjaGEucmVuZGVyKCBjYXB0Y2hhUmVuZGVyZXIsIHtcbiAgICAgICAgICAgIHNpdGVrZXkgOiBjYXB0Y2hhRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNpdGVrZXknKSxcbiAgICAgICAgICAgIHNpemUgOiAoIHRoaXMubWluV2lkdGgoJ20nKSA/ICdub3JtYWwnIDogJ2NvbXBhY3QnIClcbiAgICAgICAgfSApO1xuXG4gICAgfVxuXG4gICAgc2VuZERhdGEoKSB7XG4gICAgICAgIGxldCB0aGF0ID0gdGhpcztcbiAgICAgICAgbGV0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRoaXMuY29udGFjdEZvcm0pO1xuICAgICAgICBsZXQgYWN0aW9uID0gdGhpcy5jb250YWN0Rm9ybS5hY3Rpb247XG4gICAgICAgIGxldCBtZXRob2QgPSB0aGlzLmNvbnRhY3RGb3JtLm1ldGhvZDtcblxuICAgICAgICB4aHIoe1xuICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgICAgICB1cmk6IGFjdGlvbixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgICAgIH0sIChlcnIsIHJlc3AsIGJvZHkpID0+IHtcbiAgICAgICAgICAgIGxldCBib2R5T2JqID0gSlNPTi5wYXJzZSggYm9keSApO1xuICAgICAgICAgICAgbGV0IGVycm9ycyA9IGJvZHlPYmouZXJyb3JzO1xuICAgICAgICAgICAgbGV0IGlzU2VudCA9IGJvZHlPYmouaXNfc2VudDtcbiAgICAgICAgICAgIGxldCBjb250YWN0RXJyb3JDb250YWluZXIgPSB0aGF0LmVsLnF1ZXJ5U2VsZWN0b3IoJyNjb250YWN0LWVycm9yJyk7XG5cbiAgICAgICAgICAgIGlmICghaXNTZW50KSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0Q2FwdGNoYSgpO1xuXG4gICAgICAgICAgICAgICAgY29udGFjdEVycm9yQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlcnJvciBpbiBlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvcm1GaWVsZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVycm9yKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGZvcm1GaWVsZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1GaWVsZC5jbGFzc0xpc3QucmVtb3ZlKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybUZpZWxkLnBhcmVudE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnZXJyb3InKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yc1tlcnJvcl0gJiYgZm9ybUZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybUZpZWxkLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybUZpZWxkLnBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlY2FwdGNoYSBzcGVjaWZpYyBlcnJvcnNcbiAgICAgICAgICAgICAgICBsZXQgcmVjYXB0Y2hhRXJyb3JFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnJlY2FwdGNoYS1lcnJvcicpO1xuICAgICAgICAgICAgICAgIGlmICggZXJyb3JzWydyZWNhcHRjaGEnXSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjYXB0Y2hhRXJyb3JFbC50ZXh0Q29udGVudCA9IGVycm9yc1sncmVjYXB0Y2hhJ107XG4gICAgICAgICAgICAgICAgICAgIHJlY2FwdGNoYUVycm9yRWwuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2FwdGNoYUVycm9yRWwuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBoaWRlIGVycm9yc1xuICAgICAgICAgICAgICAgIGNvbnRhY3RFcnJvckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZXJyb3JzIGZyb20gbGFiZWxzXG4gICAgICAgICAgICAgICAgbGV0IGZvcm1MYWJlbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGFiZWwnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBmb3JtTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1MYWJlbHNbaV0uY2xhc3NMaXN0LnJlbW92ZSgnZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZXJyb3JzIGZyb20gaW5wdXRzXG4gICAgICAgICAgICAgICAgbGV0IGZvcm1JbnB1dHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBmb3JtSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1JbnB1dHNbaV0uY2xhc3NMaXN0LnJlbW92ZSgnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUlucHV0c1tpXS52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBlcnJvcnMgZnJvbSB0ZXh0YXJlYXNcbiAgICAgICAgICAgICAgICBsZXQgZm9ybVRleHRhcmVhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZXh0YXJlYScpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGZvcm1UZXh0YXJlYXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybVRleHRhcmVhc1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtVGV4dGFyZWFzW2ldLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHN1Ym1pdENvbnRhaW5lciA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnN1Ym1pdC1jb250YWluZXIgLmJ1dHRvbicpO1xuICAgICAgICAgICAgICAgIHN1Ym1pdENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgIHN1Ym1pdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwic3VibWl0XCJdJykuZGlzYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gc2hvdyBzdWNjZXNzIG1lc3NhZ2UgP1xuICAgICAgICAgICAgICAgIGxldCBzdWNjZXNzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3VjY2VzcycpO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5jb250YWN0Rm9ybS5jbGFzc0xpc3QuYWRkKCdpcy1zZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFB1YmxpYyBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBQcml2YXRlIE1ldGhvZHNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9wcml2YXRlRnVuY3Rpb24oKSB7XG5cbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9jaGlsZENsaWNrSGFuZGxlcigpIHtcblxuICAgIH1cblxuICAgIF9mb3JtU3VibWl0SGFuZGxlcihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHRoaXMuc2VuZERhdGEoKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udGFjdFBhZ2U7XG4iLCIvLyBUaGlyZCBwYXJ0eSBkZXBlbmRlbmNpZXNcbi8vIGltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBmaW5kTGFzdCBmcm9tICdsb2Rhc2gvZmluZExhc3QnO1xuXG5pbXBvcnQgU3ByaXRlQW5pbWF0b3IgZnJvbSAnemltcGxpc3QvZGlzcGxheS9hbmltYXRpb24vU3ByaXRlQW5pbWF0b3InO1xuaW1wb3J0IFNjcm9sbGluZ1RyYWNrZXIgZnJvbSAnemltcGxpc3QvdXRpbHMvU2Nyb2xsaW5nVHJhY2tlcic7XG5pbXBvcnQgV2luZG93TWFuYWdlciBmcm9tICd6aW1wbGlzdC91dGlscy9XaW5kb3dNYW5hZ2VyJztcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSAnemltcGxpc3QvZGlzcGxheS9nZXREb2N1bWVudFJlY3QnO1xuXG4vLyBMb2NhbCBhcHAgRGVwZW5kZW5jaWVzXG5pbXBvcnQgUGFnZSBmcm9tICdhcHAvcGFnZXMvUGFnZS5hYnN0cmFjdCc7XG5pbXBvcnQgUHJvZ3Jlc3NQYXRoIGZyb20gJ2FwcC9jb21wb25lbnRzL1Byb2dyZXNzUGF0aCc7XG5pbXBvcnQgQ2FyZWVyU2xpZGVyIGZyb20gJ2FwcC9jb21wb25lbnRzL0NhcmVlclNsaWRlcic7XG5pbXBvcnQgQWxwaGFWaWRlbyBmcm9tICdhcHAvY29tcG9uZW50cy9BbHBoYVZpZGVvJztcblxuLy8gSGlkZGVuIGNvbnN0c1xuY29uc3QgTUVOVV9DT0xMQVBTRV9IRUlHSFQgPSAxMTE7XG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgSG9tZVBhZ2UgZXh0ZW5kcyBQYWdlIHtcblxuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgc3VwZXIoZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuY2FyZWVyU2xpZGVyID0gbmV3IENhcmVlclNsaWRlcih0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXInKSk7XG5cbiAgICAgICAgdGhpcy5wcm9ncmVzc1BhdGggPSBuZXcgUHJvZ3Jlc3NQYXRoKCB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5wcm9ncmVzcy1wYXRoJyksIHtcbiAgICAgICAgICAgIHdheXBvaW50cyA6IEFycmF5LmZyb20odGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCcuYnJhbmQtaW5pdGlhbHMnKSksXG4gICAgICAgICAgICBjdXRvdXRzIDogQXJyYXkuZnJvbSh0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9ncmVzcy1wYXRoLWN1dG91dCcpKVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFscGhhVmlkZW9zID0gQXJyYXkuZnJvbSggdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCcuYWxwaGEtdmlkZW8nKSApLm1hcCggYWxwaGFWaWRlbyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFscGhhVmlkZW8oIGFscGhhVmlkZW8gKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gd2FpdCBmb3IgZGFuY2VyIHZpZGVvIHRvIGJlIGxvYWRlZFxuICAgICAgICB0aGlzLmFkZERvbUV2ZW50KCdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtXaW5kb3dNYW5hZ2VyLnRyaWdnZXIoJ3Jlc2l6ZScpO30sIHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmRhbmNlci1hbmltIHZpZGVvJykpO1xuXG4gICAgICAgIGlmICh3aW5kb3cuZGF0YUxheWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0R1RNVHJhY2tpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUYWNrZWRTZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyU3ViVmlldyggdGhpcy5wcm9ncmVzc1BhdGggKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJTdWJWaWV3KCB0aGlzLmNhcmVlclNsaWRlciApO1xuXG4gICAgICAgIHRoaXMuYnJlYWtwb2ludENoYW5nZWQoKTtcblxuICAgICAgICB0aGlzLl9pbml0U2Nyb2xsaW5nVHJhY2tlcigpO1xuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHVibGljIE1ldGhvZHNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgYnJlYWtwb2ludENoYW5nZWQoKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLm1pbldpZHRoKCdtJykgKSB7XG5cbiAgICAgICAgICAgIGlmICggIXRoaXMucHJvZHVjdFNwcml0ZSApIHtcbiAgICAgICAgICAgICAgICBsZXQgc3ByaXRlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcHJpdGUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2R1Y3RTcHJpdGUgPSBuZXcgU3ByaXRlQW5pbWF0b3Ioc3ByaXRlRWwsIHtmcHMgOiAwLjc1LCBudW1GcmFtZXM6IDksIHVybCA6IHNwcml0ZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKX0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyU3ViVmlldyggdGhpcy5wcm9kdWN0U3ByaXRlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggdGhpcy5wcm9kdWN0U3ByaXRlICkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvZHVjdFNwcml0ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5yZWdpc3RlclN1YlZpZXcoIHRoaXMucHJvZHVjdFNwcml0ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXNpemUoKSB7XG4gICAgICAgIHN1cGVyLnJlc2l6ZSgpO1xuXG4gICAgICAgIC8vIFNhdmUgc2VjdGlvbiBvZmZzZXQgZm9yIEdUTSB0cmFja2luZ1xuICAgICAgICB0aGlzLl9zZWN0aW9uT2Zmc2V0cyA9IEFycmF5LmZyb20oIHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnLnBhZ2Utc2VjdGlvbicpICkubWFwKCBzZWN0aW9uID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZWw6IHNlY3Rpb24sXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBnZXREb2N1bWVudFJlY3Qoc2VjdGlvbikudG9wIC0gTUVOVV9DT0xMQVBTRV9IRUlHSFRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBQcml2YXRlIE1ldGhvZHNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgICogRm9yIHBlcmZvcm1hbmNlIGFuZCBkZWxheWVkIGFuaW1hdGlvbiByZWFzb25zLCB3ZSBzY3JvbGwgdHJhY2sgdmFyaW91cyBlbGVtZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFNjcm9sbGluZ1RyYWNrZXIoKSB7XG4gICAgICAgIC8vIHRoaXMuc2Nyb2xsVHJhY2tlciA9IG5ldyBTY3JvbGxpbmdUcmFja2VyKCk7XG5cbiAgICAgICAgLy8gc2Nyb2xsaW5nIHRyYWNrZXIgZm9yIGJ1dHRlcmZseSBhbmltcyBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICAgICAgICBBcnJheS5mcm9tKCB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5idXR0ZXJmbHktb3ZlcmxheS5hbHBoYS12aWRlbycpICkuZm9yRWFjaCggKG92ZXJsYXkpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFja2VyID0gdGhpcy5zY3JvbGxUcmFja2VyLnRyYWNrRWxlbWVudCggb3ZlcmxheSApO1xuICAgICAgICAgICAgdHJhY2tlci5vbignc3RhdGUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdmlkZW8gPSBvdmVybGF5LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSBTY3JvbGxpbmdUcmFja2VyLlNUQVRFLk9GRikge1xuICAgICAgICAgICAgICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2Nyb2xsaW5nIHRyYWNrZXIgZm9yIHByb2R1Y3Qgc3ByaXRlIGFuaW1hdG9yXG4gICAgICAgIGlmICh0aGlzLnByb2R1Y3RTcHJpdGUpIHtcbiAgICAgICAgICAgIGxldCBwcm9kdWN0U3ByaXRlVHJhY2tlciA9IHRoaXMuc2Nyb2xsVHJhY2tlci50cmFja0VsZW1lbnQodGhpcy5wcm9kdWN0U3ByaXRlLmVsKTtcbiAgICAgICAgICAgIHByb2R1Y3RTcHJpdGVUcmFja2VyLm9uKCdzdGF0ZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PVkVSTEFQIHx8IGV2ZW50LnN0YXRlID09PSBTY3JvbGxpbmdUcmFja2VyLlNUQVRFLk9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZHVjdFNwcml0ZS5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9kdWN0U3ByaXRlLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwcm9kdWN0U3ByaXRlVHJhY2tlci5zdGF0ZSA9PT0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PTiB8fCBwcm9kdWN0U3ByaXRlVHJhY2tlci5zdGF0ZSA9PT0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PVkVSTEFQKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9kdWN0U3ByaXRlLnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gVHJhY2sgY2FyZWVycyBzbGlkZXJcbiAgICAgICAgbGV0IGNhcmVlclNsaWRlckVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdzZWN0aW9uLmNhcmVlcnMgLnNsaWRlcicpO1xuICAgICAgICBsZXQgY2FyZWVyU2xpZGVyVHJhY2tlciA9IHRoaXMuc2Nyb2xsVHJhY2tlci50cmFja0VsZW1lbnQoIGNhcmVlclNsaWRlckVsKTtcblxuICAgICAgICBpZiAoY2FyZWVyU2xpZGVyVHJhY2tlci5zdGF0ZSA9PT0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PRkYpIHtcbiAgICAgICAgICAgIGxldCB2aXNpYmxlU2xpZGVzID0gQXJyYXkuZnJvbSggY2FyZWVyU2xpZGVyRWwucXVlcnlTZWxlY3RvckFsbCgnLnNsaWRlci1pdGVtLnZpc2libGUnKSApO1xuICAgICAgICAgICAgdmlzaWJsZVNsaWRlcy5mb3JFYWNoKCBzbGlkZSA9PiBzbGlkZS5jbGFzc0xpc3QuYWRkKCdhbmltLWluJykpO1xuICAgICAgICAgICAgY2FyZWVyU2xpZGVyVHJhY2tlci5vbignc3RhdGUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RhdGUgIT09IFNjcm9sbGluZ1RyYWNrZXIuU1RBVEUuT0ZGKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBldmVudCB0byBvbmx5IGFuaW1hdGUgb25jZVxuICAgICAgICAgICAgICAgICAgICBjYXJlZXJTbGlkZXJUcmFja2VyLm9mZignc3RhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZVNsaWRlcy5mb3JFYWNoKCAoc2xpZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoICgpID0+IHNsaWRlLmNsYXNzTGlzdC5yZW1vdmUoJ2FuaW0taW4nKSwgNDAwICsgKGkgKiAyMDApICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBTY3JvbGxpbmcgdHJhY2tlciBmb3IgZGFuY2VyIGFuaW1cbiAgICAgICAgbGV0IGRhbmNlckFuaW0gPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5kYW5jZXItYW5pbScpO1xuICAgICAgICBsZXQgZGFuY2VyQW5pbVRyYWNrZXIgPSB0aGlzLnNjcm9sbFRyYWNrZXIudHJhY2tFbGVtZW50KCBkYW5jZXJBbmltLCAwLjc1ICk7XG5cbiAgICAgICAgLy8gb25seSBwbGF5IG9uY2UsIHNvIGRvbid0IGxpc3RlbiBmb3IgZXZlbnRzIGlmIGFscmVhZHkgb25zY3JlZW5cbiAgICAgICAgaWYgKGRhbmNlckFuaW1UcmFja2VyLnN0YXRlID09PSBTY3JvbGxpbmdUcmFja2VyLlNUQVRFLk9OIHx8IGRhbmNlckFuaW1UcmFja2VyLnN0YXRlID09PSBTY3JvbGxpbmdUcmFja2VyLlNUQVRFLk9WRVJMQVApIHtcbiAgICAgICAgICAgIGRhbmNlckFuaW0ucXVlcnlTZWxlY3RvcigndmlkZW8nKS5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYW5jZXJBbmltVHJhY2tlci5vbignc3RhdGUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RhdGUgPT09IFNjcm9sbGluZ1RyYWNrZXIuU1RBVEUuT1ZFUkxBUCB8fCBldmVudC5zdGF0ZSA9PT0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PTikge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCAoKSA9PiBkYW5jZXJBbmltLnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJykucGxheSgpLCAzNzUpO1xuICAgICAgICAgICAgICAgICAgICBkYW5jZXJBbmltVHJhY2tlci5vZmYoJ3N0YXRlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGFuY2VyQW5pbS5xdWVyeVNlbGVjdG9yKCd2aWRlbycpLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFRyYWNrIHRoZW1lIGl0ZW1zIHRvIGZhZGUgaW5cbiAgICAgICAgQXJyYXkuZnJvbSggdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCcudGhlbWUtY29udGFpbmVyIGxpLnRoZW1lLWhpZGRlbicpICkuZm9yRWFjaCggdGhlbWVJdGVtID0+IHtcblxuICAgICAgICAgICAgbGV0IHRyYWNrZXIgPSB0aGlzLnNjcm9sbFRyYWNrZXIudHJhY2tFbGVtZW50KCB0aGVtZUl0ZW0gKTtcblxuICAgICAgICAgICAgLy8gb25seSBwbGF5IG9uY2UsIHNvIGRvbid0IGxpc3RlbiBmb3IgZXZlbnRzIGlmIGFscmVhZHkgb25zY3JlZW5cbiAgICAgICAgICAgIGlmICh0cmFja2VyLnN0YXRlID09PSBTY3JvbGxpbmdUcmFja2VyLlNUQVRFLk9OIHx8IHRyYWNrZXIuc3RhdGUgPT09IFNjcm9sbGluZ1RyYWNrZXIuU1RBVEUuT1ZFUkxBUCkge1xuICAgICAgICAgICAgICAgIHRoZW1lSXRlbS5jbGFzc0xpc3QucmVtb3ZlKCd0aGVtZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2tlci5vbignc3RhdGUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSBTY3JvbGxpbmdUcmFja2VyLlNUQVRFLk9WRVJMQVAgfHwgZXZlbnQuc3RhdGUgPT09IFNjcm9sbGluZ1RyYWNrZXIuU1RBVEUuT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lSXRlbS5jbGFzc0xpc3QucmVtb3ZlKCd0aGVtZS1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZW5hYmxlIHNjcm9sbGluZyB0cmFja2VyIGZvciBkYW5jZXItbGluZS5cbiAgICAgICAgbGV0IGRhbmNlckxpbmVGdWxsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuY2FuZGlkYXRlIC5kYW5jZXItbGluZSAuZnVsbCcpO1xuICAgICAgICBsZXQgZGFuY2VyTGluZVNjcm9sbFRyYWNrZXIgPSB0aGlzLnNjcm9sbFRyYWNrZXIudHJhY2tFbGVtZW50KCBkYW5jZXJMaW5lRnVsbCwgMC4yNSApO1xuXG4gICAgICAgIGlmIChkYW5jZXJMaW5lU2Nyb2xsVHJhY2tlci5zdGF0ZSA9PT0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PTikge1xuICAgICAgICAgICAgZGFuY2VyTGluZUZ1bGwuY2xhc3NMaXN0LnJlbW92ZSgnc3RhY2tlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGFuY2VyTGluZVNjcm9sbFRyYWNrZXIub25jZSgnc3RhdGU6b3ZlcmxhcCcsICgpID0+IGRhbmNlckxpbmVGdWxsLmNsYXNzTGlzdC5yZW1vdmUoJ3N0YWNrZWQnKSApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBfaW5pdEdUTVRyYWNraW5nKCkge1xuXG4gICAgICAgIC8vIE91ciB2YWx1ZXMgQ1RBXG4gICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuZGF0YUxheWVyLnB1c2goe1xuICAgICAgICAgICAgICAgICdldmVudCcgICAgICAgICAgICAgICAgIDogJ3ZpcnR1YWxTZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAncGFnZUdyb3VwaW5nTWFpc29uJyAgICA6ICdIdW1hbiBSZXNvdXJjZXMnLFxuICAgICAgICAgICAgICAgICdzZWN0aW9uJyAgICAgICAgICAgICAgIDogJ2JyYW5kLXZhbHVlcycsXG4gICAgICAgICAgICAgICAgJ3N1YlNlY3Rpb24nICAgICAgICAgICAgOiAnYnJhbmQtdmFsdWVzJyxcbiAgICAgICAgICAgICAgICAndXJpJyAgICAgICAgICAgICAgICAgICA6IGV2ZW50LmRlbGVnYXRlVGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpLFxuICAgICAgICAgICAgICAgICdwYWdlTGFuZ3VhZ2UnICAgICAgICAgIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sICdzZWN0aW9uLmJyYW5kLXZhbHVlcyAuYnV0dG9uJyk7XG5cbiAgICAgICAgdGhpcy5hZGREb21FdmVudCgnY2xpY2snLCAoZXZlbnQpID0+IHtcblxuICAgICAgICAgICAgbGV0IGxpbmsgPSBldmVudC5kZWxlZ2F0ZVRhcmdldC5xdWVyeVNlbGVjdG9yKCcuY2FyZWVyLXRpdGxlIGEnKTtcblxuICAgICAgICAgICAgd2luZG93LmRhdGFMYXllci5wdXNoKHtcbiAgICAgICAgICAgICAgICAnZXZlbnQnICAgICAgICAgICAgICAgICA6ICd2aXJ0dWFsU2VjdGlvbicsXG4gICAgICAgICAgICAgICAgJ3BhZ2VHcm91cGluZ01haXNvbicgICAgOiAnSHVtYW4gUmVzb3VyY2VzJyxcbiAgICAgICAgICAgICAgICAnc2VjdGlvbicgICAgICAgICAgICAgICA6ICdodW1hbi1yZXNvdXJjZXMnLFxuICAgICAgICAgICAgICAgICdzdWJTZWN0aW9uJyAgICAgICAgICAgIDogbGluay5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHJhY2tpbmctaWQnKSxcbiAgICAgICAgICAgICAgICAndXJpJyAgICAgICAgICAgICAgICAgICA6IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJyksXG4gICAgICAgICAgICAgICAgJ3BhZ2VMYW5ndWFnZScgICAgICAgICAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZ1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCAnLmNhcmVlcnMgLnNsaWRlci1pdGVtJyk7XG5cbiAgICAgICAgdGhpcy5hZGREb21FdmVudCgnY2xpY2snLCAoZXZlbnQpID0+IHtcblxuICAgICAgICAgICAgbGV0IGxpbmsgPSBldmVudC5kZWxlZ2F0ZVRhcmdldDtcblxuICAgICAgICAgICAgd2luZG93LmRhdGFMYXllci5wdXNoKHtcbiAgICAgICAgICAgICAgICAnZXZlbnQnICAgICAgICAgICAgICAgICA6ICd2aXJ0dWFsU2VjdGlvbicsXG4gICAgICAgICAgICAgICAgJ3BhZ2VHcm91cGluZ01haXNvbicgICAgOiAnSHVtYW4gUmVzb3VyY2VzJyxcbiAgICAgICAgICAgICAgICAnc2VjdGlvbicgICAgICAgICAgICAgICA6ICdIdW1hbiBSZXNvdXJjZXMnLFxuICAgICAgICAgICAgICAgICdzdWJTZWN0aW9uJyAgICAgICAgICAgIDogbGluay5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHJhY2tpbmctaWQnKSxcbiAgICAgICAgICAgICAgICAndXJpJyAgICAgICAgICAgICAgICAgICA6IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJyksXG4gICAgICAgICAgICAgICAgJ3BhZ2VMYW5ndWFnZScgICAgICAgICAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgJy5wYWdlLXNlY3Rpb24uaHVtYW4tcmVzb3VyY2VzIC5idXR0b24nKTtcblxuICAgICAgICB0aGlzLmFkZERvbUV2ZW50KCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LmRhdGFMYXllci5wdXNoKHtcbiAgICAgICAgICAgICAgICAnZXZlbnQnICAgICAgICAgICAgICAgICA6ICd2aXJ0dWFsU2VjdGlvbicsXG4gICAgICAgICAgICAgICAgJ3BhZ2VHcm91cGluZ01haXNvbicgICAgOiAnSHVtYW4gUmVzb3VyY2VzJyxcbiAgICAgICAgICAgICAgICAnc2VjdGlvbicgICAgICAgICAgICAgICA6ICdjYW5kaWRhdGUnLFxuICAgICAgICAgICAgICAgICdzdWJTZWN0aW9uJyAgICAgICAgICAgIDogJ2NhbmRpZGF0ZScsXG4gICAgICAgICAgICAgICAgJ3VyaScgICAgICAgICAgICAgICAgICAgOiBldmVudC5kZWxlZ2F0ZVRhcmdldC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSxcbiAgICAgICAgICAgICAgICAncGFnZUxhbmd1YWdlJyAgICAgICAgICA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgJ3NlY3Rpb24uY2FuZGlkYXRlIC5idXR0b24nKTtcblxuXG4gICAgICAgIHRoaXMubGlzdGVuVG8oIFdpbmRvd01hbmFnZXIsICdzY3JvbGwnLCAoZXZlbnQpID0+IHtcblxuICAgICAgICAgICAgbGV0IHNlY3Rpb24gPSBmaW5kTGFzdCggdGhpcy5fc2VjdGlvbk9mZnNldHMsIHNlY3Rpb25PZmZzZXQgPT4gV2luZG93TWFuYWdlci5zY3JvbGxQb3NpdGlvbi50b3AgPj0gc2VjdGlvbk9mZnNldC5vZmZzZXQgKTtcblxuICAgICAgICAgICAgaWYgKHNlY3Rpb24gJiYgc2VjdGlvbiAhPT0gdGhpcy5fY3VycmVudFRhY2tlZFNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VjdGlvbkFuY2hvciA9IHNlY3Rpb24uZWwucXVlcnlTZWxlY3RvcignYVtuYW1lXScpO1xuICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uQW5jaG9yKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmRhdGFMYXllci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdldmVudCcgICAgICAgICAgICAgICAgIDogJ3ZpcnR1YWxTZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYWdlR3JvdXBpbmdNYWlzb24nICAgIDogJ0h1bWFuIFJlc291cmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VjdGlvbicgICAgICAgICAgICAgICA6IHNlY3Rpb25BbmNob3IuZ2V0QXR0cmlidXRlKCduYW1lJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAndXJpJyAgICAgICAgICAgICAgICAgICA6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYWdlTGFuZ3VhZ2UnICAgICAgICAgIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhY2tlZFNlY3Rpb24gPSBzZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBFdmVudCBIYW5kbGVyc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWVQYWdlO1xuIiwiLy8gVGhpcmQgcGFydHkgZGVwZW5kZW5jaWVzXG4vLyBpbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5cbmltcG9ydCBTY3JvbGxpbmdUcmFja2VyIGZyb20gJ3ppbXBsaXN0L3V0aWxzL1Njcm9sbGluZ1RyYWNrZXInO1xuXG4vLyBMb2NhbCBhcHAgRGVwZW5kZW5jaWVzXG5pbXBvcnQgUGFnZSBmcm9tICdhcHAvcGFnZXMvUGFnZS5hYnN0cmFjdCc7XG5pbXBvcnQgUHJvZmlsZXNTbGlkZXIgZnJvbSAnYXBwL2NvbXBvbmVudHMvUHJvZmlsZVNsaWRlcic7XG5pbXBvcnQgTWVkaWFHYWxsZXJ5IGZyb20gJ2FwcC9jb21wb25lbnRzL01lZGlhR2FsbGVyeSc7XG5cbi8vIEhpZGRlbiBjb25zdHNcblxuLyoqXG4gKlxuICovXG5jbGFzcyBIdW1hblJlc291cmNlc1BhZ2UgZXh0ZW5kcyBQYWdlIHtcblxuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgc3VwZXIoZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIGxldCBwcm9maWxlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5jYXJlZXItcHJvZmlsZS1zbGlkZXInKTtcbiAgICAgICAgaWYgKHByb2ZpbGVFbCkge1xuICAgICAgICAgICAgdGhpcy5wcm9maWxlc1NsaWRlciA9IG5ldyBQcm9maWxlc1NsaWRlciggcHJvZmlsZUVsICk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlclN1YlZpZXcoIHRoaXMucHJvZmlsZXNTbGlkZXIgKTtcblxuICAgICAgICAgICAgbGV0IHByb2ZpbGVUcmFja2VyID0gdGhpcy5zY3JvbGxUcmFja2VyLnRyYWNrRWxlbWVudCggcHJvZmlsZUVsLCAwLjc1ICk7XG5cbiAgICAgICAgICAgIGlmICggcHJvZmlsZVRyYWNrZXIuc3RhdGUgIT09IFNjcm9sbGluZ1RyYWNrZXIuU1RBVEUuT0ZGKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZVByb2ZpbGVzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcHJvZmlsZVRyYWNrZXIub24oJ3N0YXRlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PVkVSTEFQIHx8IGV2ZW50LnN0YXRlID09PSBTY3JvbGxpbmdUcmFja2VyLlNUQVRFLk9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlUHJvZmlsZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVUcmFja2VyLm9mZignc3RhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lZGlhR2FsbGVyeUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcubWVkaWEtZ2FsbGVyeScpO1xuICAgICAgICBpZiAobWVkaWFHYWxsZXJ5RWwpIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWFHYWxsZXJ5ID0gbmV3IE1lZGlhR2FsbGVyeSggbWVkaWFHYWxsZXJ5RWwgKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyU3ViVmlldyggdGhpcy5tZWRpYUdhbGxlcnkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdvb2dsZSBUYWcgTWFuYWdlclxuICAgICAgICBpZiAod2luZG93LmRhdGFMYXllcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdEdUTVRyYWNraW5nKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHVibGljIE1ldGhvZHNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFByaXZhdGUgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBfaW5pdEdUTVRyYWNraW5nKCkge1xuICAgICAgICB0aGlzLmFkZERvbUV2ZW50KCdjbGljaycsIChldmVudCkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgYnV0dG9uID0gZXZlbnQuZGVsZWdhdGVUYXJnZXQ7XG5cbiAgICAgICAgICAgIGxldCBsaW5rVHlwZSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGluay10eXBlJyk7XG4gICAgICAgICAgICBsZXQgZXh0ZXJuYWxQbGF0Zm9ybSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtZXh0ZXJuYWwtcGxhdGZvcm0nKTtcblxuICAgICAgICAgICAgaWYgKGxpbmtUeXBlKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmRhdGFMYXllci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgJ2V2ZW50JzogJ2V4dGVybmFsQ2xpY2snLFxuICAgICAgICAgICAgICAgICAgICAncGFnZUdyb3VwaW5nTWFpc29uJzogJ0h1bWFuIFJlc291cmNlcycsXG4gICAgICAgICAgICAgICAgICAgICdsaW5rVHlwZSc6IGxpbmtUeXBlLFxuICAgICAgICAgICAgICAgICAgICAncGFnZUxhbmd1YWdlJyA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4dGVybmFsUGxhdGZvcm0pIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZGF0YUxheWVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAnZXZlbnQnOiAnZXh0ZXJuYWxDbGljaycsXG4gICAgICAgICAgICAgICAgICAgICdwYWdlR3JvdXBpbmdNYWlzb24nOiAnSHVtYW4gUmVzb3VyY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2V4dGVybmFsUGxhdGZvcm0nOiBleHRlcm5hbFBsYXRmb3JtLFxuICAgICAgICAgICAgICAgICAgICAncGFnZUxhbmd1YWdlJyA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwgJy5idXR0b24nKTtcblxuICAgICAgICB0aGlzLmFkZERvbUV2ZW50KCdjbGljaycsICgpID0+IHtcblxuICAgICAgICAgICAgd2luZG93LmRhdGFMYXllci5wdXNoKHtcbiAgICAgICAgICAgICAgICAnZXZlbnQnOiAndmlkZW9QbGF5JyxcbiAgICAgICAgICAgICAgICAnbGluZSc6ICdIdW1hbiBSZXNvdXJjZXMnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCAnLmdhbGxlcnktaXRlbS5pdGVtLXZpZGVvLnZpc2libGUnKTtcbiAgICB9XG5cbiAgICBfYW5pbWF0ZVByb2ZpbGVzKCkge1xuICAgICAgICBBcnJheS5mcm9tKCB0aGlzLnByb2ZpbGVzU2xpZGVyLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJlZXItcHJvZmlsZScpICkuZm9yRWFjaCggY2FyZCA9PiBjYXJkLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpICk7XG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIEV2ZW50IEhhbmRsZXJzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgICBfY2hpbGRDbGlja0hhbmRsZXIoZXZlbnQpIHtcblxuICAgIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEh1bWFuUmVzb3VyY2VzUGFnZTtcbiIsIi8vIFRoaXJkIHBhcnR5IGRlcGVuZGVuY2llc1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC9kZWJvdW5jZSc7XG5pbXBvcnQgYW5pbWUgZnJvbSAnYW5pbWVqcyc7XG5cbi8vIFppbXBsaXN0IERlcGVkZW5jaWVzXG5pbXBvcnQgQ29udGFpbmVyVmlldyBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L0NvbnRhaW5lclZpZXcnO1xuaW1wb3J0IFdpbmRvd01hbmFnZXIgZnJvbSAnemltcGxpc3QvdXRpbHMvV2luZG93TWFuYWdlcic7XG5pbXBvcnQgU2Nyb2xsaW5nVHJhY2tlciBmcm9tICd6aW1wbGlzdC91dGlscy9TY3JvbGxpbmdUcmFja2VyJztcbmltcG9ydCBTdHlsZSBmcm9tICd6aW1wbGlzdC91dGlscy9TdHlsZSc7XG5cbi8vIExvY2FsIGFwcCBEZXBlbmRlbmNpZXNcblxuXG4vLyBIaWRkZW4gY29uc3RzXG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgUGFnZSBleHRlbmRzIENvbnRhaW5lclZpZXcge1xuXG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMubGlzdGVuVG8oV2luZG93TWFuYWdlciwgJ3Jlc2l6ZScsIHRoaXMucmVzaXplKTtcblxuICAgICAgICAvLyBFdmVyeSBwYWdlIG5lZWRzIGEgc2Nyb2xsaW5nIHRyYWNrZXJcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSB0aGlzLmVsLnBhcmVudE5vZGU7XG5cbiAgICAgICAgdGhpcy5zY3JvbGxUcmFja2VyID0gbmV3IFNjcm9sbGluZ1RyYWNrZXIoICh0aGlzLmlkID09PSAnaG9tZScpID8gd2luZG93IDogcGFyZW50Tm9kZSApO1xuXG4gICAgICAgIGxldCBjb250ZW50UGFnZUNvdmVyID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuY29udGVudC1wYWdlLWNvdmVyID4gaW1nJyk7XG4gICAgICAgIGlmIChjb250ZW50UGFnZUNvdmVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRQYWdlQ292ZXIgPSBjb250ZW50UGFnZUNvdmVyO1xuICAgICAgICAgICAgdGhpcy5hZGREb21FdmVudCggJ3Njcm9sbCcsIHRoaXMuX3Njcm9sbEhhbmRsZXIsIHRoaXMuc2Nyb2xsVHJhY2tlci5zY3JvbGxDb250YWluZXIgKTtcbiAgICAgICAgfVxuXG5cbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFB1YmxpYyBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXBhZ2UtaWQnKTtcbiAgICB9XG5cbiAgICBfc2Nyb2xsSGFuZGxlcihldmVudCkge1xuXG4gICAgICAgIGlmICghdGhpcy5xdWV1ZWRGcmFtZSkge1xuXG4gICAgICAgICAgICB0aGlzLnF1ZXVlZEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVHJhY2tlci5fZ2V0U2Nyb2xsQ29udGFpbmVyU2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICAgICAgU3R5bGUuc2V0KCB0aGlzLmNvbnRlbnRQYWdlQ292ZXIsIHt0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKCR7c2Nyb2xsVG9wICogMC41fXB4KWB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlZEZyYW1lID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFnZTtcbiIsIi8vIFRoaXJkIHBhcnR5IGRlcGVuZGVuY2llc1xuLy8gaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IGFuaW1lIGZyb20gJ2FuaW1lanMnO1xuXG5pbXBvcnQgU2Nyb2xsaW5nVHJhY2tlciBmcm9tICd6aW1wbGlzdC91dGlscy9TY3JvbGxpbmdUcmFja2VyJztcblxuLy8gTG9jYWwgYXBwIERlcGVuZGVuY2llc1xuaW1wb3J0IFBhZ2UgZnJvbSAnYXBwL3BhZ2VzL1BhZ2UuYWJzdHJhY3QnO1xuaW1wb3J0IFZhbHVlc1doZWVsIGZyb20gJ2FwcC9jb21wb25lbnRzL3ZhbHVlcy13aGVlbC9WYWx1ZXNXaGVlbCc7XG5pbXBvcnQgVmFsdWVzV2hlZWxTbWFsbCBmcm9tICdhcHAvY29tcG9uZW50cy92YWx1ZXMtd2hlZWwvVmFsdWVzV2hlZWxTbWFsbCc7XG5cbi8vIEhpZGRlbiBjb25zdHNcblxuLyoqXG4gKlxuICovXG5jbGFzcyBWYWx1ZXNQYWdlIGV4dGVuZHMgUGFnZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuXG4gICAgICAgIHN1cGVyKGVsLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmFkZERvbUV2ZW50KCdjbGljaycsIHRoaXMuX21vcmVWYWx1ZXNUcmlnZ2VyQ2xpY2tIYW5kbGVyLCAnLm1vcmUtdmFsdWVzLXRyaWdnZXInKTtcblxuICAgICAgICBsZXQgdmFsdWVzV2hlZWxFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnZhbHVlcy13aGVlbCcpO1xuXG4gICAgICAgIGlmICggdGhpcy5taW5XaWR0aCgnbScpICkge1xuICAgICAgICAgICAgdGhpcy53aGVlbCA9IG5ldyBWYWx1ZXNXaGVlbCggdmFsdWVzV2hlZWxFbCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53aGVlbCA9IG5ldyBWYWx1ZXNXaGVlbFNtYWxsKCB2YWx1ZXNXaGVlbEVsICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgd2hlZWxUcmFja2VyID0gdGhpcy5zY3JvbGxUcmFja2VyLnRyYWNrRWxlbWVudCggdmFsdWVzV2hlZWxFbCApO1xuXG4gICAgICAgIGlmICh3aGVlbFRyYWNrZXIuc3RhdGUgIT09IFNjcm9sbGluZ1RyYWNrZXIuU1RBVEUuT0ZGKSB7XG4gICAgICAgICAgICB0aGlzLndoZWVsLmludHJvQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRyYWNrZXIudW50cmFja0VsZW1lbnQoIHdoZWVsVHJhY2tlciApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlZWxUcmFja2VyLm9uKCdzdGF0ZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PTiB8fCBldmVudC5zdGF0ZSA9PT0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PVkVSTEFQKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2hlZWwuaW50cm9BbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgd2hlZWxUcmFja2VyLm9mZignc3RhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUcmFja2VyLnVudHJhY2tFbGVtZW50KCB3aGVlbFRyYWNrZXIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdvb2dsZSBUYWcgTWFuYWdlclxuICAgICAgICBsZXQgYnV0dG9ucyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnLmJ1dHRvbicpO1xuXG4gICAgICAgIGJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGREb21FdmVudCgnY2xpY2snLCAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBsZXQgbGlua1R5cGUgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLWxpbmstdHlwZScpO1xuICAgICAgICAgICAgICAgIGxldCBleHRlcm5hbFBsYXRmb3JtID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS1leHRlcm5hbC1wbGF0Zm9ybScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmtUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kYXRhTGF5ZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZXZlbnQnOiAnZXh0ZXJuYWxDbGljaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFnZUdyb3VwaW5nTWFpc29uJzogJ0h1bWFuIFJlc291cmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlua1R5cGUnOiBsaW5rVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYWdlTGFuZ3VhZ2UnIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHRlcm5hbFBsYXRmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kYXRhTGF5ZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZXZlbnQnOiAnZXh0ZXJuYWxDbGljaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFnZUdyb3VwaW5nTWFpc29uJzogJ0h1bWFuIFJlc291cmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXh0ZXJuYWxQbGF0Zm9ybSc6IGV4dGVybmFsUGxhdGZvcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFnZUxhbmd1YWdlJyA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgYnV0dG9uKTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFB1YmxpYyBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBQcml2YXRlIE1ldGhvZHNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9wcml2YXRlRnVuY3Rpb24oKSB7XG5cbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9tb3JlVmFsdWVzVHJpZ2dlckNsaWNrSGFuZGxlcihldmVudCkge1xuXG4gICAgICAgIGxldCBtYXNrID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcubW9yZS12YWx1ZXMtbWFzaycpO1xuXG4gICAgICAgIGlmICggbWFzay5jbGFzc0xpc3QuY29udGFpbnMoJ2hpZGRlbicpICkge1xuICAgICAgICAgICAgYW5pbWUoe1xuICAgICAgICAgICAgICAgIHRhcmdldHMgOiBtYXNrLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uIDogMTAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgOiBbMCwgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcubW9yZS12YWx1ZXMtY29udGVudCcpLmNsaWVudEhlaWdodF0sXG4gICAgICAgICAgICAgICAgZWFzaW5nIDogJ2Vhc2VJbk91dEN1YmljJyxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWFzay5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcudHJpZ2dlci1jb250YWluZXInKS5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZhbHVlc1BhZ2U7XG4iLCJpbXBvcnQgUGFnZSBmcm9tICdhcHAvcGFnZXMvUGFnZS5hYnN0cmFjdCc7XG5cbmltcG9ydCBIb21lUGFnZSBmcm9tICdhcHAvcGFnZXMvSG9tZVBhZ2UnO1xuaW1wb3J0IFZhbHVlc1BhZ2UgZnJvbSAnYXBwL3BhZ2VzL1ZhbHVlc1BhZ2UnO1xuaW1wb3J0IENhcmVlcnNQYWdlIGZyb20gJ2FwcC9wYWdlcy9DYXJlZXJzUGFnZSc7XG5pbXBvcnQgSHVtYW5SZXNvdXJjZXNQYWdlIGZyb20gJ2FwcC9wYWdlcy9IdW1hblJlc291cmNlc1BhZ2UnO1xuaW1wb3J0IENvbnRhY3RQYWdlIGZyb20gJ2FwcC9wYWdlcy9Db250YWN0UGFnZSc7XG5pbXBvcnQgQ2FuZGlkYXRlUGFnZSBmcm9tICdhcHAvcGFnZXMvQ2FuZGlkYXRlUGFnZSc7XG5cbi8vIE1hcCBvZiBwYWdlIElEJ3MgYW5kIHZpZXcgY2xhc3Nlc1xuLy8gVGhlIGtleXMgbXVzdCBtYXRjaCB0aGUgcGFnZSBJRHMgc2VudCBieSB0aGUgc2VydmVyXG5jb25zdCBwYWdlTGlzdCA9IHtcbiAgICAnZGVmYXVsdCcgICAgICAgICAgIDogUGFnZSxcbiAgICAnaG9tZScgICAgICAgICAgICAgIDogSG9tZVBhZ2UsXG4gICAgJ291ci12YWx1ZXMnICAgICAgICA6IFZhbHVlc1BhZ2UsXG4gICAgJ2NhcmVlcnMnICAgICAgICAgICA6IENhcmVlcnNQYWdlLFxuICAgICdodW1hbi1yZXNvdXJjZXMnICAgOiBIdW1hblJlc291cmNlc1BhZ2UsXG4gICAgJ2NvbnRhY3QnICAgICAgICAgICA6IENvbnRhY3RQYWdlLFxuICAgICdjYW5kaWRhdGUnICAgICAgICAgOiBDYW5kaWRhdGVQYWdlLFxuICAgICdsZWdhbHMnICAgICAgICAgICAgOiBQYWdlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYWdlTGlzdDsiLCJpbXBvcnQgQmFzZVZpZXcgZnJvbSAnemltcGxpc3QvZGlzcGxheS9CYXNlVmlldyc7XG5cbmltcG9ydCBMaW5rU2VsZWN0IGZyb20gJ2FwcC9jb21wb25lbnRzL0xpbmtTZWxlY3QnO1xuXG5jbGFzcyBGb290ZXIgZXh0ZW5kcyBCYXNlVmlldyB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuXG4gICAgICAgIHN1cGVyKGVsLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBpbml0IGxpbmsgc2VsZWN0IGZvciBsYW5ndWFnZXNcbiAgICAgICAgdGhpcy5sYW5nU2VsZWN0ID0gbmV3IExpbmtTZWxlY3QoIHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmxhbmctc2VsZWN0JykgKTtcblxuICAgICAgICBpZiAod2luZG93LmRhdGFMYXllcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdEdUTVRyYWNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgX2luaXRHVE1UcmFja2luZygpIHtcbiAgICAgICAgdGhpcy5hZGREb21FdmVudCgnY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuZGF0YUxheWVyLnB1c2goe1xuICAgICAgICAgICAgICAgICdldmVudCc6ICduZXdzbGV0dGVySFInLFxuICAgICAgICAgICAgICAgICdwYWdlR3JvdXBpbmdNYWlzb24nOiAnSHVtYW4gUmVzb3VyY2VzJyxcbiAgICAgICAgICAgICAgICAncGFnZUxhbmd1YWdlJyA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCAnLmd0bScpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBGb290ZXI7XG4iLCIvLyBUaGlyZCBwYXJ0eSBkZXBlbmRlbmNpZXNcbmltcG9ydCBhbmltZSBmcm9tICdhbmltZWpzJztcblxuLy8gWmltcGxpc3QgRGVwZWRlbmNpZXNcbmltcG9ydCBCYXNlVmlldyBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L0Jhc2VWaWV3JztcbmltcG9ydCBXaW5kb3dNYW5hZ2VyIGZyb20gJ3ppbXBsaXN0L3V0aWxzL1dpbmRvd01hbmFnZXInO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L2dldERvY3VtZW50UmVjdCc7XG4vLyBpbXBvcnQgZ2V0U2Nyb2xsUGFyZW50IGZyb20gJ3ppbXBsaXN0L2Rpc3BsYXkvZG9tL2dldFNjcm9sbFBhcmVudCc7XG5cbi8vIExvY2FsIGFwcCBEZXBlbmRlbmNpZXNcbmltcG9ydCBMaW5rU2VsZWN0IGZyb20gJ2FwcC9jb21wb25lbnRzL0xpbmtTZWxlY3QnO1xuXG4vLyBIaWRkZW4gY29uc3RzXG5jb25zdCBTQ1JPTExfU1BFRURfUkFUSU8gPSAwLjc7XG5jb25zdCBIRUlHSFRfSEVBREVSX01FTlUgPSAxMTE7XG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgSGVhZGVyIGV4dGVuZHMgQmFzZVZpZXcge1xuXG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcihlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5sYW5nU2VsZWN0ID0gbmV3IExpbmtTZWxlY3QoIHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmxhbmctc2VsZWN0JykgKTtcblxuICAgICAgICAvLyBEb20gRXZlbnRzXG4gICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLl90cmFuc2l0aW9uRW5kSGFuZGxlcik7XG4gICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ2NsaWNrJywgdGhpcy5fbWVudVRvZ2dsZUNsaWNrSGFuZGxlciwgJy5tZW51LXRvZ2dsZScpOyAvLyBzcGVjaWZ5aW5nIHRoaXMuZWwgcHJldmVudHMgYnViYmxlZCBldmVudHMgZnJvbSB0cmlnZ2VyaW5nIHRoaXNcbiAgICAgICAgdGhpcy5hZGREb21FdmVudCgnY2xpY2snLCB0aGlzLl9tZW51SXRlbUNsaWNrSGFuZGxlciwgJy5tZW51IGEnKTtcbiAgICAgICAgdGhpcy5hZGREb21FdmVudCgnY2xpY2snLCB0aGlzLl9tZW51TG9nb0NsaWNrSGFuZGxlciwgJy5zbWFsbC1sb2dvJyk7XG5cbiAgICAgICAgdGhpcy5saXN0ZW5UbyggV2luZG93TWFuYWdlciwgJ3Njcm9sbCcsIHRoaXMuX3Njcm9sbEhhbmRsZXIpO1xuXG4gICAgICAgIHRoaXMubGFuZ1NlbGVjdC5vbignb3BlbicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdpcy1mYWRlLW91dCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxhbmdTZWxlY3Qub24oJ2Nsb3NlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWZhZGUtb3V0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBQdWJsaWMgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBicmVha3BvaW50Q2hhbmdlZChicmVha3BvaW50LCBwcmV2aW91c0JyZWFrcG9pbnQpIHtcbiAgICAgICAgc3VwZXIuYnJlYWtwb2ludENoYW5nZWQoYnJlYWtwb2ludCwgcHJldmlvdXNCcmVha3BvaW50KTtcblxuICAgICAgICBpZiAoIHRoaXMubWluV2lkdGgoJ20nKSApIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTsgLy8gQ2xvc2UgYmVjYXVzZSB3ZSBkb24ndCBuZWVkIHNjcm9sbCBsb2NrXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIG9wZW4oKSB7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdvcGVuJyk7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdzY3JvbGwtbG9jaycpO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ29wZW4nKTtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3Njcm9sbC1sb2NrJyk7XG4gICAgfVxuXG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHJpdmF0ZSBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgICBfc2Nyb2xsUGFnZShvZmZzZXQsIHNwZWVkKSB7XG5cbiAgICAgICAgY29uc29sZS5sb2coIG9mZnNldCApO1xuXG5cbiAgICAgICAgaWYgKCB0aGlzLm1pbldpZHRoKCdtJykgKSB7XG4gICAgICAgICAgICBhbmltZSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0cyA6IHsgLy8gdGFyZ2V0IGlzIGEgcHJveHkgb2JqZWN0IHRvIHRoZSB3aW5kb3cgbWFuYWdlclxuXG4gICAgICAgICAgICAgICAgICAgIGdldCBzY3JvbGxUb3AoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gV2luZG93TWFuYWdlci5zY3JvbGxQb3NpdGlvbi50b3A7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgc2V0IHNjcm9sbFRvcCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgV2luZG93TWFuYWdlci5zY3JvbGxUbyggcGFyc2VGbG9hdCh2YWx1ZSksIDApOyAvLyBmb3Igc29tZSByZWFzb24gYW5pbWVqcyBzZXRzIGEgc3RyaW5nIGZvciBmbG9hdCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA6IHNwZWVkLFxuICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA6IG9mZnNldCxcbiAgICAgICAgICAgICAgICBlYXNpbmcgOiAnZWFzZUluT3V0Q3ViaWMnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb2Zmc2V0ID0gYW5jaG9yQm94LnRvcCAtIDIwO1xuICAgICAgICAgICAgV2luZG93TWFuYWdlci5zY3JvbGxUbyggb2Zmc2V0ICk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9tZW51VG9nZ2xlQ2xpY2tIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlzT3BlbiA/IHRoaXMuY2xvc2UoKSA6IHRoaXMub3BlbigpO1xuICAgIH1cblxuICAgIF90cmFuc2l0aW9uRW5kSGFuZGxlcihldmVudCkge1xuXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuZWwpIHtcbiAgICAgICAgICAgIFdpbmRvd01hbmFnZXIudHJpZ2dlcigncmVzaXplJyk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIF9tZW51SXRlbUNsaWNrSGFuZGxlcihldmVudCkge1xuXG4gICAgICAgIGlmICggIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpICkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgbGV0IHNlY3Rpb25OYW1lID0gZXZlbnQuZGVsZWdhdGVUYXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJykuc2xpY2UoMSk7XG4gICAgICAgICAgICBsZXQgc2VjdGlvbkFuY2hvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGFbbmFtZT1cIiR7c2VjdGlvbk5hbWV9XCJdYCkucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgbGV0IGFuY2hvckJveCA9IGdldERvY3VtZW50UmVjdCggc2VjdGlvbkFuY2hvciApO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9ICggdGhpcy5taW5XaWR0aCgnbScpICkgP1xuICAgICAgICAgICAgICAgIGFuY2hvckJveC50b3AgLSBIRUlHSFRfSEVBREVSX01FTlUgKyAyIDogLy8gKzIgdG8gZnVkZ2UgdGhlIEdUTSB0cmFja2luZ1xuICAgICAgICAgICAgICAgIGFuY2hvckJveC50b3AgLSAyMjtcblxuICAgICAgICAgICAgbGV0IGRpc3RhbmNlICA9IE1hdGguYWJzKCBXaW5kb3dNYW5hZ2VyLnNjcm9sbFBvc2l0aW9uLnRvcCAtIG9mZnNldCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFBhZ2Uob2Zmc2V0LCBkaXN0YW5jZSAqIFNDUk9MTF9TUEVFRF9SQVRJTyk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgX21lbnVMb2dvQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHRoaXMuX3Njcm9sbFBhZ2UoMCwgV2luZG93TWFuYWdlci5zY3JvbGxQb3NpdGlvbi50b3AgKiBTQ1JPTExfU1BFRURfUkFUSU8pO1xuICAgIH1cblxuICAgIF9zY3JvbGxIYW5kbGVyKCkge1xuXG4gICAgICAgIGlmIChXaW5kb3dNYW5hZ2VyLnNjcm9sbFBvc2l0aW9uLnRvcCA8PSAxMDApIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2VkJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ21lbnUtY29sbGFwc2VkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNlZCcpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdtZW51LWNvbGxhcHNlZCcpO1xuICAgICAgICB9XG5cbiAgICB9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBIZWFkZXI7XG4iLCIvLyBUaGlyZCBwYXJ0eSBkZXBlbmRlbmNpZXNcbi8vIGltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBhbmltZSBmcm9tICdhbmltZWpzJztcblxuLy8gWmltcGxpc3QgRGVwZWRlbmNpZXNcbmltcG9ydCBCYXNlVmlldyBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L0Jhc2VWaWV3JztcbmltcG9ydCBlbXB0eSBmcm9tICd6aW1wbGlzdC9kaXNwbGF5L2RvbS9lbXB0eSc7XG5pbXBvcnQgS2V5Ym9hcmQgZnJvbSAnemltcGxpc3QvaW5wdXQvS2V5Ym9hcmQnO1xuaW1wb3J0IFNwcml0ZUFuaW1hdG9yIGZyb20gJ3ppbXBsaXN0L2Rpc3BsYXkvYW5pbWF0aW9uL1Nwcml0ZUFuaW1hdG9yJztcblxuLy8gTG9jYWwgYXBwIERlcGVuZGVuY2llc1xuXG5cblxuLy8gSGlkZGVuIGNvbnN0c1xuXG4vKipcbiAqXG4gKi9cbmNsYXNzIFBhZ2VEcmF3IGV4dGVuZHMgQmFzZVZpZXcge1xuXG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcihlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5wYWdlQ29udGFpbmVyID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcucGFnZS1kcmF3LW1haW4nKTtcblxuICAgICAgICBsZXQgc3ByaXRlQ2FudmFzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3ByaXRlJyk7XG4gICAgICAgIHRoaXMuc3ByaXRlID0gbmV3IFNwcml0ZUFuaW1hdG9yKHNwcml0ZUNhbnZhcywge2ZwczogMjUsIGF1dG9wbGF5OiBmYWxzZSwgbG9vcDogZmFsc2UsIG51bUZyYW1lczogMzYsIHVybDogc3ByaXRlQ2FudmFzLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKX0pO1xuXG4gICAgICAgIGxldCBsb2FkZXJDYW52YXMgPSBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLWRyYXctbG9hZGVyIGNhbnZhcycpO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBTcHJpdGVBbmltYXRvcihsb2FkZXJDYW52YXMsIHtmcHM6IDI1LCBhdXRvcGxheTogZmFsc2UsIGxvb3A6IHRydWUsIG51bUZyYW1lczogMzYsIHVybDogbG9hZGVyQ2FudmFzLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKX0pO1xuXG4gICAgICAgIHRoaXMuYWRkRG9tRXZlbnQoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLl90cmFuc2l0aW9uRW5kSGFuZGxlcik7IC8vIHNwZWNpZnlpbmcgdGhpcy5lbCBwcmV2ZW50cyBidWJibGVkIGV2ZW50cyBmcm9tIHRyaWdnZXJpbmcgdGhpcyAvLyBUT0RPIHRlc3QgdGhpc1xuXG4gICAgfVxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBQdWJsaWMgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBpbmplY3RQYWdlRWwocGFnZUVsKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhZ2VFbCkge1xuICAgICAgICAgICAgZW1wdHkodGhpcy5wYWdlQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMucGFnZUNvbnRhaW5lci5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZUVsID0gcGFnZUVsO1xuXG4gICAgICAgIGlmICggIXRoaXMucGFnZUNvbnRhaW5lci5jb250YWlucyggcGFnZUVsICkgKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoIHBhZ2VFbCApO1xuXG4gICAgICAgICAgICBwYWdlRWwuc3R5bGUub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgICAgIGFuaW1lKHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiBwYWdlRWwsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gOiAxMDAwLFxuICAgICAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRDdWJpYycsXG4gICAgICAgICAgICAgICAgb3BhY2l0eSA6IFswLCAxXVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG5cblxuICAgIH1cblxuICAgIHByZXBhcmUoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgncGFnZS1kcmF3LW1hc2snKTtcbiAgICAgICAgdGhpcy5sb2FkZXIucGxheSgpO1xuICAgIH1cblxuICAgIG9wZW4oKSB7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdwYWdlLWRyYXctb3BlbicpO1xuXG4gICAgICAgIC8qaWYgKCB0aGlzLm1pbldpZHRoKCdtJykgKSB7XG4gICAgICAgICAgICAvLyBzZXRUaW1lb3V0KCAoKSA9PiB0aGlzLnNwcml0ZS5wbGF5KCksIDgwMCk7XG4gICAgICAgIH1cbiovXG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgncGFnZS1kcmF3LW9wZW4nKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdzY3JvbGwtbG9jaycpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3BhZ2UtZHJhdy1tYXNrJyk7XG5cbiAgICAgICAgdGhpcy5sb2FkZXIucGF1c2UoKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuY3VycmVudEZyYW1lID0gMDtcblxuICAgICAgICB0aGlzLnNwcml0ZS5jdXJyZW50RnJhbWUgPSAwO1xuXG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFByaXZhdGUgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gICAgX3ByaXZhdGVGdW5jdGlvbigpIHtcblxuICAgIH1cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBFdmVudCBIYW5kbGVyc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gICAgX3RyYW5zaXRpb25FbmRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnc2Nyb2xsLWxvY2snKTtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubWluV2lkdGgoJ20nKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGUucGxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW1wdHkodGhpcy5wYWdlQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhZ2VEcmF3O1xuIiwiY29uc3QgRVZFTlRTID0gJ19FVkVOVFMnOyAvLyBEZWZpbmUgYSB1bmlxdWUga2V5IGZvciBhbGwgaW5zdGFuY2VzIHRvIGNyZWF0ZSBldmVudCBoYXNoIG9uXG5jb25zdCBMSVNURU5fVEFSR0VUUyA9ICdfTElTVEVOX1RBUkdFVFMnOyAvLyBEZWZpbmUgYSB1bmlxdWUga2V5IGZvciBhbGwgaW5zdGFuY2VzIHRvIGNyZWF0ZSBhIGxpc3RlbiBhcnJheSBvbjtcblxuLyoqXG4gKiBUaGUgRXZlbnRUYXJnZXQgaXMgYSBjbGFzcyB0aGF0IGFsbG93cyB0aGUgdXNlIG9mIGN1c3RvbSBldmVudHMgaW4gaXQncyBpbnN0YW5jZXMuIGl0IGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICogUHViL1N1YiBwYXR0ZXJuLlxuICpcbiAqIEl0IGlzIGdlbmVyYWxseSBub3QgdXNlZCBkaXJlY3RseSBidXQgaXMgaW5oZXJpdGVkIGZyb20gaW4gb3RoZXIgY2xhc3Nlcy5cbiAqXG4gKiBJbXBvcnRhbnQgOiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgbWlzdGFrZW4gd2l0aCB0aGUgbmF0aXZlIEV2ZW50VGFyZ2V0IGNsYXNzIEVsZW1lbnRzLCBXaW5kb3cgYW5kIERvY3VtZW50IGluaGVyaXQgZnJvbS5cbiAqXG4gKi9cbmNsYXNzIEV2ZW50VGFyZ2V0IHtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgTVVTVCBiZSBjYWxsZWQgYnkgc3ViLWNsYXNzZXMgdG8gaW5zdGFudGlhdGUgdGhlIGNvcnJlY3QgcHJvcGVydGllcyB3aGVyZSBldmVudHMgYXJlIHN0b3JlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7e319XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzW0VWRU5UU10gPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpc1tMSVNURU5fVEFSR0VUU10gPSBbXTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LiBBIGN1c3RvbSBodW1hbiByZWFkYWJsZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuIE5vIHNpZ25hdHVyZSBpcyBwcm92aWRlZCwgaXQgaXMgdXAgdG8gdGhlIGRldmVsb3BlciB0byBkZXRlcm1pbmUgd2hhdCBpcyBwYXNzZWQgdG8gdGhlIGxpc3RlbmVyIGF0IHRyaWdnZXIgdGltZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD10aGlzXSAtIFRoZSBvYmplY3QgdGhlIGxpc3RlbmVyIHdpbGwgY2FsbGVkIG9uLiBEZWZhdWx0cyB0byBgdGhpc2AgYW5kIGNhbiBiZSBjaGFuZ2VkIGlmIGV2ZW50IGRlbGVnYXRpb24gaXMgbmVlZGVkLlxuICAgICAqL1xuICAgIG9uKHR5cGUsIGhhbmRsZXIsIGNvbnRleHQgPSB0aGlzKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciB0aGlzIHR5cGUgaXMgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZiAoICF0aGlzLmhhc0xpc3RlbmVycyh0eXBlKSApIHtcbiAgICAgICAgICAgICAgICB0aGlzW0VWRU5UU11bdHlwZV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpc1tFVkVOVFNdW3R5cGVdLnB1c2goIHtoYW5kbGVyOiBoYW5kbGVyLCBjb250ZXh0IDogY29udGV4dH0gKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyBBc3N1bWUgd2UgaGF2ZSBiZWVuIHBhc3NlZCBhbiBvYmplY3Qgb2YgZXZlbnRzLlxuXG4gICAgICAgICAgICAvLyBsb29wIG92ZXIgaGFzaCB1c2luZyBrZXkgYXMgdHlwZSwgYW5kIHZhbHVlIGFzIGhhbmRsZXJcbiAgICAgICAgICAgIGZvciAoIGNvbnN0IGtleSBpbiB0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0eXBlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub24oa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIgdGhhdCB3aWxsIHRyaWdnZXIgb25seSBvbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuIEEgY3VzdG9tIGh1bWFuIHJlYWRhYmxlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC4gTm8gc2lnbmF0dXJlIGlzIHByb3ZpZGVkLCBpdCBpcyB1cCB0byB0aGUgZGV2ZWxvcGVyIHRvIGRldGVybWluZSB3aGF0IGlzIHBhc3NlZCB0byB0aGUgbGlzdGVuZXIgYXQgdHJpZ2dlciB0aW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXRoaXNdIC0gVGhlIG9iamVjdCB0aGUgbGlzdGVuZXIgd2lsbCBjYWxsZWQgb24uIERlZmF1bHRzIHRvIGB0aGlzYCBhbmQgY2FuIGJlIGNoYW5nZWQgaWYgZXZlbnQgZGVsZWdhdGlvbiBpcyBuZWVkZWQuXG4gICAgICovXG4gICAgb25jZSh0eXBlLCBoYW5kbGVyLCBjb250ZXh0ID0gdGhpcykge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzdXJyb2dhdGUgaGFuZGxlciB0aGF0IHdpbGwgZXhlY3V0ZSBvbmNlIGFuIHJlbW92ZSBldmVudFxuICAgICAgICBjb25zdCBvbmNlSGFuZGxlciA9ICguLi5ldmVudERhdGEpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKHR5cGUsIG9uY2VIYW5kbGVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZWdpc3RlciBvdXIgc3Vycm9nYXRlIGV2ZW50XG4gICAgICAgIHRoaXMub24odHlwZSwgb25jZUhhbmRsZXIsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBldmVudCBoYW5kbGVyLCBlaXRoZXIgb2Ygb25lIHR5cGUsIG9yIGp1c3Qgb25lIGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuIEEgY3VzdG9tIGh1bWFuIHJlYWRhYmxlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBUaGUgZXZlbnQgaGFuZGxlciB0byBiZSByZW1vdmVkLiBJZiB1bnNwZWNpZmlmZWQsIGFsbCBoYW5kbGVycyBvZiB0aGUgc3VwcGxpZWQgdHlwZSBhcmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBvZmYodHlwZSwgaGFuZGxlcikge1xuXG4gICAgICAgIGlmICggdGhpcy5oYXNMaXN0ZW5lcnModHlwZSkgKSB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRoaXNbRVZFTlRTXVt0eXBlXSA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpc3RlcmVkSGFuZGxlciA9IHRoaXNbRVZFTlRTXVt0eXBlXS5maW5kKCAodGVzdEhhbmRsZXIpID0+IHRlc3RIYW5kbGVyLmhhbmRsZXIgPT09IGhhbmRsZXIgKTtcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0ZXJlZEhhbmRsZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbRVZFTlRTXVt0eXBlXS5zcGxpY2UoIHRoaXNbRVZFTlRTXVt0eXBlXS5sYXN0SW5kZXhPZihyZWdpc3RlcmVkSGFuZGxlcikgLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBhbGxvdyBFdmVudFRhcmdldHMgdG8gbGlzdGVuIHRvIG90aGVyIEV2ZW50VGFyZ2V0J3MgZXZlbnRzIGVhc2lseVxuICAgICAqXG4gICAgICogQFRPRE8gaGFuZGxlIG9iamVjdHMgbGlrZSBpbiBgb25gXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXQgLSBUaGUgaW5zdGFuY2Ugb2YgRXZlbnRUYXJnZXQgdG8gbGlzdGVuIHRvIGV2ZW50cyBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LiBBIGN1c3RvbSBodW1hbiByZWFkYWJsZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuIE5vIHNpZ25hdHVyZSBpcyBwcm92aWRlZCwgaXQgaXMgdXAgdG8gdGhlIGRldmVsb3BlciB0byBkZXRlcm1pbmUgd2hhdCBpcyBwYXNzZWQgdG8gdGhlIGxpc3RlbmVyIGF0IHRyaWdnZXIgdGltZVxuICAgICAqL1xuICAgIGxpc3RlblRvKHRhcmdldCwgdHlwZSwgaGFuZGxlcikge1xuXG4gICAgICAgIGlmICggISh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gbGlzdGVuVG8gYW4gb2JqZWN0IHRoYXQgZG9lcyBub3QgaW5oZXJpdCBmcm9tIEV2ZW50VGFyZ2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgYXJlIGxpc3RlbmluZyB0byB0aGlzIG9iamVjdCB5ZXRcbiAgICAgICAgbGV0IHRhcmdldExpc3RlbmVycyA9IHRoaXNbTElTVEVOX1RBUkdFVFNdLmZpbmQoICh0ZXN0VGFyZ2V0KSA9PiB0ZXN0VGFyZ2V0LnRhcmdldCA9PT0gdGFyZ2V0KTtcblxuICAgICAgICAvLyBJZiB0YXJnZXQgbGlzdGVuZXJzIGRvZXNuJ3QgZXhpc3QgeWV0LCBhZGQgaXQgaGVyZVxuICAgICAgICBpZiAoICF0YXJnZXRMaXN0ZW5lcnMgKSB7XG4gICAgICAgICAgICB0YXJnZXRMaXN0ZW5lcnMgPSB7dGFyZ2V0IDogdGFyZ2V0LCBsaXN0ZW5lcnMgOiB7fSB9O1xuICAgICAgICAgICAgdGhpc1tMSVNURU5fVEFSR0VUU10ucHVzaCggdGFyZ2V0TGlzdGVuZXJzICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgYW4gYXJyYXkgZm9yIHRoaXMgdHlwZSBvZiBldmVudCBpcyBhdmFpbGFibGVcbiAgICAgICAgdGFyZ2V0TGlzdGVuZXJzLmxpc3RlbmVyc1t0eXBlXSA9IHRhcmdldExpc3RlbmVycy5saXN0ZW5lcnNbdHlwZV0gfHwgW107XG5cbiAgICAgICAgLy8gQWRkIHRvIHJlZ2lzdGVyIG9mIGZ1bmN0aW9uc1xuICAgICAgICB0YXJnZXRMaXN0ZW5lcnMubGlzdGVuZXJzW3R5cGVdLnB1c2goIGhhbmRsZXIgKTtcblxuICAgICAgICAvLyBiaW5kIGV2ZW50IG5vcm1hbGx5XG4gICAgICAgIHRhcmdldC5vbih0eXBlLCBoYW5kbGVyLCB0aGlzKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgbGlzdGVuaW5nIGZvciBldmVudHMgb24gYW5vdGhlciBFdmVudFRhcmdldFxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldCAtIFRoZSBpbnN0YW5jZSBvZiBFdmVudFRhcmdldCB0byBzdG9wIHJlY2VpdmluZyBldmVudHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC4gQSBjdXN0b20gaHVtYW4gcmVhZGFibGUgc3RyaW5nLlxuICAgICAqL1xuICAgIHN0b3BMaXN0ZW5pbmcodGFyZ2V0LCB0eXBlKSB7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIGFyZSBsaXN0ZW5pbmcgdG8gdGhpcyBvYmplY3QgeWV0XG4gICAgICAgIC8vIHZhciB0YXJnZXRMaXN0ZW5lcnMgPSBfLmZpbmQodGhpc1tMSVNURU5fVEFSR0VUU10sIHt0YXJnZXQgOiB0YXJnZXQgfSk7XG4gICAgICAgIGNvbnN0IHRhcmdldExpc3RlbmVycyA9IHRoaXNbTElTVEVOX1RBUkdFVFNdLmZpbmQoICh0ZXN0VGFyZ2V0KSA9PiB0ZXN0VGFyZ2V0ID09PSB0YXJnZXQpO1xuXG4gICAgICAgIC8vIElmIGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBmb3IgdGhpcyB0YXJnZXRcbiAgICAgICAgaWYgKCB0YXJnZXRMaXN0ZW5lcnMgKSB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXRMaXN0ZW5lcnMubGlzdGVuZXJzW3R5cGVdLmZvckVhY2goIGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5vZmYodHlwZSwgaGFuZGxlcilcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IHR5cGVJdGVyIG9mIE9iamVjdC5rZXlzKHRhcmdldExpc3RlbmVycy5saXN0ZW5lcnMpICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldExpc3RlbmVycy5saXN0ZW5lcnNbdHlwZUl0ZXJdLmZvckVhY2goIGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQub2ZmKHR5cGVJdGVyLCBoYW5kbGVyKVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGlzIG9iamVjdCBoYXMgZXZlbnRzIHJlZ2lzdGVyZWQgb2YgYSBjZXJ0YWluIHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEV2ZW50IHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoZSBFdmVudFRhcmdldCBoYXMgbGlzdGVuZXJzIGZvciB0aGlzIHR5cGUgb2YgZXZlbnRcbiAgICAgKi9cbiAgICBoYXNMaXN0ZW5lcnModHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXNbRVZFTlRTXVt0eXBlXSAhPT0gJ3VuZGVmaW5lZCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIHRoaXMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZSB3aG8ncyBsaXN0ZW5lcnMgd2lsbCBiZSB0cmlnZ2VyZWRcbiAgICAgKiBAcGFyYW0gey4uLip9IGV2ZW50UGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBsaXN0ZW5pbmcgb2JqZWN0cy4gQW55IG51bWJlciBjYW4gYmUgcGFzc2VkIGJ1dCBpdCBpcyByZWNvbWVuZGVkIHRvIG9ubHkgcGFzcyBhIHNpbmdsZSBldmVudCBvYmplY3Qgb24gd2hpY2ggeW91IG1heSBhdHRhY2ggbXVsdGlwbGUgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICB0cmlnZ2VyKHR5cGUsIC4uLmV2ZW50UGFyYW1zKSB7XG5cbiAgICAgICAgLy8gaWYgYW4gZXZlbnQgb2YgdGhpcyB0eXBlIGhhcyBiZWVuIHJlZ2lzdGVyZWQgb24gdGhpcyBldmVudFxuICAgICAgICBpZiAoIHRoaXMuaGFzTGlzdGVuZXJzKHR5cGUpICkge1xuXG4gICAgICAgICAgICAvLyBsb29wIG92ZXIgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQgdHlwZVxuICAgICAgICAgICAgLy8gbm90ZSA6IGNvdWxkIGhhdmUgdXNlZCBmb3Igb2YsIGJ1dCBjb3VsZCBuZWVkIGEgU3ltYm9sIHBvbHlmaWxsIHdoaWNoIGlzIHRvbyBtdWNoIGNvZGUuXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXNbRVZFTlRTXVt0eXBlXTtcbiAgICAgICAgICAgIGZvciAoIGNvbnN0IGV2ZW50S2V5IGluIGhhbmRsZXJzICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBoYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShldmVudEtleSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBldmVudCA9IHRoaXNbRVZFTlRTXVt0eXBlXVtldmVudEtleV07XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuaGFuZGxlci5hcHBseShldmVudC5jb250ZXh0LCBldmVudFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBFdmVudFRhcmdldDsiLCIvLyBUaGlyZCBwYXJ0eSBkZXBlbmRlbmNpZXNcbmltcG9ydCBpc0VsZW1lbnQgZnJvbSAnbG9kYXNoL2lzRWxlbWVudCc7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSAnbG9kYXNoL2lzU3RyaW5nJztcbmltcG9ydCBpc1VuZGVmaW5lZCBmcm9tICdsb2Rhc2gvaXNVbmRlZmluZWQnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnbG9kYXNoL2lzRnVuY3Rpb24nO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAnbG9kYXNoL2lzRXF1YWwnO1xuaW1wb3J0IGZpbHRlciBmcm9tICdsb2Rhc2gvZmlsdGVyJztcbmltcG9ydCBlYWNoIGZyb20gJ2xvZGFzaC9lYWNoJztcbmltcG9ydCBjbG9uZSBmcm9tICdsb2Rhc2gvY2xvbmUnO1xuaW1wb3J0IGluY2x1ZGVzIGZyb20gJ2xvZGFzaC9pbmNsdWRlcyc7XG5pbXBvcnQgZmluZExhc3QgZnJvbSAnbG9kYXNoL2ZpbmRMYXN0JztcblxuXG4vLyBaaW1wbGUgZGVwZW5kZW5jaWVzXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi4vY29yZS9FdmVudFRhcmdldCc7XG5pbXBvcnQgV2luZG93TWFuYWdlciBmcm9tICcuLi91dGlscy9XaW5kb3dNYW5hZ2VyJztcblxuLyoqXG4gKiBCYXNlVmlldyBpcyB0aGUgYmFzZSBjbGFzcyBmb3Igb3JnYW5pemluZyB0aGUgRE9NLiBJdCBleHRlbmRzIEV2ZW50VGFyZ2V0IHRvIGFsbG93IGV2ZW50IGJhc2VkIGNvbW11bmljYXRpb24gYmV0d2VlblxuICogVmlld3MgYW5kIHRoZWlyIHBhcmVudHMgb3Igb3RoZXIgcGFydHMgb2YgdGhlIGFwcGxpY2F0aW9uIHRoYXQgYWxzbyBpbmhlcml0IGZyb20gRXZlbnRUYXJnZXQuXG4gKlxuICogQmFzZVZpZXcgZW5hYmxlcyBlYXNpbHkgYWRkaW5nIERPTSBFdmVudHMgYnkgZG9pbmcgdGhlIGJvb2sga2VlcGluZyBhbmQgYWxsb3dpbmcgZm9yIGV2ZW50IGRlbGVnYXRpb24uXG4gKi9cbmNsYXNzIEJhc2VWaWV3IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gVGhlIEVsZW1lbnQgdGhpcyB2aWV3IGlzIHJlc3BvbnNpYmxlIGZvci4gU2F2ZWQgdG8gdGhpcy5lbCwgYSBWaWV3IGlzIGFsd2F5cyByZXNwb25zaWJsZVxuICAgICAqICAgICAgRm9yIGEgc2luZ2xlIHJvb3QgZWxlbWVudC4gVGhlIHZpZXcgY2FuIHRoZW4gc3BsaXQgdXAgaXQncyBjb250YWluZWQgZWxlbWVudHMgd2l0aCBzdWJ2aWV3c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQW4gb2JqZWN0IG9mIG9wdGlvbnMgZm9yIHRoZSB2aWV3XG4gICAgICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5icmVha3BvaW50cyAtIEFuIGFycmF5IG9mIGJyZWFrcG9pbnQgb2JqZWN0cyB0aGUgdmlldyB1c2VzLiBJZiB0aGlzIG9wdGlvbnMgaXMgc3BlY2lmaWVkLFxuICAgICAqICAgICAgdGhlIGBicmVha3BvaW50Q2hhbmdlZGAgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGNhbGxlZCB3aXRoIGJyZWFrcG9pbnRzIHNwZWNpZmllZCBoZXJlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiAgICAgIGZvciBldmVyeSBicmVha3BvaW50IGNoYW5nZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBDaGVjayBzdXBwbGllZCBlbCBwYXJhbWV0ZXJcbiAgICAgICAgaWYgKCAhZWwgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSByb290IGVsZW1lbnQgZm9yIHRoZSBWaWV3Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoICFpc0VsZW1lbnQoZWwpICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCBgZWxgIGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgRE9NRWxlbWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZSBzdXBwbGllZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIC8vIEJyZWFrcG9pbnQgaGFuZGxpbmdcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3BvaW50cykgeyAvLyByZWFjdCBvbmx5IGJyZWFrcG9pbnRzIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9uc1xuICAgICAgICAgICAgdGhpcy5icmVha3BvaW50cyA9IGZpbHRlciggV2luZG93TWFuYWdlci5icmVha3BvaW50cywgKGJwKSA9PiBpbmNsdWRlcyh0aGlzLm9wdGlvbnMuYnJlYWtwb2ludHMsIGJwLm5hbWUpICk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gdXNlIGFsbCBicmVha3BvaW50c1xuICAgICAgICAgICAgdGhpcy5icmVha3BvaW50cyA9IGNsb25lKCBXaW5kb3dNYW5hZ2VyLmJyZWFrcG9pbnRzICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbiBmaXJzdCBpbnN0YW50aWF0aW9uIG9mIGFueSBCYXNlVmlldywgYmluZCB0aGUgV2luZG93TWFuYWdlci5icmVha3BvaW50IGhhbmRsZXJcbiAgICAgICAgaWYgKCAhQmFzZVZpZXcuaW5zdGFuY2VzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIFdpbmRvd01hbmFnZXIub24oJ2JyZWFrcG9pbnQnLCBicmVha3BvaW50SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIG5ld2x5IGNyZWF0ZWQgaW5zdGFuY2UgdG8gc3RhdGljIGFycmF5LlxuICAgICAgICBCYXNlVmlldy5pbnN0YW5jZXMucHVzaCggdGhpcyApO1xuXG4gICAgICAgIC8vIGRldGVjdCBmaXJzdCBicmVha3BvaW50XG4gICAgICAgIHRoaXMuY3VycmVudEJyZWFrcG9pbnQgPSBmaW5kTGFzdCh0aGlzLmJyZWFrcG9pbnRzLCAoYnApID0+IFdpbmRvd01hbmFnZXIud2lkdGggPj0gYnAudmFsdWUgKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGJyZWFrcG9pbnQgaXMgY2hhbmdlZFxuICAgICAqL1xuICAgIGJyZWFrcG9pbnRDaGFuZ2VkKCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEJpbmQgYSBET01FdmVudCB0byB0aGUgdmlldywgb3B0aW9uYWxseSBmaWx0ZXJlZCBvbiB0aGUgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIEV2ZW50IHR5cG9lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbihldmVudCl9IGxpc3RlbmVyIC0gRXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHNjb3BlZCB0byB0aGlzIHZpZXdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBbc2VsZWN0b3I9dGhpcy5lbF0gLSBJZiBzZWxlY3RvciBpcyBhIFN0cmluZywgdGhlIHN0cmluZyB3aWxsIGJlIHVzZWQgdG8gdGVzdCBtYXRjaGluZyB1c2luZ1xuICAgICAqICAgICAgZGVsZWdhdGVkIGV2ZW50cyB0byBgdGhpcy5lbGAuIElmIGl0J3MgYW4gRWxlbWVudCB0aGVuIGJpbmQgZXZlbnQgZGlyZWN0bHkgdG8gdGhhdCBlbGVtZW50LlxuICAgICAqICAgICAgQmluZGluZyBkaXJlY3RseSB0byBhbiBlbGVtZW50IGlzIHVzZWZ1bGwgZm9yIGV2ZW50cyB0aGF0IGRvbid0IGJ1YmJsZS4gKGZvcm0gc3VibWl0LCBmb3IgZXhhbXBsZSlcbiAgICAgKi9cbiAgICBhZGREb21FdmVudCh0eXBlLCBsaXN0ZW5lciwgc2VsZWN0b3IgPSBudWxsKSB7XG5cbiAgICAgICAgLy8gaW5pdCBkb21FdmVudHMgcmVnaXN0cnkgaWYgbm90IHByZXNlbnRcbiAgICAgICAgdGhpcy5fZG9tRXZlbnRzID0gdGhpcy5fZG9tRXZlbnRzIHx8IHt9O1xuXG4gICAgICAgIC8vIGluaXQgcmVnaXN0cnkgZm9yIHRoaXMgdHlwZVxuICAgICAgICB0aGlzLl9kb21FdmVudHNbdHlwZV0gPSB0aGlzLl9kb21FdmVudHNbdHlwZV0gfHwgW107XG5cbiAgICAgICAgLy8gQ2hlY2sgc2VsZWN0b3IgaXMgZWl0aGVyIGEgdmFsaWQgc3RyaW5nIG9yIGFuIGVsZW1lbnRcbiAgICAgICAgaWYgKCBzZWxlY3RvciAmJiAhKCAoaXNTdHJpbmcoc2VsZWN0b3IpICYmIHNlbGVjdG9yICE9PSAnYWxsJykgfHwgaXNFbGVtZW50KHNlbGVjdG9yKSApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3IgcGFzc2VkIHRvIGFkZERvbUV2ZW50LiBNdXN0IGJlIFN0cmluZyBvciBET01FbGVtZW50LiBDYW4gbm90IGJlIFwiYWxsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIHdlIGhhdmUgYSBmdW5jdGlvbiB0byBiaW5kIHRvLlxuICAgICAgICBpZiAoICFpc0Z1bmN0aW9uKGxpc3RlbmVyKSApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gc3BlY2lmaWVkIGZvciBhZGREb21FdmVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHNlbGVjdG9yIGlzIGFuIGVsZW1lbnQsIGFkZCBldmVudCB0byBpdCwgb3RoZXJ3aXNlIHVzZSB0aGlzLmVsIGZvciBldmVudCBkZWxlZ2F0aW9uXG4gICAgICAgIGxldCB0YXJnZXQgPSBpc0VsZW1lbnQoc2VsZWN0b3IpID8gc2VsZWN0b3IgOiB0aGlzLmVsO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgc2F2ZWRcbiAgICAgICAgbGV0IGludGVybmFsTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcblxuICAgICAgICAgICAgLy8gaW5pdCBhIGZsYWcgdG8gaW5kaWNhdGUgaWYgYSBzZWxlY3RvciBoYXMgYmVlbiBmb3VuZFxuICAgICAgICAgICAgbGV0IGluU2VsZWN0b3IgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGVsZW1lbnQgaXRlcmF0b3IgdGhhdCB3aWxsIGNsaW1iIHVwIHRoZSBET00uXG4gICAgICAgICAgICBsZXQgaXRlckVsO1xuXG4gICAgICAgICAgICBpZiAoICFzZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICBpblNlbGVjdG9yID0gdHJ1ZTsgLy8gaWYgbm8gc2VsZWN0b3Igc3BlY2lmaWVkLCBhbHdheXMgdHJpZ2dlclxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGl0ZXJFbCA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhzZWxlY3RvcikpIHtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaXRlckVsICE9PSB0aGlzLmVsKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gY2xpY2tpbmcgb24gU1ZHIDx1c2U+IHRhZ3MgaW4gSUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZXZlbnQudGFyZ2V0IGlzIGFjdHVhbGx5IHRoZSBkZWNsYXJhdGlvbiBlbGVtZW50LCBhbmQgbm90IHRoZSBhY3R1YWwgPHVzZT4gdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIHN3aXRjaCByZWZlcmVuY2UgdG8gdGhlIGFjdHVhbCA8dXNlIC8+IHRhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnRcIiBpbiBpdGVyRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyRWwgPSBpdGVyRWwuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5tYXRjaGVzIGRvZXMndCBleGlzdCBvbiBTVkcgZWxlbWVudHMgaW4gb2xkIElFXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICdtYXRjaGVzJyBpbiBpdGVyRWwgJiYgaXRlckVsLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5TZWxlY3RvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJFbCA9IGl0ZXJFbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzRWxlbWVudChzZWxlY3RvcikpIHsgLy8gSWYgc2VsZWN0b3IgaXMgYW4gRWxlbWVudCwgdGhlbiBpdCBpcyBvdXIgdGFyZ2V0IGFuZCB3aWxsIGFsd2F5cyBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBpdGVyRWwgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgaW5TZWxlY3RvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5TZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBmb3VuZCBzZWxlY3RvciB0byBldmVudCBhbmQgdHJhbnNwYXJlbnRseSB0cmlnZ2VyIG91ciBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gaXRlckVsO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIFtldmVudF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTmF0aXZlIGRvbSBldmVudFxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBpbnRlcm5hbExpc3RlbmVyKTtcblxuICAgICAgICAvLyBTYXZlIGV2ZW50IG9iamVjdFxuICAgICAgICB0aGlzLl9kb21FdmVudHNbdHlwZV0ucHVzaCh7dGFyZ2V0IDogdGFyZ2V0LCBsaXN0ZW5lcjogaW50ZXJuYWxMaXN0ZW5lcn0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBET00gZXZlbnQgZnJvbSB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gVGhlIGVsZW1lbnQgdG8gcmVtb3ZlIGV2ZW50cyBmcm9tXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlPSdhbGwnXSAtIFRoZSBET00gZXZlbnQgVHlwZS4gU3BlY2lhbCBrZXl3b3JkICdhbGwnIHJlbW92ZXMgYWxsIGV2ZW50IHR5cGVzXG4gICAgICovXG4gICAgcmVtb3ZlRG9tRXZlbnQodGFyZ2V0LCB0eXBlID0gJ2FsbCcpIHtcblxuICAgICAgICBpZiAodGhpcy5fZG9tRXZlbnRzKSB7XG5cbiAgICAgICAgICAgIGxldCBldmVudHM7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodHlwZSkgfHwgdHlwZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICBldmVudHMgPSB0aGlzLl9kb21FdmVudHM7IC8vIHJlbW92ZSBhbGwgZXZlbnRzIGlmIG5vIHR5cGUgaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IHt9O1xuICAgICAgICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IHRoaXMuX2RvbUV2ZW50c1t0eXBlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggZXZlbnQgdHlwZVxuICAgICAgICAgICAgZWFjaChldmVudHMsIChldmVudExpc3RlbmVycywgaXRlclR5cGUpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gbW9kaWZ5IHRoZSBhcnJheSBpbiBwbGFjZSBkdXJpbmcgdGhlIGxvb3AsIHNvIHNhdmUgcmVtb3ZlZCBldmVudCBsaXN0ZW5lcnMgdG8gYW4gYXJyYXlcbiAgICAgICAgICAgICAgICBsZXQgcmVtb3ZlZCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9vcCBvdmVyIGxpc3RlbmVyIG9iamVjdHMgYW5kIHJlbW92ZVxuICAgICAgICAgICAgICAgIGVhY2goZXZlbnRMaXN0ZW5lcnMsIChsaXN0ZW5lck9iaiwgaSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXRhcmdldCB8fCBsaXN0ZW5lck9iai50YXJnZXQgPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lck9iai50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihpdGVyVHlwZSwgbGlzdGVuZXJPYmoubGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKCBpICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG9mIGxpc3RlbmVyIG9iamVjdHMgbm93XG4gICAgICAgICAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudExpc3RlbmVycy5zcGxpY2UoaSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWxldGUgdGhlIG9iamVjdCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBsaXN0ZW5lcnMgZm9yIHRoaXMgdHlwZVxuICAgICAgICAgICAgICAgIGlmICggIWV2ZW50TGlzdGVuZXJzIHx8IGV2ZW50TGlzdGVuZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9kb21FdmVudHNbaXRlclR5cGVdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgRE9NIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVtb3ZlIHRoZSBWaWV3IGVsZW1lbnQgZnJvbSB0aGUgRE9NLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgd2hlbiB3ZSB3YW50IHRvXG4gICAgICogcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTSBidXQgd2FudCB0aGUgdmlldyB0byBzdGF5IGluIG1lbW9yeVxuICAgICAqL1xuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVEb21FdmVudCgpO1xuICAgICAgICAvLyBNaWdodCBub3Qgc3RpbGwgYmUgYXR0YWNoZWQgdG8gRE9NXG4gICAgICAgIGlmICh0aGlzLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgRE9NIEVsZW1lbnQgYW5kIERPTSBldmVudHMuIFVuYmluZHMgb3RoZXIgRXZlbnRzLlxuICAgICAqIENhbGwgdGhpcyB0byBjbGVhbiB1cCB0aGUgdmlldyBiZWZvcmUgZGUtcmVmZXJlbmNpbmcgaXQuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gaW50ZXJuYWwgbGlzdCBvZiBpbnN0YW5jZXNcbiAgICAgICAgQmFzZVZpZXcuaW5zdGFuY2VzLnNwbGljZSggQmFzZVZpZXcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyksIDEpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHVtbXkgZnVuY3Rpb24gdG8gaW1wbGVtZW50IHJlc2l6aW5nXG4gICAgICovXG4gICAgcmVzaXplKCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdCB0byBzZWUgaWYgdGhlIHZpZXdwb3J0IGlzIGN1cnJlbnRseSBhdCBhIGNlcnRhaW4gYnJlYWtwb2ludFxuICAgICAqXG4gICAgICogUHJveGllcyBXaW5kb3dNYW5hZ2VyLm1pbldpZHRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJlYWtwb2ludCB7TnVtYmVyfFN0cmluZ3xPYmplY3R9IGEgYnJlYWtwb2ludCBuYW1lLCBvYmplY3Qgb3IgbnVtZXJpY2FsIHZhbHVlLiBTZWUgV2luZG93TWFuYWdlci5taW5XaWR0aCBmb3IgbW9yZSBpbmZvXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgbWluV2lkdGgoYnJlYWtwb2ludCkge1xuICAgICAgICByZXR1cm4gV2luZG93TWFuYWdlci5taW5XaWR0aCggYnJlYWtwb2ludCApO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFN0YXRpYyBhcnJheSBvZiBpbnN0YW5jZXNcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7QXJyYXk8QmFzZVZpZXc+fVxuICovXG5CYXNlVmlldy5pbnN0YW5jZXMgPSBbXTtcblxuLyoqXG4gKiBTaW5nbGUgZXZlbnQgaGFuZGxlciBmcm9tIFdpbmRvd01hbmFnZXIgYnJlYWtwb2ludCBldmVudC4gSGFuZGxlcyBjYWxsaW5nIG9mIGJyZWFrcG9pbnRDaGFuZ2VkIG9uIGVhY2ggaW5zdGFuY2UgaWYgYXBwbGljYWJsZVxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBldmVudFxuICovXG5mdW5jdGlvbiBicmVha3BvaW50SGFuZGxlcihldmVudCkge1xuICAgIGZvciAobGV0IGluc3RhbmNlIG9mIEJhc2VWaWV3Lmluc3RhbmNlcykge1xuICAgICAgICAvLyBnZXQgdGhlIG1heCBicmVha3BvaW50IHRoaXMgaW5zdGFuY2UgaGFuZGxlc1xuICAgICAgICBsZXQgdXNlZEJyZWFrcG9pbnQgPSBmaW5kTGFzdChpbnN0YW5jZS5icmVha3BvaW50cywgKGJwKSA9PiBldmVudC5icmVha3BvaW50LnZhbHVlID49IGJwLnZhbHVlICk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaXQncyBub3QgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCBhbmQgaW52b2tlIGJyZWFrcG9pbnRDaGFuZ2VkIG1ldGhvZFxuICAgICAgICBpZiAoICFpc0VxdWFsKHVzZWRCcmVha3BvaW50LCBpbnN0YW5jZS5jdXJyZW50QnJlYWtwb2ludCkgKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jdXJyZW50QnJlYWtwb2ludCA9IHVzZWRCcmVha3BvaW50O1xuICAgICAgICAgICAgaW5zdGFuY2UuYnJlYWtwb2ludENoYW5nZWQoIHVzZWRCcmVha3BvaW50LCBldmVudC5wcmV2aW91cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVZpZXc7IiwiLy8gVGhpcmQgcGFydHkgZGVwZW5kZW5jaWVzXG5pbXBvcnQgaW5jbHVkZXMgZnJvbSAnbG9kYXNoL2luY2x1ZGVzJztcblxuLy8gWmltcGxlIERlcGVkZW5jaWVzXG5pbXBvcnQgQmFzZVZpZXcgZnJvbSAnLi9CYXNlVmlldyc7XG5cblxuLyoqXG4gKiBBIHZpZXcgdGhhdCBjYW4gY29udGFpbiBvdGhlciB2aWV3cy5cbiAqIEF1dG9tYXRpY2FsbHkgY2FsbCByZXNpemUvYnJlYWtwb2ludENoYW5nZWQvZGVzdHJveSBvbiBjaGlsZHJlbi5cbiAqL1xuY2xhc3MgQ29udGFpbmVyVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcblxuICAgIC8qKlxuICAgICAqIFNlZSBzdXBlciBkZWNsYXJhdGlvbi4gVGhpcyB2aWV3IGFsc28gaW5zdGFudGlhdGVzIGEgc3VidmlldyBhcnJheVxuICAgICAqIEBwYXJhbSBlbFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcihlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGNvbnRhaW5lZCBzdWIgdmlld3NcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3ViVmlld3MgPSBbXTtcblxuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHVibGljIE1ldGhvZHNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG5cbiAgICAgICAgLy8gZGVzdHJveSBhbmQgdW5yZWdpc3RlciBhbGwgc3ViIHZpZXdzXG4gICAgICAgIHRoaXMuX3N1YlZpZXdzLmZvckVhY2goIHZpZXcgPT4ge1xuICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl91bnJlZ2lzdGVyU3ViVmlldyh2aWV3KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWZ0ZXIgdGhpcyB2aWV3IGlzIGRvbmUsIGNhbGwgc3VwZXIgZGVzdHJveWVyIHRvIGRvIHRoZSByZWFsIGNsZWFudXBcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCByZXNpemUgZm9yIGFsbCB0aGUgc3ViLXZpZXdzXG4gICAgICovXG4gICAgcmVzaXplKCkge1xuICAgICAgICB0aGlzLl9zdWJWaWV3cy5mb3JFYWNoKCAodmlldykgPT4gdmlldy5yZXNpemUoKSApO1xuICAgICAgICBzdXBlci5yZXNpemUoKTtcblxuICAgIH1cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBQcml2YXRlIE1ldGhvZHNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jhc2VWaWV3fSB2aWV3IC0gdGhlIHN1Yi12aWV3IHRvIHJlZ2lzdGVyIHdpdGggdGhpcyBhcyBhIHBhcmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyU3ViVmlldyh2aWV3ICkge1xuXG4gICAgICAgIGlmICggISh2aWV3IGluc3RhbmNlb2YgQmFzZVZpZXcpICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIGFkZCBhIHN1Yi12aWV3IHRvIHRoZSBjb250YWluZXIgdGhhdCBkb2VzIG5vdCBpbmhlcml0IGZyb20gQmFzZVZpZXcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgb25lIGNvcHkgb2YgZWFjaCB2aWV3XG4gICAgICAgIGlmICggIWluY2x1ZGVzKHRoaXMuX3N1YlZpZXdzLCB2aWV3KSApIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YlZpZXdzLnB1c2godmlldyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICF0aGlzLmVsLmNvbnRhaW5zKCB2aWV3LmVsICkgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FkZGluZyBzdWItdmlldyB3aG9cXCdzIERPTSBlbGVtZW50IGlzblxcJ3QgY29udGFpbmVkIGluIHRoaXMuZWwnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJlbW92ZSBzdWItdmlldyBmcm9tIGludGVybmFsIGFycmF5XG4gICAgICogQHBhcmFtIHZpZXdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bnJlZ2lzdGVyU3ViVmlldyh2aWV3ICkge1xuICAgICAgICBsZXQgdmlld0luZGV4ID0gdGhpcy5fc3ViVmlld3MuaW5kZXhPZiggdmlldyApO1xuXG4gICAgICAgIGlmICh2aWV3SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fc3ViVmlld3Muc3BsaWNlKHZpZXdJbmRleCwxKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXJWaWV3O1xuIiwiLy8gVVpJSyBEZXBlZGVuY2llc1xuaW1wb3J0IEJhc2VWaWV3IGZyb20gJy4uL0Jhc2VWaWV3JztcbmltcG9ydCBJbWFnZUxvYWRlciBmcm9tICcuLi8uLi9uZXQvSW1hZ2VMb2FkZXInO1xuXG4vLyBIaWRkZW4gY29uc3RzXG5cbi8qKlxuICpcbiAqXG4gKlxuICovXG5jbGFzcyBTcHJpdGVBbmltYXRvciBleHRlbmRzIEJhc2VWaWV3IHtcblxuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgc3VwZXIoZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYXZlIHJlbmRlcmluZyBjb250ZXh0IHJlZmVyZW5jZVxuICAgICAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmF3aW5nQ29udGV4dCA9IHRoaXMuZWwuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAvLyBIaURQSSBzdXBwb3J0XG4gICAgICAgIHRoaXMuZHJhd2luZ0NvbnRleHQuc2NhbGUoIDEsIDEpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjIGZyYW1lIGR1cmF0aW9uIHdpdGggRlBTLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mcmFtZUR1cmF0aW9uID0gMTAwMCAvIG9wdGlvbnMuZnBzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdG90YWwgbnVtYmVyIG9mIGZyYW1lcy4gV2UgY2FuJ3QgY2FsYyB0aGlzIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm51bUZyYW1lcyA9IG9wdGlvbnMubnVtRnJhbWVzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb29wIGluIHBvaW50IGlzIHRoZSBmcmFtZSB0byBsb29wIGZyb20uIElmIHRoaXMgdmFsdWUgaXMgLTEsIHRoZSBzcHJpdGUgd2lsbCBub3QgbG9vcFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb29wID0gKG9wdGlvbnMubG9vcCA9PT0gZmFsc2UpID8gLTEgOiAob3B0aW9ucy5sb29wIHx8IDApO1xuXG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmVsLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuZWwuaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5pbWFnZUxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggb3B0aW9ucy51cmwgKTtcbiAgICAgICAgdGhpcy5pbWFnZUxvYWRlci5wcm9taXNlLnRoZW4oIChpbWcpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBpbWcuZGF0YTtcblxuICAgICAgICAgICAgdGhpcy5zb3VyY2VDb2xzID0gTWF0aC5mbG9vciggdGhpcy5zb3VyY2Uud2lkdGggLyB0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlUm93cyA9IE1hdGguZmxvb3IoIHRoaXMuc291cmNlLmhlaWdodCAvIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b3BsYXkgfHwgdGhpcy5fcGxheUFmdGVyTG9hZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgR2V0dGVycyBhbmQgc2V0dGVyc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBnZXQgY3VycmVudEZyYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRGcmFtZTtcbiAgICB9XG5cbiAgICBzZXQgY3VycmVudEZyYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IHZhbHVlIC0gMTtcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICBQdWJsaWMgTWV0aG9kc1xuXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBwbGF5KCkge1xuICAgICAgICBpZiAoIHRoaXMuaW1hZ2VMb2FkZXIuc3RhdHVzICE9PSAnY29tcGxldGUnICkge1xuICAgICAgICAgICAgdGhpcy5fcGxheUFmdGVyTG9hZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCAhdGhpcy5xdWV1ZWRGcmFtZSApIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVkRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIGlzTmFOKHRoaXMubGFzdFJlbmRlcikgfHwgRGF0ZS5ub3coKSAtIHRoaXMubGFzdFJlbmRlciA+IHRoaXMuZnJhbWVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlZEZyYW1lID0gbnVsbDsgLy8gZW1wdHkgcmVmXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nKSB0aGlzLnBsYXkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGF1c2UoKSB7XG5cbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5xdWV1ZWRGcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aGlzLnF1ZXVlZEZyYW1lICk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZEZyYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3BsYXlBZnRlckxvYWQgPSBmYWxzZTsgLy8gaW4gY2FzZSB0aGUgc3ByaXRlIGlzIHBsYXllZCBhbmQgcGF1c2VkIGJlZm9yZSBsb2FkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHJpdmF0ZSBNZXRob2RzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIF9yZW5kZXIoKSB7XG4gICAgICAgIGxldCBmcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZSArIDE7XG5cbiAgICAgICAgaWYgKGZyYW1lID49IHRoaXMubnVtRnJhbWVzIC0gMSkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5sb29wIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhbWUgPSB0aGlzLmxvb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhd2luZ0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICBsZXQgeCA9IE1hdGguZmxvb3IoIGZyYW1lICUgdGhpcy5zb3VyY2VDb2xzKTtcbiAgICAgICAgbGV0IHkgPSBNYXRoLmZsb29yKCBmcmFtZSAvIHRoaXMuc291cmNlQ29scyApO1xuXG4gICAgICAgIHRoaXMuZHJhd2luZ0NvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICB4ICogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIHkgKiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHRoaXMud2lkdGgsXG4gICAgICAgICAgICB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIDAsMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSBmcmFtZTtcbiAgICAgICAgdGhpcy5sYXN0UmVuZGVyID0gRGF0ZS5ub3coKTtcbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIF9jaGlsZENsaWNrSGFuZGxlcigpIHtcblxuICAgIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwcml0ZUFuaW1hdG9yO1xuIiwiLyoqXG4gKiBTaW1wbGUgZnVuY3Rpb24gdG8gZW1wdHkgYW4gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIERPTUVsZW1lbnQgdG8gZW1wdHkgYnkgcmVtb3ZpbmcgYWxsIGl0J3MgY2hpbGRyZW4uXG4gKi9cbmNvbnN0IGVtcHR5ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgd2hpbGUgKCBlbC5maXJzdENoaWxkICkgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBlbXB0eSIsIi8qKlxuICogRmluZCB0aGUgZmlyc3QgcGFyZW50IHRoYXQgaXMgc2Nyb2xsYWJsZS4gaW4gbW9zdCBjYXNlcyB0aGlzIHdpbGwgYmUgdGhlIGRvY3VtZW50IGl0c2VsZi5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB3ZSBuZWVkIHRvIGZpbmQgdGhlIHNjcm9sbCBwYXJlbnQgZm9yXG4gKiBAcmV0dXJucyB7RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsKSB7XG5cbiAgICAvLyBEZWZhdWx0IGlzIEhUTUwgdGFnXG4gICAgbGV0IHNjcm9sbFBhcmVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgIGxldCBlbEl0ZXIgPSBlbDtcbiAgICB3aGlsZSggZWxJdGVyLnBhcmVudE5vZGUgJiYgZWxJdGVyICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgKSB7XG4gICAgICAgIGVsSXRlciA9IGVsSXRlci5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmICggLyhhdXRvfHNjcm9sbCkvLnRlc3Qod2luZG93LmdldENvbXB1dGVkU3R5bGUoIGVsSXRlciApLm92ZXJmbG93WSkgKSB7XG4gICAgICAgICAgICBzY3JvbGxQYXJlbnQgPSBlbEl0ZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzY3JvbGxQYXJlbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFNjcm9sbFBhcmVudDsiLCJpbXBvcnQgaXNBcnJheSBmcm9tICdsb2Rhc2gvaXNBcnJheSc7XG5pbXBvcnQgaXNFbGVtZW50IGZyb20gJ2xvZGFzaC9pc0VsZW1lbnQnO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gJ2xvZGFzaC9pc1N0cmluZyc7XG5pbXBvcnQgaW5kZXhPZiBmcm9tICdsb2Rhc2gvaW5kZXhPZic7XG5pbXBvcnQgZmluZEluZGV4IGZyb20gJ2xvZGFzaC9maW5kSW5kZXgnO1xuXG5cbi8qKlxuICogR2V0IGluZGV4IG9mIHNlYXJjaENyaXRlcmlhIGluIGEgY29sbGVjdGlvbiBvZiBub2RlcyAoZGVmYXVsdCBpcyBzZWFyY2hDcml0ZXJhJ3Mgc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IHNlYXJjaENyaXRlcmlhIC0gQW4gZWxlbWVudCBvciBDU1Mgc2VsZWN0b3IgdG8gZmluZCBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0FycmF5PEVsZW1lbnQ+fSBjb2xsZWN0aW9uIC0gVGhlIGFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaCBpbi5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IEluZGV4IG9mIHRoZSBzZWFyY2ggY3JpdGVyaWEgb3IgLTEgaWYgdGhlIHNlYXJjaENyaXRlcmEgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGNvbGxlY3Rpb25cbiAqL1xuY29uc3QgaW5kZXggPSBmdW5jdGlvbiAoc2VhcmNoQ3JpdGVyaWEsIGNvbGxlY3Rpb24pIHtcblxuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgLy8gaWYgY29sbGVjdGlvbiBwYXJhbWV0ZXIgaXNuJ3QgcHJlc2VudCBvciBhbiBlbGVtZW50LCBhc3N1bWUgd2Ugd2FudCB0byBmaW5kIGl0J3MgcGxhY2UgYW1vbmcgdGhlIG90aGVyIGNoaWxkcmVuIG9mIGl0J3MgcGFyZW50LlxuICAgIGlmICggIWNvbGxlY3Rpb24gfHwgIWlzRWxlbWVudChjb2xsZWN0aW9uKSApIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IEFycmF5LmZyb20oc2VhcmNoQ3JpdGVyaWEucGFyZW50Tm9kZS5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGhlIGNvbGxlY3Rpb24gaXMgYW4gYXJyYXlcbiAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuXG4gICAgICAgIC8vIHNlYXJjaCBhcyBsaXRlcmFsIG9iamVjdFxuICAgICAgICBpZiAoaXNFbGVtZW50KHNlYXJjaENyaXRlcmlhKSkge1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleE9mKGNvbGxlY3Rpb24sIHNlYXJjaENyaXRlcmlhKTtcbiAgICAgICAgICAgIC8vIHNlYXJjaCBhcyBDU1Mgc2VsZWN0b3JcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhzZWFyY2hDcml0ZXJpYSkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZmluZEluZGV4KGNvbGxlY3Rpb24sIChpdGVtKSA9PiBpdGVtLm1hdGNoZXMoc2VhcmNoQ3JpdGVyaWEpICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlYXJjaCBjcml0ZXJpYSBtdXN0IGJlIGFuIGVsZW1lbnQgb3IgYSBTdHJpbmcnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGdldCBhbiBpbmRleCBpbiBhIG5vbi1BcnJheSBjb2xsZWN0aW9uJylcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4OyIsIi8qKlxuICogUmVtb3ZlIG11bHRpcGxlIGNsYXNzZXMgZnJvbSBhbiBFbGVtZW50LiBTdXBwb3J0cyByZW1vdmluZyBjbGFzc2VzIHdpdGggYCpgIHdpbGRjYXJkXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIERPTSBlbGVtZW50IHRvIHJlbW92ZSBjbGFzc2VzIGZyb21cbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXR0ZXJucyAtIE9uZSBvciBtb3JlIGNsYXNzIHBhdHRlcm5zLiBQYXR0ZXJucyBtdXN0IGJlIENTUyBjbGFzcyBuYW1lcyBidXQgY2FuIGFsc28gY29udGFpbiBgKmAgYXMgYSB3aWxkY2FyZC5cbiAqL1xuY29uc3QgcmVtb3ZlQ2xhc3NlcyA9IGZ1bmN0aW9uIChlbCwgLi4ucGF0dGVybnMpIHtcblxuICAgIC8vIHNhdmUgY2xhc3NlcyB0byBhdm9pZCB0cmFuc2Zvcm1pbmcgdGhlIGNsYXNzTmFtZSBvZiB0aGUgZWwgbXVsdGlwbGUgdGltZXNcbiAgICB2YXIgY2xhc3NlcyA9IGVsLmNsYXNzTmFtZTtcblxuICAgIHBhdHRlcm5zLmZvckVhY2goIChwYXR0ZXJuKSA9PiB7XG5cbiAgICAgICAgLy8gcmVwbGFjZSB3aWxkY2FyZCB3aXRoIHJlZ2V4LCBhZGQgc3BhY2UgbWF0Y2hlciBhZnRlciBmb3IgZWxlbWVudHMgd2l0aCBtdWx0aXBsZSBjbGFzc2VzXG4gICAgICAgIGxldCBwYXR0ZXJuUmVnZXggPSBuZXcgUmVnRXhwKCBwYXR0ZXJuLnJlcGxhY2UoJyonLCAnW2EtekEtWjAtOS1fXSsnKSArICdcXFxccz8nICk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNsYXNzZXMgdXNpbmcgUmVnZXhcbiAgICAgICAgY2xhc3NlcyA9IGNsYXNzZXMucmVwbGFjZSggcGF0dGVyblJlZ2V4LCAnJyApXG5cbiAgICB9ICk7XG5cbiAgICAvLyByZSBhc3NpZ24gbmV3IGNsYXNzZXMgdG8gdGhlIGVsZW1lbnRcbiAgICBlbC5jbGFzc05hbWUgPSBjbGFzc2VzO1xuXG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW1vdmVDbGFzc2VzOyIsIi8qKlxuICogVHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIG9uZSBvciBtb3JlIERPTSBlbGVtZW50cyBpbnRvIHVzYWJsZSBvYmplY3RzLlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVN0cmluZ1xuICogQHJldHVybnMge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gVGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RyaW5nLiBJZiBtdWx0aXBsZSByb290IHRhZ3MgYXJlIHByZXNlbnQgaW4gdGhlXG4gKiAgICAgc3RyaW5nLCBpdCB3aWxsIHJldHVybiBhIERvY3VtZW50RnJhZ21lbnRcbiAqL1xuY29uc3Qgc3RyaW5nVG9FbGVtZW50ID0gZnVuY3Rpb24gKHNvdXJjZVN0cmluZykge1xuICAgIC8vIGNyZWF0ZSBhIGR1bW15IGVsZW1lbnQgdGhhdCBpcyB1c2VkXG4gICAgbGV0IGVsZW1lbnRJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbGV0IGk7XG5cbiAgICAvLyBUaHJvdyB0aGUgc3RyaW5nIGludG8gSFRNTFxuICAgIGVsZW1lbnRJdGVyYXRvci5pbm5lckhUTUwgPSBzb3VyY2VTdHJpbmc7XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgcm9vdCBlbGVtZW50cy5cbiAgICBpZiAoIGVsZW1lbnRJdGVyYXRvci5jaGlsZHJlbi5sZW5ndGggPiAxICkgeyAvLyByZXR1cm4gZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAgbGV0IGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIHdoaWxlIChpID0gZWxlbWVudEl0ZXJhdG9yLmZpcnN0Q2hpbGQgKSB7XG4gICAgICAgICAgICBkb2NGcmFnLmFwcGVuZENoaWxkKGkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZG9jRnJhZztcblxuICAgIH0gZWxzZSB7IC8vIGp1c3QgcmV0dXJuIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRJdGVyYXRvci5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ1RvRWxlbWVudDsiLCJpbXBvcnQgZ2V0U2Nyb2xsUGFyZW50IGZyb20gJy4vZG9tL2dldFNjcm9sbFBhcmVudCc7XG5cbmNvbnN0IGdldERvY3VtZW50UmVjdCA9IGZ1bmN0aW9uKGVsKSB7XG5cbiAgICBsZXQgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBjb25zdCBzY3JvbGxFbCA9IGdldFNjcm9sbFBhcmVudCggZWwgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcCA6IGVsUmVjdC50b3AgKyBzY3JvbGxFbC5zY3JvbGxUb3AsXG5cbiAgICAgICAgbGVmdDogZWxSZWN0LmxlZnQgKyBzY3JvbGxFbC5zY3JvbGxUb3AsXG5cbiAgICAgICAgd2lkdGggICA6IGVsUmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ICA6IGVsUmVjdC5oZWlnaHQsXG5cbiAgICAgICAgcmlnaHQgICA6IGVsUmVjdC5yaWdodCArIHNjcm9sbEVsLnNjcm9sbExlZnQsXG4gICAgICAgIGJvdHRvbSAgOiBlbFJlY3QuYm90dG9tICsgc2Nyb2xsRWwuc2Nyb2xsVG9wXG4gICAgfTtcblxufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0RG9jdW1lbnRSZWN0OyIsIlxuXG5cbmNsYXNzIFBvaW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHgsIHksIGFuZ2xlID0gTmFOLCBkaXN0YW5jZSA9IE5hTikge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIC8vIFNhdmUgb3B0aW9uYWwgYW5nbGUgYW5kIGRpc3RhbmNlXG4gICAgICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXG4gICAgfVxuXG4gICAgdG9Qb2xhcigpIHtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcG9sYXIgY29vcmRpbmF0ZXMgaWYgdGhleSB3ZXJlbid0IHN1cHBsaWVkIHRvIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICBpZiAoIGlzTmFOKHRoaXMuYW5nbGUpIHx8IGlzTmFOKHRoaXMuZGlzdGFuY2UpICkge1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IE1hdGguc3FydCggIE1hdGgucG93KHRoaXMueCwgMikgKyBNYXRoLnBvdyh0aGlzLnksIDIpICk7XG4gICAgICAgICAgICB0aGlzLmFuZ2xlID0gTWF0aC5hdGFuMiggdGhpcy55LCB0aGlzLnggKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbmdsZSA6IHRoaXMuYW5nbGUsXG4gICAgICAgICAgICBkaXN0YW5jZSA6IHRoaXMuZGlzdGFuY2VcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBhXG4gKiBAcGFyYW0ge1BvaW50fSBiXG4gKi9cblBvaW50LmRpc3RhbmNlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBsZXQgeCA9IChiLnggLSBhLngpO1xuICAgIGxldCB5ID0gKGIueSAtIGEueSk7XG4gICAgcmV0dXJuIE1hdGguc3FydCggKHgqeCkgKyAoeSp5KSApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgUG9pbnQ7IiwiaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2NvcmUvRXZlbnRUYXJnZXQnO1xuXG4vKipcbiAqIEtleWJvYXJkIGNsYXNzIHByb3ZpZGVzIGEgc21hbGwgYWJzdHJhY3Rpb24gbGF5ZXIgdG8gbWFrZSBLZXlib2FyZCBldmVudHMgbW9yZSBFdmVudFRhcmdldCBmcmllbmRseVxuICpcbiAqL1xuY2xhc3MgS2V5Ym9hcmQgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gW3RhcmdldD13aW5kb3cuZG9jdW1lbnRdIC0gVGhlIGVsZW1lbnQgdG8gbGlzdGVuIHRvIGV2ZW50cyB0by4gRGVmYXVsdHMgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCA9IHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBET00gZXZlbnQgdGFyZ2V0XG4gICAgICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHt7cHJlc3M6IChmdW5jdGlvbihldmVudDpFdmVudCkpLCBkb3duOiAoZnVuY3Rpb24oZXZlbnQ6RXZlbnQpKX19XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9rZXlib2FyZEV2ZW50cyA9IHtcbiAgICAgICAgICAgIHByZXNzICAgOiB0aGlzLl9rZXlQcmVzc0hhbmRsZXIuYmluZCggdGhpcyApLFxuICAgICAgICAgICAgZG93biAgICA6IHRoaXMuX2tleURvd25IYW5kbGVyLmJpbmQoIHRoaXMgKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMuX2tleWJvYXJkRXZlbnRzLnByZXNzKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlib2FyZEV2ZW50cy5kb3duKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMuX2tleWJvYXJkRXZlbnRzLnByZXNzKTtcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWJvYXJkRXZlbnRzLmRvd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEtleXByZXNzIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBFdmVudCBvYmplY3RcbiAgICAgKiBAZW1pdHMge0V2ZW50fSBOYXRpdmUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9rZXlQcmVzc0hhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgLy8gZm9yd2FyZCBldmVudFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3ByZXNzJywgZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEtleWRvd24gZXZlbnQuIEFkZHMgc3ltYm9sIHRvIGV2ZW50IG9iamVjdCBiZWZvcmUgZm9yd2FyZGluZyBpdC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBldmVudFxuICAgICAqIEBlbWl0cyB7RXZlbnR9IE5hdGl2ZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2tleURvd25IYW5kbGVyKGV2ZW50KSB7XG5cbiAgICAgICAgLy8gZ2V0IGNoYXJcbiAgICAgICAgZXZlbnQuc3ltYm9sID0gS2V5Ym9hcmQuY29kZXNbIGV2ZW50LmtleUNvZGUgXTtcblxuICAgICAgICAvLyBzYXZlIGxhdGVzdCBwb2ludHNcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkb3duJywgZXZlbnQpO1xuICAgIH1cblxufVxuXG4vLyBjb25zdGFudCB0eXBlIHZhbHVlcyBmb3IgY29tcGFyaXNvblxuS2V5Ym9hcmQua2V5cyA9IHt9O1xuS2V5Ym9hcmQua2V5cy5FU0MgICAgICAgPSAyNztcblxuLy8gSW52ZXJzZSBsb29rdXAgZm9yIGtleWJvYXJkIHZhbHVlcztcbktleWJvYXJkLmNvZGVzID0gW107XG5LZXlib2FyZC5jb2Rlc1sgMjcgXSAgICA9ICdFU0MnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IEtleWJvYXJkO1xuIiwiaW1wb3J0IGZpcnN0IGZyb20gJ2xvZGFzaC9maXJzdCc7XG5pbXBvcnQgbGFzdCBmcm9tICdsb2Rhc2gvbGFzdCc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnbG9kYXNoL2RlZmF1bHRzJztcblxuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2NvcmUvRXZlbnRUYXJnZXQnO1xuXG4vKipcbiAqXG4gKiBUaGVzZSBjb25zdGFudHMgcmVwcmVzZW50IGdlc3R1cmVzIHRoYXQgdGhlIHRvdWNoIGluc3RhbmNlIHdpbGwgdHJ5IHRvIG1hdGNoXG4gKlxuICpcbiAqL1xuY29uc3QgR0VTVFVSRVNfREVGSU5JVElPTlMgPSB7XG5cbiAgICAvKlxuXG4gICAgIFNXSVBFIERFVEVDVE9SXG5cbiAgICAgKi9cbiAgICAnc3dpcGUnOiB7XG4gICAgICAgIGRldGVjdDogZnVuY3Rpb24gKGV2ZW50cywgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBsZXQgZGV0ZWN0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gb25seSBkZXRlY3Qgc3dpcGVzIHdpdGggbXVsdGlwbGUgZXZlbnRzXG4gICAgICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RFdmVudCA9IGZpcnN0KGV2ZW50cyk7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RFdmVudCA9IGxhc3QoZXZlbnRzKTtcblxuICAgICAgICAgICAgICAgIC8vIFN3aXBlIHdpdGggb25lIGZpbmdlciBvbmx5LlxuICAgICAgICAgICAgICAgIGlmICghaXNNdWx0aVRvdWNoKGZpcnN0RXZlbnQpICYmICFpc011bHRpVG91Y2gobGFzdEV2ZW50KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YVggPSBsYXN0RXZlbnQudG91Y2hlc1swXS5zY3JlZW5YIC0gZmlyc3RFdmVudC50b3VjaGVzWzBdLnNjcmVlblg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YVkgPSBsYXN0RXZlbnQudG91Y2hlc1swXS5zY3JlZW5ZIC0gZmlyc3RFdmVudC50b3VjaGVzWzBdLnNjcmVlblk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFEZWx0YVggPSBNYXRoLmFicyhkZWx0YVgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYURlbHRhWSA9IE1hdGguYWJzKGRlbHRhWSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGRpcmVjdGlvbiBieSBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICAgIGlmIChhRGVsdGFYID4gKDIgKiBhRGVsdGFZKSAmJiBhRGVsdGFYID4gb3B0aW9ucy5zd2lwZVRocmVzaG9sZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpczogJ3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGRlbHRhWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogZGVsdGFZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG9wdGlvbnMudmVydGljYWxTd2lwZSAmJiBhRGVsdGFZID4gKDIgKiBhRGVsdGFYKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpczogJ3knLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGRlbHRhWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogZGVsdGFZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRldGVjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGF0Y2hFdmVudCh0YXJnZXQsIGV2ZW50RGF0YSkge1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgZXZlbnRcbiAgICAgICAgICAgIGxldCBzd2lwZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBzd2lwZUV2ZW50LmluaXRDdXN0b21FdmVudCgnc3dpcGUnLCB0cnVlLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgICBzd2lwZUV2ZW50LmRpc3RhbmNlID0gZXZlbnREYXRhLmRpc3RhbmNlO1xuICAgICAgICAgICAgc3dpcGVFdmVudC5heGlzID0gZXZlbnREYXRhLmF4aXM7XG5cbiAgICAgICAgICAgIC8vIGRpc3BhdGNoIGl0IHRocm91Z2ggdGhlIERPTVxuICAgICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoc3dpcGVFdmVudCk7XG5cbiAgICAgICAgfSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKlxuXG4gICAgIFpPT00gREVURUNUT1JcblxuICAgICAqL1xuICAgICd6b29tJzoge1xuICAgICAgICBkZXRlY3Q6IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICAgICAgICAgIGxldCBkZXRlY3Rpb24gPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBvbmx5IGRldGVjdCB6b29tcyB3aXRoIG11bHRpcGxlIGV2ZW50c1xuICAgICAgICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPj0gMikge1xuXG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICAvLyBkZXRlY3QgbXVsdGlwbGUgbXVsdGkgdG91Y2ggZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKGlzTXVsdGlUb3VjaChmaXJzdCkgJiYgaXNNdWx0aVRvdWNoKGxhc3QpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGRpc3RhbmNlcyBmb3IgYm90aCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0RGlzdGFuY2UgPSB0b3VjaERpc3RhbmNlKGZpcnN0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3REaXN0YW5jZSA9IHRvdWNoRGlzdGFuY2UobGFzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gWm9vbSBpcyBvbmx0IHdoZW4gZmluZ2VycyBleHBhbmQgYXdheSBmcm9tIGVhY2ggb3RoZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RGlzdGFuY2UgPCBsYXN0RGlzdGFuY2UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgOiBsYXN0RGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyIDogdG91Y2hDZW50ZXIobGFzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRldGVjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGF0Y2hFdmVudCh0YXJnZXQsIGV2ZW50RGF0YSkge1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgZXZlbnRcbiAgICAgICAgICAgIGxldCBzd2lwZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBzd2lwZUV2ZW50LmluaXRDdXN0b21FdmVudCgnem9vbScsIHRydWUsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgICAgIHN3aXBlRXZlbnQuZGlzdGFuY2UgPSBldmVudERhdGEuZGlzdGFuY2U7XG5cbiAgICAgICAgICAgIC8vIGRpc3BhdGNoIGl0IHRocm91Z2ggdGhlIERPTVxuICAgICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoc3dpcGVFdmVudCk7XG5cbiAgICAgICAgfSxcbiAgICAgICAgcmVwZWF0OiB0cnVlXG4gICAgfSxcblxuICAgICdwaW5jaCc6IHtcbiAgICAgICAgZGV0ZWN0OiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgICAgICAgICBsZXQgZGV0ZWN0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gb25seSBkZXRlY3Qgem9vbXMgd2l0aCBtdWx0aXBsZSBldmVudHNcbiAgICAgICAgICAgIGlmIChldmVudHMubGVuZ3RoID49IDIpIHtcblxuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IG11bHRpcGxlIG11bHRpIHRvdWNoIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChpc011bHRpVG91Y2goZmlyc3QpICYmIGlzTXVsdGlUb3VjaChsYXN0KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBkaXN0YW5jZXMgZm9yIGJvdGggcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdERpc3RhbmNlID0gdG91Y2hEaXN0YW5jZShmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0RGlzdGFuY2UgPSB0b3VjaERpc3RhbmNlKGxhc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdERpc3RhbmNlID4gbGFzdERpc3RhbmNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlIDogbGFzdERpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlciA6IHRvdWNoQ2VudGVyKGxhc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZXRlY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCBldmVudERhdGEpIHtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGV2ZW50XG4gICAgICAgICAgICBsZXQgc3dpcGVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgc3dpcGVFdmVudC5pbml0Q3VzdG9tRXZlbnQoJ3pvb20nLCB0cnVlLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgICBzd2lwZUV2ZW50LmRpc3RhbmNlID0gZXZlbnREYXRhLmRpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBkaXNwYXRjaCBpdCB0aHJvdWdoIHRoZSBET01cbiAgICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KHN3aXBlRXZlbnQpO1xuXG4gICAgICAgIH0sXG4gICAgICAgIHJlcGVhdDogdHJ1ZVxuICAgIH1cblxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGV2ZW50IGlzIGRldGVjdGluZyBtdXRsaXBsZSB0b3VjaCBwb2ludHMuXG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50IC0gVGhlIFRvdWNoRXZlbnQgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTXVsdGlUb3VjaChldmVudCkge1xuICAgIHJldHVybiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDE7XG59XG5cbi8qKlxuICogR2V0IGRpc3RhbmNlIGJldHdlZW4gdHdvIHRvdWNoZXMgb2YgYW4gZXZlbnQuIFNpbXBsZSBzcXVhcmUgcm9vdC5cbiAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnQgLSBBIG11bHRpLXRvdWNoIG5hdGl2ZSB0b3VjaCBldmVudFxuICogQHJldHVybnMge251bWJlcn0gRGlzdGFuY2UgaW4gcGl4ZWxzIGJldHdlZW4gdG91Y2hlc1xuICovXG5mdW5jdGlvbiB0b3VjaERpc3RhbmNlKGV2ZW50KSB7XG5cbiAgICBsZXQgYSA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgbGV0IGIgPSBldmVudC50b3VjaGVzWzFdO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggTWF0aC5wb3coYi5jbGllbnRYIC0gYS5jbGllbnRYLCAyKSArIE1hdGgucG93KGIuY2xpZW50WSAtIGEuY2xpZW50WSwgMikgKTtcbn1cblxuLyoqXG4gKiBHZXQgY2VudGVyIG9mIHRvdWNoIGV2ZW50J3MgdG91Y2hlcy5cbiAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnQgLSBUaGUgbmF0aXZlIGV2ZW50IHRvIGFuYWx5c2UuXG4gKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBUaGUgY2VudGVyIHRoZSBzdXBwbGllZCBldmVudCdzIHRvdWNoZXMuIElmIHRoZXJlIGlzIGEgc2luZ2xlIHRvdWNoLCBpdCB3aWxsIHJldHVybiBpdCdzIGNvb3JkaW5hdGVzLlxuICovXG5mdW5jdGlvbiB0b3VjaENlbnRlcihldmVudCkge1xuICAgIGlmICggaXNNdWx0aVRvdWNoKGV2ZW50KSApIHtcblxuICAgICAgICBsZXQgYSA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICAgIGxldCBiID0gZXZlbnQudG91Y2hlc1sxXTtcblxuICAgICAgICBsZXQgYVggPSBhLmNsaWVudFg7XG4gICAgICAgIGxldCBhWSA9IGEuY2xpZW50WTtcblxuICAgICAgICBsZXQgYlggPSBiLmNsaWVudFg7XG4gICAgICAgIGxldCBiWSA9IGIuY2xpZW50WTtcblxuICAgICAgICAvLyAgICAgICAgIHN0YXJ0XG4gICAgICAgIGxldCB4ID0gYVggKyAoKGJYIC0gYVgpIC8gMik7XG4gICAgICAgIGxldCB5ID0gYVkgKyAoKGJZIC0gYVkpIC8gMik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHggOiB4LFxuICAgICAgICAgICAgeSA6IHlcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeCA6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgICB5IDogdG91Y2guY2xpZW50WVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogQ2xhc3MgdG8gdHJhY2sgc2ltcGxlIHRvdWNoIGdlc3R1cmVzLiBJbnNwaXJlZCBwYXJ0bHkgYnkgaGFtbWVyLmpzXG4gKlxuICogQFRPRE8gbWFrZSBnZXN0dXJlcyBvcHRpb25hbCwgbW92aW5nIGRldGVjdG9ycyBpbnRvIHNlcGFyYXRlIGNsYXNzXG4gKiBAdG9kbyBjb25maWd1cmUgZ2VzdHVyZSBkZXRlY3RvcnMgdG8gYXZvaWQgdXNlbGVzcyBvcGVyYXRpb25zIG9uIG11bHRpcGxlIG9iamVjdHNcbiAqXG4gKi9cbmNsYXNzIFRvdWNoIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBUYXJnZXQgb2YgdG91Y2ggZXZlbnRzIHRvIGxpc3RlbiB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgY2xhc3MgYmVoYXZpb3IuIFNlZSBkZWZhdWx0cyBmb3IgbW9yZSBpbmZvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhdmUgZXZlbnQgdGFyZ2V0XG4gICAgICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhdmVkIG9wdGlvbnMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIFRvdWNoLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgICAvLyBjcmVhdGUgYW5kIHN0b3JlIGJvdW5kIGZ1bmN0aW9ucyB0aGF0IGFyZSB1c2VkIGFzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl90b3VjaEV2ZW50cyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbW92ZTogdGhpcy5fdG91Y2hNb3ZlSGFuZGxlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZW5kOiB0aGlzLl90b3VjaEVuZEhhbmRsZXIuYmluZCh0aGlzKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl90b3VjaEV2ZW50cy5zdGFydCk7XG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX3RvdWNoRXZlbnRzLm1vdmUpO1xuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3RvdWNoRXZlbnRzLmVuZCk7XG5cbiAgICAgICAgLy8gVG8gaGVscCBoYW5kbGluZyB3aG9sZSB0b3VjaCBjeWNsZSAoc3RhcnQgLT4gbW92ZSAtPiBlbmQpIGxpc3RlbiB0byB0aGUgZW5kIGV2ZW50IG9uIHRoZSB3aW5kb3cgdG9vLlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJpbmRXaW5kb3dFbmQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3RvdWNoRXZlbnRzLmVuZCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBkaXN0YW5jZSBiZXR3ZWVuIGZpcnN0IGFuZCBsYXN0IGV2ZW50IHBvaW50cyBvbiBib3RoIGF4aXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IERpc3RhbmNlIGluIHBpeGVscyBiZXR3ZWVuIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBjdXJyZW50bHkgdHJhY2tlZC4gQmFzZWQgb24gdGhlIGZpcnN0IHRvdWNoIG9mIGEgbXVsdGkgdG91Y2ggZXZlbnRzXG4gICAgICovXG4gICAgZ2V0IGRpc3RhbmNlKCkge1xuXG4gICAgICAgIC8vIG9ubHkgcmV0dXJuIGEgbnVtYmVyIGlmIHRoZXJlIGlzIGEgcHJvcGVyIGRpc3RhbmNlXG4gICAgICAgIGlmICggIXRoaXMuX2V2ZW50QnVmZmVyIHx8IHRoaXMuX2V2ZW50QnVmZmVyLmxlbmd0aCA8IDIgKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMuX2V2ZW50QnVmZmVyWzBdLnRvdWNoZXNbMF07XG4gICAgICAgICAgICBsZXQgYiA9IHRoaXMuX2V2ZW50QnVmZmVyWyB0aGlzLl9ldmVudEJ1ZmZlci5sZW5ndGggLSAxIF0udG91Y2hlc1swXTtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCggTWF0aC5wb3coYi5jbGllbnRYIC0gYS5jbGllbnRYLCAyKSArIE1hdGgucG93KGIuY2xpZW50WSAtIGEuY2xpZW50WSwgMikgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGlzdGFuY2UgYmV0d2VlbiBmaXJzdCBhbmQgbGFzdCBldmVudCBwb2ludHMgb24gdGhlIFggYXhpc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gRGlzdGFuY2UgaW4gcGl4ZWxzIGJldHdlZW4gZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGN1cnJlbnRseSB0cmFja2VkLiBCYXNlZCBvbiB0aGUgZmlyc3QgdG91Y2ggb2YgYSBtdWx0aSB0b3VjaCBldmVudHNcbiAgICAgKi9cbiAgICBnZXQgZGlzdGFuY2VYKCkge1xuICAgICAgICAvLyBvbmx5IHJldHVybiBhIG51bWJlciBpZiB0aGVyZSBpcyBhIHByb3BlciBkaXN0YW5jZVxuICAgICAgICBpZiAoICF0aGlzLl9ldmVudEJ1ZmZlciB8fCB0aGlzLl9ldmVudEJ1ZmZlci5sZW5ndGggPCAyICkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgbGV0IGEgPSB0aGlzLl9ldmVudEJ1ZmZlclswXS50b3VjaGVzWzBdO1xuICAgICAgICAgICAgbGV0IGIgPSB0aGlzLl9ldmVudEJ1ZmZlclsgdGhpcy5fZXZlbnRCdWZmZXIubGVuZ3RoIC0gMSAgXS50b3VjaGVzWzBdO1xuXG4gICAgICAgICAgICByZXR1cm4gYi5jbGllbnRYIC0gYS5jbGllbnRYO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGRpc3RhbmNlIGJldHdlZW4gZmlyc3QgYW5kIGxhc3QgZXZlbnQgcG9pbnRzIG9uIHRoZSBZIGF4aXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IERpc3RhbmNlIGluIHBpeGVscyBiZXR3ZWVuIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBjdXJyZW50bHkgdHJhY2tlZC4gQmFzZWQgb24gdGhlIGZpcnN0IHRvdWNoIG9mIGEgbXVsdGkgdG91Y2ggZXZlbnRzXG4gICAgICovXG4gICAgZ2V0IGRpc3RhbmNlWSgpIHtcbiAgICAgICAgLy8gb25seSByZXR1cm4gYSBudW1iZXIgaWYgdGhlcmUgaXMgYSBwcm9wZXIgZGlzdGFuY2VcbiAgICAgICAgaWYgKCAhdGhpcy5fZXZlbnRCdWZmZXIgfHwgdGhpcy5fZXZlbnRCdWZmZXIubGVuZ3RoIDwgMiApIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5fZXZlbnRCdWZmZXJbMF0udG91Y2hlc1swXTtcbiAgICAgICAgICAgIGxldCBiID0gdGhpcy5fZXZlbnRCdWZmZXJbIHRoaXMuX2V2ZW50QnVmZmVyLmxlbmd0aCAtIDEgIF0udG91Y2hlc1swXTtcblxuICAgICAgICAgICAgcmV0dXJuIGIuY2xpZW50WSAtIGEuY2xpZW50WTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgbmF0aXZlIGV2ZW50cyBhbmQgY2xlYW51cFxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG5cbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3RvdWNoRXZlbnRzLnN0YXJ0KTtcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fdG91Y2hFdmVudHMubW92ZSk7XG4gICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fdG91Y2hFdmVudHMuZW5kKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJpbmRXaW5kb3dFbmQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3RvdWNoRXZlbnRzLmVuZCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qID09PT09PT1cblxuICAgICBQcml2YXRlIG1ldGhvZHNcblxuICAgICA9PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdHJhY2tpbmcgdG91Y2ggZXZlbnRzIG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnQgLSBOYXRpdmUgRE9NIGV2ZW50XG4gICAgICogQGVtaXRzIHtUb3VjaEV2ZW50fSBOYXRpdmUgRE9NIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc3RhcnQoZXZlbnQpIHtcblxuICAgICAgICAvLyBpbiBjYXNlICdlbmQoKScgaXNuJ3QgY2FsbGVkIHByb3Blcmx5LiBQcm9iYWJseSBzaG91bGRuJ3QgaGFwcGVuLlxuICAgICAgICBpZiAodGhpcy5pc1RvdWNoZWQpIHRoaXMuZW5kKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlcmUgaXMgYWN1dGFsbHkgYSB0b3VjaCBvbiB0aGUgZGV2aWNlLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNUb3VjaGVkID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgYnVmZmVyIG9mIGV2ZW50cyB0byBhbmFseXNlXG4gICAgICAgICAqIEB0eXBlIHtUb3VjaEV2ZW50W119XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ldmVudEJ1ZmZlciA9IFtldmVudF07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGxpc3Qgb2YgZ2VzdHVyZXMgY3VycmVudGx5IGJlaW5nIGRldGVjdGVkXG4gICAgICAgICAqIEB0eXBlIHt7fX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2N1cnJlbnRHZXN0dXJlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignc3RhcnQnLCBldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50IC0gTmF0aXZlIERPTSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRCdWZmZXIucHVzaChldmVudCk7XG5cbiAgICAgICAgLy8gUnVuIGRldGVjdG9yc1xuICAgICAgICAvLyBUT0RPIG1vdmUgdG8gc3ViLWNsYXNzXG4gICAgICAgIGZvciAobGV0IGdlc3R1cmUgaW4gR0VTVFVSRVNfREVGSU5JVElPTlMpIHtcblxuICAgICAgICAgICAgbGV0IGdlc3R1cmVEZWYgPSBHRVNUVVJFU19ERUZJTklUSU9OU1tnZXN0dXJlXTtcbiAgICAgICAgICAgIGxldCBnZXN0dXJlSW5mbyA9IGdlc3R1cmVEZWYuZGV0ZWN0KHRoaXMuX2V2ZW50QnVmZmVyLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBpZiBnZXN0dXJlIGRldGVjdGVkXG4gICAgICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcblxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgcmVwZWF0IGV2ZW50cyBvbiBnZXN0dXJlcyB0aGF0IG9ubHkgc2hvdWxkIGhhcHBlbiBvbmNlIHBlciB0b3VjaCBjeWNsZSAoc3dpcGUgZm9yIGV4YW1wbGUpLiBDb3VsZCBhbHNvIGJlIGhhbmRsZWQgaW4gdG91Y2hlbmQ/XG4gICAgICAgICAgICAgICAgaWYgKCBnZXN0dXJlRGVmLnJlcGVhdCB8fCAoIWdlc3R1cmVEZWYucmVwZWF0ICYmICF0aGlzLl9jdXJyZW50R2VzdHVyZXNbZ2VzdHVyZV0pICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gcHJldmVudCBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBnZXN0dXJlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRHZXN0dXJlc1tnZXN0dXJlXSA9IGdlc3R1cmVJbmZvO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXN0dXJlRGVmLmRpc3BhdGNoRXZlbnQodGhpcy50YXJnZXQsIGdlc3R1cmVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihnZXN0dXJlLCBnZXN0dXJlSW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignbW92ZScsIGV2ZW50KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuZCBvZiB0b3VjaC4gUmVzZXQgaW50ZXJuYWwgdmFyc1xuICAgICAqIEBwYXJhbSBldmVudCAtIE5hdGl2ZSBET00gZXZlbnRcbiAgICAgKiBAZW1pdHMge1RvdWNoRXZlbnR9IC0gTmF0aXZlIERPTSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2VuZChldmVudCkge1xuXG4gICAgICAgIC8vIFRyaWdnZXIgZXZlbnQgYmVmb3JlIGRpc3Bvc2luZyBvZiBzYXZlZCBzdGF0ZVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2VuZCcsIGV2ZW50KTtcblxuICAgICAgICB0aGlzLl9ldmVudEJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmlzVG91Y2hlZCA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgLyogPT09PT09PVxuXG4gICAgIEV2ZW50IEhhbmRsZXJzXG5cbiAgICAgPT09PT09PT0gKi9cblxuICAgIC8qKlxuICAgICAqIE5hdGl2ZSBzdGFydCBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG91Y2hTdGFydEhhbmRsZXIoZXZlbnQpIHtcblxuICAgICAgICAvLyBzdGFuZGFyZCBiZWh2aW91ciBpcyB0b28gZGlzYWJsZSBzY3JvbGxpbmcgYW5kIHpvb21pbmcgb24gbXVsdGkgdG91Y2hcbiAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlJ3JlIGFscmVhZHkgdG91Y2hpbmcsIGFuZCBhbm90aGVyIGZpbmdlciBzdGFydHMgdG91Y2hpbmcsIHRyZWF0IGl0IGFzIGEgbW92ZVxuICAgICAgICBpZiAodGhpcy5pc1RvdWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdmUoZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnQoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOYXRpdmUgbW92ZSBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG91Y2hNb3ZlSGFuZGxlcihldmVudCkge1xuXG4gICAgICAgIC8vIHN0YW5kYXJkIGJlaHZpb3VyIGlzIHRvbyBkaXNhYmxlIHNjcm9sbGluZyBhbmQgem9vbWluZyBvbiBtdWx0aSB0b3VjaFxuICAgICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW92ZShldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmF0aXZlIGVuZCBldmVudCBoYW5ka2VyXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG91Y2hFbmRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2VuZChldmVudCk7XG4gICAgfVxuXG59XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHR5cGUge3t2ZXJ0aWNhbFN3aXBlOiBib29sZWFuLCBzd2lwZVRocmVzaG9sZDogbnVtYmVyLCBkb21FdmVudHM6IGJvb2xlYW59fVxuICovXG5Ub3VjaC5kZWZhdWx0T3B0aW9ucyA9IHtcblxuICAgIC8qKlxuICAgICAqIERlY3RlZCB5IGF4aXMgd2hlbiBkZXRlY3Rpbmcgc3dpcGVzLiBWZXJ5IG9mdGVuIHdlIGRvbid0IHdhbnQgdG8gYmxvY2sgc2Nyb2xsaW5nLlxuICAgICAqL1xuICAgIHZlcnRpY2FsU3dpcGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBkaXN0YW5jZSB0byB0cmlnZ2VyIHN3aXBlIGV2ZW50XG4gICAgICovXG4gICAgc3dpcGVUaHJlc2hvbGQ6IDEwLFxuXG4gICAgLyoqXG4gICAgICogV2lsbCBjcmVhdGUgYW5kIHRyaWdnZXIgY3VzdG9tIGJ1YmJsaW5nIERPTSBldmVudHMgZm9yIGdlc3R1cmVzLlxuICAgICAqL1xuICAgIGRvbUV2ZW50czogdHJ1ZVxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUb3VjaCIsImltcG9ydCBkZWZhdWx0cyBmcm9tICdsb2Rhc2gvZGVmYXVsdHMnO1xuXG5pbXBvcnQgTG9hZGVyIGZyb20gJy4vTG9hZGVyJztcblxuY2xhc3MgSW1hZ2VMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG4gICAgY29uc3RydWN0b3IodXJsLCBzcmNzZXQsIHNpemVzLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgaXQncyBwYXVzZWQgc28gd2UgY2FuIGNoYW5nZSBwYXVzZWQgc3RhdHVzXG4gICAgICAgIGxldCBwYXVzZWQgPSBvcHRpb25zLnBhdXNlZDtcblxuICAgICAgICBzdXBlcih1cmwsIGRlZmF1bHRzKHtwYXVzZWQ6IHRydWV9LCBvcHRpb25zKSApO1xuXG4gICAgICAgIHRoaXMuc3Jjc2V0ID0gc3Jjc2V0O1xuICAgICAgICB0aGlzLnNpemVzID0gc2l6ZXM7XG5cbiAgICAgICAgaWYgKCAhcGF1c2VkICkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGxvYWQgbWVjaGFuaXNtXG4gICAgICovXG4gICAgbG9hZCgpIHtcblxuICAgICAgICBsZXQgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IExvYWRlci5TVEFUVVMuTE9BRElORztcbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2VSZXNvbHZlKHt1cmwgOiB0aGlzLnVybCwgZGF0YTogaW1hZ2UsIHJhd0RhdGE6IGltYWdlfSk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVMb2FkQ29tcGxldGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpbWFnZS5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVJlamVjdCgnQ291bGQgbm90IGxvYWQgSW1hZ2UgOiAnKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUxvYWRDb21wbGV0ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIElmIGFscmVhZHkgbG9hZGVkIGNhbGwgbG9hZCBoYW5kbGVyIG1hbnVhbGx5XG4gICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSA9PT0gdHJ1ZSAmJiBpbWFnZS53aWR0aCAmJiBpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoICgpID0+IGltYWdlLm9ubG9hZCgpLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIHN0YXJ0IHRoZSBsb2FkXG4gICAgICAgIGlmICh0aGlzLnNyY3NldCkgaW1hZ2Uuc3Jjc2V0ID0gdGhpcy5zcmNzZXQ7XG4gICAgICAgIGlmICh0aGlzLnNpemVzKSBpbWFnZS5zaXplcyA9IHRoaXMuc2l6ZXM7XG4gICAgICAgIGltYWdlLnNyYyA9IHRoaXMudXJsO1xuXG4gICAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlTG9hZGVyOyIsImltcG9ydCB4aHIgZnJvbSAneGhyJztcblxuLy8gWmltcGxlIGRlcGVuZGVuY2llc1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2NvcmUvRXZlbnRUYXJnZXQnO1xuXG5cbmxldCBsb2FkZXJJRCA9IDA7XG5cbmNsYXNzIExvYWRlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcblxuICAgIGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucyA9IHtwYXVzZWQgOiBmYWxzZSwgcGFyc2VCb2R5IDogdHJ1ZX0pIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQgfHwgJ2xvYWRlci0nK2xvYWRlcklEKys7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICAvLyBMb2FkIHByb2dyZXNzLCBhdCBjb25zdHJ1Y3QsIGl0IGlzIGFsd2F5cyAwXG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuXG4gICAgICAgIC8vIENyZWF0ZSBQcm9taXNlIGZvciB0aGlzIGxvYWRlciwgYW5kIHNhdmUgdGhlIHJlc29sdmUgYW5kIHJlamVjdCBmdW5jdGlvbnMgZm9yIGxhdGVyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdGFydCBvciBwYXVzZSBsb2FkaW5nXG4gICAgICAgIGlmICggdGhpcy5vcHRpb25zLnBhdXNlZCApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gTG9hZGVyLlNUQVRVUy5QQVVTRUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgbG9hZCgpIHtcblxuICAgICAgICAvLyBkZXRlY3QgdHlwZSBvZiBsb2FkXG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHhocih7XG4gICAgICAgICAgICB1cmwgOiB0aGlzLnVybCxcbiAgICAgICAgICAgIGJlZm9yZVNlbmQgOiAobmF0aXZlWEhSKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIHByb2dyZXNzIGV2ZW50LiB5b3UgbmV2ZXIga25vd1xuICAgICAgICAgICAgICAgIG5hdGl2ZVhIUi5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVMb2FkUHJvZ3Jlc3MoZXZlbnQpOyAvLyBmb3JjZSBjb250ZXh0IHRvIGluc3RhbmNlIG9mIHByZWxvYWRlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoZXJyLCByZXNwb25zZSwgYm9keSkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgc3RhdHVzQ29kZUNhdGVnb3J5ID0gcGFyc2VJbnQoIHJlc3BvbnNlLnN0YXR1c0NvZGUudG9TdHJpbmcoKVswXSApO1xuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVqZWN0KG5ldyBFcnJvcihyZXNwb25zZS50ZXh0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlTG9hZENvbXBsZXRlKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIF8uaW5jbHVkZXMoIFs0LCA1XSwgc3RhdHVzQ29kZUNhdGVnb3J5ICkgKSB7XG5cblxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIHNhdmUgYSBjb3B5IG9mIHRoZSByYXcgZGF0YVxuICAgICAgICAgICAgICAgIHRoaXMucmF3RGF0YSA9IGJvZHk7XG5cbiAgICAgICAgICAgICAgICAvLyBtaWdodCB3YW50IHRvIHBhcnNlIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJzZUJvZHkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoZXJlIGlzbid0IGFuIGV4dGVuc2lvbiwgcmVzb3J0IHRvIGNvbnRlbnQtdHlwZSBzbmlmZmluZyBhbmQgZm9yY2luZyB0aGUgdHlwZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMudXJsLmxhc3RJbmRleE9mKCcuJykgPCB0aGlzLnVybC5sYXN0SW5kZXhPZignLycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb250ZW50VHlwZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdqc29uJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gTG9hZGVyLnBhcnNlUmVzcG9uc2VCb2R5KCB0aGlzLnVybCwgYm9keSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBMb2FkZXIucGFyc2VSZXNwb25zZUJvZHkoIHRoaXMudXJsLCBib2R5ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVJlc29sdmUoe3VybCA6IHRoaXMudXJsLCBkYXRhOiB0aGlzLmRhdGEsIHJhd0RhdGE6IGJvZHl9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVMb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN0YXR1cyA9IExvYWRlci5TVEFUVVMuTE9BRElORztcblxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuXG4gICAgfVxuXG4gICAgX2hhbmRsZUxvYWRQcm9ncmVzcyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdwcm9ncmVzcycsIHtwcm9ncmVzcyA6IHRoaXMucHJvZ3Jlc3N9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBlbmQgb2YgbG9hZGluZy4gaW5jbHVkaW5nIGNoYW5naW5nIGxvYWRlciBzdGF0dXMgYW5kIGZpcmluZyBldmVudHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZUxvYWRDb21wbGV0ZSgpIHtcblxuICAgICAgICB0aGlzLnN0YXR1cyA9IExvYWRlci5TVEFUVVMuQ09NUExFVEU7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAxO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbXBsZXRlJywge3RhcmdldDogdGhpc30pO1xuXG4gICAgfVxuXG59XG5cblxuXG5cblxuXG4vKipcbiAqIEhlbHBlciB0byByZXR1cm4gYSBtb3JlIHVzYWJsZSBvYmplY3QgZnJvbSB0aGUgcHJlbG9hZGVyLiBTaW1wbGUgZGV0ZWN0aW9uIGJhc2VkIG9uIGZpbGUgZXh0ZW5zaW9uXG4gKlxuICogQHBhcmFtIHVybCB0aGUgbG9hZGVkIGZpbGUncyBVUkxcbiAqIEBwYXJhbSBib2R5IHRoIGxvYWRlZCBmaWxlJ3MgY29udGVudFxuICogQHBhcmFtIGZvcmNlVHlwZSBzb21ldGltZXMgd2UgbmVlZCB0byBmb3JjZSBwYXJzaW5nIG9mIGEgY2VydGFpbiB0eXBlIHJlZ2FyZGxlc3Mgb2YgaXQncyBmaWxlIG5hbWVcbiAqL1xuTG9hZGVyLnBhcnNlUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24gKHVybCwgYm9keSwgZm9yY2VUeXBlID0gbnVsbCkge1xuXG4gICAgbGV0IHJldHVybk9iamVjdDtcblxuICAgIGxldCBleHQgPSAoZm9yY2VUeXBlICE9PSBudWxsKSA/IGZvcmNlVHlwZSA6IHVybC5zdWJzdHIoIHVybC5sYXN0SW5kZXhPZignLicpKzEgKTtcblxuICAgIHN3aXRjaCAoZXh0KSB7XG4gICAgICAgIGNhc2UgJ2pzJyA6XG4gICAgICAgICAgICByZXR1cm5PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHJldHVybk9iamVjdC50ZXh0Q29udGVudCA9IGJvZHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnanNvbicgOlxuICAgICAgICAgICAgcmV0dXJuT2JqZWN0ID0gSlNPTi5wYXJzZSggYm9keSApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N2ZycgOlxuICAgICAgICAgICAgbGV0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gYm9keTtcbiAgICAgICAgICAgIHJldHVybk9iamVjdCA9IHRlbXBEaXYuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDogLy8gcGFzcyB0aHJvdWdoXG4gICAgICAgICAgICByZXR1cm5PYmplY3QgPSBib2R5O1xuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5PYmplY3Q7XG5cbn07XG5cbkxvYWRlci5TVEFUVVMgPSB7XG4gICAgUEFVU0VEICAgICAgOiAncGF1c2VkJyxcbiAgICBMT0FESU5HICAgICA6ICdsb2FkaW5nJyxcbiAgICBDT01QTEVURSAgICA6ICdjb21wbGV0ZSdcbn07XG5cblxuXG5leHBvcnQge0xvYWRlciBhcyBkZWZhdWx0fTsiLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnbG9kYXNoL2RlZmF1bHRzJztcbmltcG9ydCBzdGFydHNXaXRoIGZyb20gJ2xvZGFzaC9zdGFydHNXaXRoJztcbmltcG9ydCBlbmRzV2l0aCBmcm9tICdsb2Rhc2gvZW5kc1dpdGgnO1xuXG5jb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgIGVudiA6ICdwcm9kJyxcbiAgICBiYXNlUGF0aCA6ICcvJyxcbiAgICBhc3NldFBhdGggOiAnLydcbn07XG5cbmNsYXNzIENvbmZpZ0NsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZShib290c3RyYXBDb25maWcpIHtcbiAgICAgICAgdGhpcy5iYXNlQ29uZmlnID0ge307XG5cbiAgICAgICAgLy8gbWVyZ2UgZGVmYXVsdCBjb25maWdcbiAgICAgICAgZGVmYXVsdHMoIHRoaXMuYmFzZUNvbmZpZywgYm9vdHN0cmFwQ29uZmlnLCBkZWZhdWx0Q29uZmlnKTtcblxuICAgICAgICAvLyBzdHJpcCBmaXJzdCBzbGFzaGVzIG9uIHN1YiBkaXIgcGF0aHNcbiAgICAgICAgdGhpcy5iYXNlQ29uZmlnLmFzc2V0UGF0aCA9IHN0YXJ0c1dpdGgodGhpcy5iYXNlQ29uZmlnLmFzc2V0UGF0aCwgJy8nKSA/IHRoaXMuYmFzZUNvbmZpZy5hc3NldFBhdGguc3Vic3RyKDEpIDogdGhpcy5iYXNlQ29uZmlnLmFzc2V0UGF0aDtcblxuICAgICAgICAvLyBlbnN1cmUgdHJhaWxpbmcgc2xhc2hcbiAgICAgICAgdGhpcy5iYXNlQ29uZmlnLmJhc2VQYXRoICs9IChlbmRzV2l0aCh0aGlzLmJhc2VDb25maWcuYmFzZVBhdGgsICcvJykgPyAnJyA6ICcvJyApO1xuICAgICAgICB0aGlzLmJhc2VDb25maWcuYXNzZXRQYXRoICs9IChlbmRzV2l0aCh0aGlzLmJhc2VDb25maWcuYXNzZXRQYXRoLCAnLycpID8gJycgOiAnLycgKTtcblxuICAgICAgICAvLyBhdXRvIGRldGVjdCBwcm90b2NvbDovL2RvbWFpbjpwb3J0XG4gICAgICAgIHRoaXMuYmFzZUNvbmZpZy5vcmlnaW4gPSBsb2NhdGlvbi5wcm90b2NvbCsnLy8nK2xvY2F0aW9uLmhvc3RuYW1lKyhsb2NhdGlvbi5wb3J0ID8gJzonK2xvY2F0aW9uLnBvcnQ6ICcnKTtcbiAgICB9XG5cbiAgICBnZXQgZW52KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ29uZmlnLmVudjtcbiAgICB9XG5cbiAgICBnZXQgYXNzZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ29uZmlnLm9yaWdpbiArIHRoaXMuYmFzZUNvbmZpZy5iYXNlUGF0aCArIHRoaXMuYmFzZUNvbmZpZy5hc3NldFBhdGg7XG4gICAgfVxuXG4gICAgZ2V0IGJhc2VQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ29uZmlnLm9yaWdpbiArIHRoaXMuYmFzZUNvbmZpZy5iYXNlUGF0aDtcbiAgICB9XG5cbn1cblxuY29uc3QgQ29uZmlnID0gbmV3IENvbmZpZ0NsYXNzKCk7XG5cbmV4cG9ydCB7Q29uZmlnIGFzIGRlZmF1bHQsIENvbmZpZ0NsYXNzfTsiLCJpbXBvcnQgaXNFbGVtZW50IGZyb20gJ2xvZGFzaC9pc0VsZW1lbnQnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC9kZWJvdW5jZSc7XG5pbXBvcnQgZmluZEluZGV4IGZyb20gJ2xvZGFzaC9maW5kSW5kZXgnO1xuXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi4vY29yZS9FdmVudFRhcmdldCc7XG5pbXBvcnQgV2luZG93TWFuYWdlciBmcm9tICcuLi91dGlscy9XaW5kb3dNYW5hZ2VyJztcbmltcG9ydCBTdHlsZSBmcm9tICcuLi91dGlscy9TdHlsZSc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gJy4uL2Rpc3BsYXkvZ2V0RG9jdW1lbnRSZWN0JztcblxuY2xhc3MgVHJhY2tlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcblxuICAgIGNvbnN0cnVjdG9yKGVsLCBvZmZzZXQgPSAxKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5zaWRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICB9XG5cbn1cblxuXG4vKipcbiAqXG4gKiAgU2Nyb2xsaW5nIHRyYWNrZXIgYWxsb3dzIHVzIHRvIGtub3cgd2hlbiBhbiBlbGVtZW50IGlzIG9mZiBzY3JlZW4sIG92ZXJsYXBwaW5nIHRoZSBzY3JlZW4gb3IgY29tcGxldGVseSBvbiBzY3JlZW4uXG4gKiAgSXQgYWxzbyBhbGxvd3MgdXMgdG8ga25vdyB3aGljaCBzaWRlIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQgaXMgKHRvcCBvciBib3R0b20pICpcbiAqXG4gKiBAdG9kbyB1bnRyYWNrIGVsZW1lbnRzXG4gKlxuICovXG5jbGFzcyBTY3JvbGxpbmdUcmFja2VyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuXG4gICAgY29uc3RydWN0b3Ioc2Nyb2xsQ29udGFpbmVyID0gd2luZG93KSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtXaW5kb3d9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRhaW5lciA9IHNjcm9sbENvbnRhaW5lcjtcblxuICAgICAgICB0aGlzLl90cmFja2VycyA9IFtdO1xuXG4gICAgICAgIGlmIChzY3JvbGxDb250YWluZXIgPT09IHdpbmRvdykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyggV2luZG93TWFuYWdlciwgJ3Njcm9sbCcsIHRoaXMuX3dpbmRvd1Njcm9sbEhhbmRsZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3JlYXRlIG91ciBvd24gc2Nyb2xsIGhhbmRsZXIgaWYgc2Nyb2xsaW5nIGFuIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEhhbmRsZXIgPSB0aGlzLl93aW5kb3dTY3JvbGxIYW5kbGVyLmJpbmQoIHRoaXMgKTtcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCAnc2Nyb2xsJywgdGhpcy5fc2Nyb2xsSGFuZGxlciApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5saXN0ZW5UbyggV2luZG93TWFuYWdlciwgJ3Jlc2l6ZScsIHRoaXMuX3dpbmRvd1Jlc2l6ZUhhbmRsZXIpO1xuXG4gICAgfVxuXG4gICAgLypcblxuICAgICBQdWJsaWMgbWV0aG9kc1xuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCB0cmFja2luZyB0aGUgc2Nyb2xsUG9zaXRpb24gb2YgYW4gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byB0cmFjay5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IC0gQSByYXRpbyBvZiB0aGUgdG90YWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge1RyYWNrZXJ9IEEgdHJhY2tlciBvYmplY3QgdGhhdCB3aWxsIGVtaXQgZXZlbnRzXG4gICAgICovXG4gICAgdHJhY2tFbGVtZW50KGVsLCBvZmZzZXQgPSAxKSB7XG5cbiAgICAgICAgbGV0IHRyYWNrZXIgPSBuZXcgVHJhY2tlcihlbCwgb2Zmc2V0KTtcblxuICAgICAgICB0aGlzLl90cmFja2Vycy5wdXNoKCB0cmFja2VyICk7XG5cbiAgICAgICAgdGhpcy5yZWZyZXNoRWxlbWVudE1ldHJpY3ModHJhY2tlcik7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gdHJhY2tlcjtcblxuICAgIH1cblxuICAgIHVudHJhY2tFbGVtZW50KGVsT3JUcmFja2VyKSB7XG5cbiAgICAgICAgbGV0IHRyYWNrZXJJbmRleDtcblxuICAgICAgICBpZiAoZWxPclRyYWNrZXIgaW5zdGFuY2VvZiBUcmFja2VyKSB7XG4gICAgICAgICAgICB0cmFja2VySW5kZXggPSB0aGlzLl90cmFja2Vycy5pbmRleE9mKCBlbE9yVHJhY2tlciApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhY2tlckluZGV4ID0gZmluZEluZGV4KHRoaXMuX3RyYWNrZXJzLCB7ZWw6IGVsT3JUcmFja2VyfSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fFRyYWNrZXJ9IGVsT3JUcmFja2VyIC0gRWxlbWVudCBvciBUcmFja2VyIG9iamVjdCB0aGF0IG5lZWRzIHRvIGJlIHJlZnJlc2hlZFxuICAgICAqL1xuICAgIHJlZnJlc2hFbGVtZW50TWV0cmljcyhlbE9yVHJhY2tlcikge1xuXG4gICAgICAgIGxldCB0cmFja2VycztcblxuICAgICAgICBpZiAoICFlbE9yVHJhY2tlciApIHtcbiAgICAgICAgICAgIHRyYWNrZXJzID0gdGhpcy5fdHJhY2tlcnM7XG4gICAgICAgIH0gZWxzZSBpZiAoIGlzRWxlbWVudChlbE9yVHJhY2tlcikgICkge1xuICAgICAgICAgICAgdHJhY2tlcnMgPSB0aGlzLl90cmFja2Vycy5maW5kKHRyYWNrZXIgPT4gdHJhY2tlciA9PT0gZWxPclRyYWNrZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKCBlbE9yVHJhY2tlciBpbnN0YW5jZW9mIFRyYWNrZXIgKSB7XG4gICAgICAgICAgICB0cmFja2VycyA9IFtlbE9yVHJhY2tlcl07XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRyYWNrZXJzLmZvckVhY2goIHRyYWNrZXIgPT4ge1xuXG4gICAgICAgICAgICAvLyBTYXZlICYgcmVtb3ZlIHRyYW5zZm9ybXNcbiAgICAgICAgICAgIGNvbnN0IGlzSW5saW5lVHJhbnNmb3JtU3R5bGUgPSAvdHJhbnNmb3JtXFxzKjpcXHMqW2EtejAtOV0rL2kudGVzdCggdHJhY2tlci5lbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5saW5lVHJhbnNpdGlvblN0eWxlID0gL3RyYW5zaXRpb25cXHMqOlxccypbYS16MC05XSsvaS50ZXN0KCB0cmFja2VyLmVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSApO1xuXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtICA9IFN0eWxlLmdldCggdHJhY2tlci5lbCwgJ3RyYW5zZm9ybScgKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2l0aW9uID0gU3R5bGUuZ2V0KCB0cmFja2VyLmVsLCAndHJhbnNpdGlvbicgKTtcblxuICAgICAgICAgICAgU3R5bGUuc2V0KCB0cmFja2VyLmVsLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gOiAnbm9uZSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBNZWFzdXJlIGFuZCBzYXZlIG1ldHJpY3MgdG8gdHJhY2tlclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudE1ldHJpY3MgPSBnZXREb2N1bWVudFJlY3QodHJhY2tlci5lbCk7XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IG9mZnNldFxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudE1ldHJpY3MuaGVpZ2h0ICogdHJhY2tlci5vZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBlbGVtZW50TWV0cmljcy50b3AgKyAgICAoKGVsZW1lbnRNZXRyaWNzLmhlaWdodCAtIGhlaWdodCkgLyAyKTtcblxuICAgICAgICAgICAgdHJhY2tlci50b3AgPSB0b3A7XG4gICAgICAgICAgICB0cmFja2VyLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgLy8gcmUtYXBwbHkgVHJhbnNmb3JtcyBhbmQgdHJhbnNpdGlvbnMgaWYgdGhleSB3ZXJlIHJlbW92ZWRcbiAgICAgICAgICAgIGlmIChjdXJyZW50VHJhbnNmb3JtICYmIGlzSW5saW5lVHJhbnNmb3JtU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBTdHlsZS5zZXQodHJhY2tlci5lbCwge3RyYW5zZm9ybTogY3VycmVudFRyYW5zZm9ybX0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFja2VyLmVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUcmFuc2l0aW9uIHx8IGlzSW5saW5lVHJhbnNpdGlvblN0eWxlKSB7XG4gICAgICAgICAgICAgICAgU3R5bGUuc2V0KHRyYWNrZXIuZWwsIHt0cmFuc2l0aW9uOiBjdXJyZW50VHJhbnNpdGlvbn0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFja2VyLmVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uJyk7XG4gICAgICAgICAgICB9XG5cblxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZShmYWxzZSk7XG5cbiAgICB9XG5cbiAgICAvKlxuXG4gICAgUHJpdmF0ZSBtZXRob2RzXG5cbiAgICAgKi9cblxuICAgIF9nZXRTY3JvbGxDb250YWluZXJTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zY3JvbGxDb250YWluZXIgPT09IHdpbmRvdyApID8gV2luZG93TWFuYWdlci5zY3JvbGxQb3NpdGlvbi50b3AgOiB0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgfVxuXG4gICAgX2dldFNjcm9sbENvbnRhaW5lckhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNjcm9sbENvbnRhaW5lciA9PT0gd2luZG93ICkgPyBXaW5kb3dNYW5hZ2VyLmhlaWdodCA6IHRoaXMuc2Nyb2xsQ29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICBfdXBkYXRlKHRyaWdnZXJFdmVudHMgPSB0cnVlKSB7XG5cbiAgICAgICAgbGV0IHNjcmVlblRvcCA9IHRoaXMuX2dldFNjcm9sbENvbnRhaW5lclNjcm9sbFRvcCgpO1xuICAgICAgICBsZXQgc2NyZWVuSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsQ29udGFpbmVySGVpZ2h0KCk7XG4gICAgICAgIGxldCBzY3JlZW5Cb3R0b20gPSBzY3JlZW5Ub3AgKyB0aGlzLl9nZXRTY3JvbGxDb250YWluZXJIZWlnaHQoKTtcblxuICAgICAgICB0aGlzLl90cmFja2Vycy5mb3JFYWNoKCB0cmFja2VyID0+IHtcblxuICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IHRyYWNrZXIuc3RhdGU7XG4gICAgICAgICAgICBsZXQgY3VycmVudFNpZGUgPSB0cmFja2VyLnNpZGU7XG4gICAgICAgICAgICBsZXQgbmV3U3RhdGU7XG4gICAgICAgICAgICBsZXQgbmV3U2lkZTtcblxuICAgICAgICAgICAgbGV0IHRyYWNrZXJUb3AgPSB0cmFja2VyLnRvcDtcbiAgICAgICAgICAgIGxldCB0cmFja2VyQm90dG9tID0gdHJhY2tlci50b3AgKyB0cmFja2VyLmhlaWdodDtcblxuICAgICAgICAgICAgLy8gU3RhdGUgY2hlY2tpbmcgOlxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGlzIE9GRiBzY3JlZW5cbiAgICAgICAgICAgIGlmIChzY3JlZW5Cb3R0b20gPCB0cmFja2VyVG9wIHx8IC8vIG9mZiBhbmQgYmVsb3dcbiAgICAgICAgICAgICAgICBzY3JlZW5Ub3AgPiB0cmFja2VyQm90dG9tKSB7ICAvLyBvZmYgYW5kIGFib3ZlXG5cbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFNjcm9sbGluZ1RyYWNrZXIuU1RBVEUuT0ZGO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGlzIE9WRVJMQVBQSU5HIHRoZSBzY3JlZW5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHNjcmVlblRvcCA8IHRyYWNrZXJUb3AgJiYgc2NyZWVuQm90dG9tIDwgdHJhY2tlckJvdHRvbSkgfHwgLy8gb3ZlcmxhcCBib3R0b21cbiAgICAgICAgICAgICAgICAoc2NyZWVuVG9wID4gdHJhY2tlclRvcCAmJiBzY3JlZW5Ub3AgPCB0cmFja2VyQm90dG9tKSAmJiAvLyBvdmVybGFwIGFib3ZlXG4gICAgICAgICAgICAgICAgIShzY3JlZW5Ub3AgPiB0cmFja2VyVG9wICYmIHNjcmVlbkJvdHRvbSA8IHRyYWNrZXJCb3R0b20gKSkgeyAvLyB3aGVuIGFuIGVsZW1lbnQgaXMgaGlnaGVyIHRoYW4gIHRoZSBzY3JlZW4sIHRoaXMgYXZvaWRzIGl0IG5ldmVyIGJlY29taW5nIG9uIHtcblxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PVkVSTEFQO1xuXG4gICAgICAgICAgICAvLyBJZiBlbGVtZW50IGlzIG5laXRoZXIgT0ZGIG9yIE9WRVJMQVBQSU5HLCBpdCBtdXN0IGJlIE9OXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gU2Nyb2xsaW5nVHJhY2tlci5TVEFURS5PTjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2lkZSBjaGVja2luZyA6XG4gICAgICAgICAgICBuZXdTaWRlID0gKCB0cmFja2VyVG9wICsgKHRyYWNrZXIuaGVpZ2h0ICogMC41KSA8IHNjcmVlblRvcCArIChzY3JlZW5IZWlnaHQgKiAwLjUpICkgPyBTY3JvbGxpbmdUcmFja2VyLlNJREUuQUJPVkUgOiBTY3JvbGxpbmdUcmFja2VyLlNJREUuQkVMT1c7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiBzdGF0ZSBvciBzaWRlIGhhcyBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICAgICAgICBsZXQgdXBkYXRlU3RhdGUgPSAobmV3U3RhdGUgIT09IGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgICAgICBsZXQgdXBkYXRlU2lkZSA9IChuZXdTaWRlICE9PSBjdXJyZW50U2lkZSk7XG5cbiAgICAgICAgICAgIC8vIHNhdmUgdmFsdWVzIHRvIHRyYWNrZXIgYmVmb3JlIGVtaXR0aW5nIGV2ZW50cyBmb3IgY29uc2lzdGVuY3kuXG4gICAgICAgICAgICB0cmFja2VyLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICB0cmFja2VyLnNpZGUgPSBuZXdTaWRlO1xuXG4gICAgICAgICAgICBpZiAodHJpZ2dlckV2ZW50cykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBldmVudE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlIDogbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRyYWNrZXJcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFja2VyLnRyaWdnZXIoJ3N0YXRlJywgZXZlbnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB0cmFja2VyLnRyaWdnZXIoYHN0YXRlOiR7bmV3U3RhdGV9YCwgZXZlbnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2VsZW1lbnQ6c3RhdGUnLCBldmVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVNpZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlIDogbmV3U2lkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA6IHRyYWNrZXJcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFja2VyLnRyaWdnZXIoJ3NpZGUnLCBldmVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZXIudHJpZ2dlcihgc2lkZToke25ld1NpZGV9YCwgZXZlbnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2VsZW1lbnQ6c2lkZScsIGV2ZW50T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cblxuICAgIC8qXG5cbiAgICBFdmVudCBoYW5kbGVyc1xuXG4gICAgICovXG5cbiAgICAvLyBUT0RPIHJlbmFtZSBiZWNhdXNlIG9mIGRpdiBzY3JvbGxpbmcgc3VwcG9ydFxuICAgIF93aW5kb3dTY3JvbGxIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH1cblxuICAgIF93aW5kb3dSZXNpemVIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHRoaXMucmVmcmVzaEVsZW1lbnRNZXRyaWNzKCk7XG4gICAgfVxuXG59XG5cbi8vIFBvc2l0aW9uIHJlbGF0ZWl2ZSB0byB0aGUgdmlld3BvcnRcblNjcm9sbGluZ1RyYWNrZXIuU1RBVEUgPSB7XG4gICAgT046ICdvbicsXG4gICAgT0ZGOiAnb2ZmJyxcbiAgICBPVkVSTEFQOiAnb3ZlcmxhcCdcbn07XG5cbi8vIFNpZGUsIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyBiZWxvdyBvciBhYm92ZSB0aGUgc2NyZWVuLiBUaGlzIGFsc28gZGVwZW5kcyBvbiB0aGUgZWxlbWVudCBoZWlnaHRcblNjcm9sbGluZ1RyYWNrZXIuU0lERSA9IHtcbiAgICBBQk9WRTogJ2Fib3ZlJyxcbiAgICBCRUxPVzogJ2JlbG93J1xufTtcblxuU2Nyb2xsaW5nVHJhY2tlci5ESVJFQ1RJT04gPSB7XG4gICAgVVA6IC0xLFxuICAgIERPV046IDFcbn07XG5cbmV4cG9ydCB7U2Nyb2xsaW5nVHJhY2tlciBhcyBkZWZhdWx0LCBUcmFja2VyfTsiLCJpbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICdsb2Rhc2gvY2FwaXRhbGl6ZSc7XG5pbXBvcnQgZmluZCBmcm9tICdsb2Rhc2gvZmluZCc7XG5pbXBvcnQgaXNFbGVtZW50IGZyb20gJ2xvZGFzaC9pc0VsZW1lbnQnO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gJ2xvZGFzaC9pc1N0cmluZyc7XG5cbi8vIGJyb3dzZXIgcHJlZml4ZXNcbmNvbnN0IFBSRUZJWEVTID0gW1xuICAgICdXZWJraXQnLFxuICAgICdNb3onLFxuICAgICdNUycsXG4gICAgJ08nXG5dO1xuXG4vLyBDYWNoZSBvZiBtb2RpZmllciBmdW5jdGlvbnMgb25jZSB0aGUgcHJvcGVyIHByZWZpeCBoYXMgYmVlbiBmb3VuZFxuY29uc3QgcHJlZml4ZWRNb2RpZmllckNhY2hlID0ge307XG5cbi8vIFRlc3QgZWxlbWVudCBmb3IgZmluZGluZyBwcmVmaXhlZCBwcm9wZXJ0aWVzXG5jb25zdCBwcmVmaXhUZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBwcmVmaXhlZCBhd2FyZSBDU1MgbW9kaWZpZXIgZm9yIGEgcHJvcGVydHkuXG4gKlxuICogR2VuZXJhdGVkIG1vZGlmaWVycyBhcmUgc3RvcmVkIGluIHRoZSBjYWNoZSBkZWNsYXJlZCBhYm92ZVxuICpcbiAqIEBwYXJhbSBwcm9wZXJ0eVxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kaWZpZXIocHJvcGVydHkpIHtcblxuICAgIC8vIGdldCBhbGwgcHJlZml4ZWQgcHJvcGVydGllcyAoYW5kIHVuLXByZWZpeGVkIGluIGZpcnN0IHBvc2l0aW9uKS4gcHJlZml4ZWQgcHJvcGVydGllcyBhcmUgY2FtZWwgY2FzZWRcbiAgICBsZXQgcHJlZml4ZWRQcm9wZXJ0aWVzID0gW3Byb3BlcnR5XS5jb25jYXQoIFBSRUZJWEVTLm1hcCggcHJlZml4ID0+IHByZWZpeCArIGNhcGl0YWxpemUocHJvcGVydHkpICkgKTtcblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGFjY2VwdGFibGUgcHJvcGVydHkgbmFtZVxuICAgIGxldCBwcmVmaXhlZFByb3BOYW1lID0gZmluZChwcmVmaXhlZFByb3BlcnRpZXMsIChwcm9wKSA9PiBwcm9wIGluIHByZWZpeFRlc3RFbC5zdHlsZSk7XG5cbiAgICAvLyBjYWNoZSBtb2RpZmllciB0byBvYmplY3RcbiAgICBwcmVmaXhlZE1vZGlmaWVyQ2FjaGVbcHJvcGVydHldID0gZnVuY3Rpb24odGFyZ2V0U3R5bGUsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFN0eWxlW3ByZWZpeGVkUHJvcE5hbWVdID0gdmFsdWU7XG4gICAgfTtcblxuICAgIHJldHVybiBwcmVmaXhlZE1vZGlmaWVyQ2FjaGVbcHJvcGVydHldO1xufVxuXG4vKipcbiAqIFN0eWxlIHV0aWwgdG8gaGVscCBzZXR0aW5nIGFuZCBnZXR0aW5nIHN0eWxlIHByb3BlcnRpZXNcbiAqXG4gKiBAdG9kbyBhY2NlcHQgc2hvcnRoYW5kIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGxpa2UgeCx5LHNjYWxlLHJvdGF0ZS5cbiAqIEB0eXBlIHt7c2V0OiBTdHlsZS5zZXQsIGdldDogU3R5bGUuZ2V0LCBhZGRVbml0czogU3R5bGUuYWRkVW5pdHMsIHN0cmlwVW5pdHM6IFN0eWxlLnN0cmlwVW5pdHN9fVxuICovXG5jb25zdCBTdHlsZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFNldCBzdHlsZXMgb24gYW4gRWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgb24gd2hpY2ggdG8gc2V0IHN0eWxlcy4gQ2FuIGFsc28gYmUgdGhlIEVsZW1lbnQncyBzdHlsZSBvYmplY3QgZGlyZWN0bHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGFzIGtleXMgYW5kIHZhbHVlcyBhc1xuICAgICAqL1xuICAgIHNldCA6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgbGV0IGVsZW1lbnRTdHlsZXMgPSAoIGlzRWxlbWVudChlbGVtZW50KSApID8gZWxlbWVudC5zdHlsZSA6IGVsZW1lbnQ7XG5cbiAgICAgICAgLy8gdHJlYXQgcHJvcGVydGllcyBhcyBhbiBvYmplY3Qgb2YgY3NzcHJvcGVydHluYW1lIDogdmFsdWUgcGFpcnNcbiAgICAgICAgZm9yICggbGV0IHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGEgdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydGllcyBpc24ndCBhbHJlYWR5IGEgc3RyaW5nLCBmb3JtYXQgaXQuXG4gICAgICAgICAgICAgICAgbGV0IHNwZWNpZmllZFZhbHVlID0gcHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgICAgICAgICBsZXQgZmluYWxWYWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZWRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gaXNTdHJpbmcoc3BlY2lmaWVkVmFsdWUpID8gc3BlY2lmaWVkVmFsdWUgOiB0aGlzLmFkZFVuaXRzKHByb3AsIHNwZWNpZmllZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgY2FjaGVkIG9yIG5ldyBtb2RpZmllciBmdW5jdGlvbiBhbmQgdXNlIGl0IHRvIG1vZGlmeSBlbGVtZW50IHN0eWxlc1xuICAgICAgICAgICAgICAgICggcHJlZml4ZWRNb2RpZmllckNhY2hlW3Byb3BdIHx8IGNyZWF0ZU1vZGlmaWVyKHByb3ApICkoZWxlbWVudFN0eWxlcywgZmluYWxWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3R5bGUgYXBwbGllZCB0byB0aGlzIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIFRPRE8gY2hlY2sgb24gZWxlbWVudC5zdHlsZSBvYmplY3QgaWYgd2UgY2FuIGRldGVjdCAhaW1wb3J0YW50IHJ1bGVzIHNvbWV3YXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHBhcmFtIHByb3BlcnR5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ9IHRoZSBDU1MgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgOiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpcFVuaXRzKHByb3BlcnR5LCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbWVudCApWyBwcm9wZXJ0eSBdICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCB1bml0cyB0byB0aGUgQ1NTIHZhbHVlIGlmIHBvc3NpYmxlLiB1c2VmdWxsIGZvciBzcGVjaWZ5aW5nIHBpeGVsIHZhbHVlcyBhcyBudW1iZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBuYW1lIG9mIHRoZSBDU1MgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIC0gdmFsdWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgaXNuJ3QgYSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPSdweCddIC0gQ1NTIHVuaXQgZm9yIHRoZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSB3aXRoIGFwcHJvcHJpYXRlIHVuaXRzLiBiZVxuICAgICAqL1xuICAgIGFkZFVuaXRzIDogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlLCB1bml0cyA9ICdweCcpIHtcblxuICAgICAgICBsZXQgZm9ybWF0dGVkVmFsdWU7XG5cbiAgICAgICAgc3dpdGNoKHByb3BlcnR5KSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnIDpcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JyA6XG4gICAgICAgICAgICBjYXNlICdib3R0b20nIDpcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnIDpcbiAgICAgICAgICAgIGNhc2UgJ21pbldpZHRoJyA6XG4gICAgICAgICAgICBjYXNlICdtaW5IZWlnaHQnIDpcbiAgICAgICAgICAgIGNhc2UgJ3dpZHRoJyA6XG4gICAgICAgICAgICBjYXNlICdoZWlnaHQnIDpcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkgKyB1bml0cztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnb3BhY2l0eScgOlxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JtYXQgdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgIGlmICggZm9ybWF0dGVkVmFsdWUgPT09IG51bGwgKSBmb3JtYXR0ZWRWYWx1ZSA9ICcnO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RyaXAgdW5pdHMgYW5kIHJldHVybiBhcyBhIG51bWJlciBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIHJldHVybiBhIHN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gdGhlIENTUyBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIENTUyB2YWx1ZSBhcyByZWFkIGZyb20gdGhlIGJyb3dzZXIuXG4gICAgICogQHJldHVybiB7c3RyaW5nfG51bWJlcn0gQ1NTIHZhbHVlIGNhc3QgdG8gbnVtYmVyIGlmIHBvc3NpYmxlXG4gICAgICovXG4gICAgc3RyaXBVbml0cyA6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcblxuICAgICAgICBsZXQgZm9ybWF0dGVkVmFsdWU7XG5cbiAgICAgICAgc3dpdGNoKHByb3BlcnR5KSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnIDpcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JyA6XG4gICAgICAgICAgICBjYXNlICdib3R0b20nIDpcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnIDpcbiAgICAgICAgICAgIGNhc2UgJ21pbldpZHRoJyA6XG4gICAgICAgICAgICBjYXNlICdtaW5IZWlnaHQnIDpcbiAgICAgICAgICAgIGNhc2UgJ3dpZHRoJyA6XG4gICAgICAgICAgICBjYXNlICdoZWlnaHQnIDpcbiAgICAgICAgICAgIGNhc2UgJ29wYWNpdHknIDpcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkVmFsdWVcblxuICAgIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgU3R5bGU7XG4iLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnbG9kYXNoL2RlZmF1bHRzJztcbmltcG9ydCB0aHJvdHRsZSBmcm9tICdsb2Rhc2gvdGhyb3R0bGUnO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gJ2xvZGFzaC9pc1N0cmluZyc7XG5pbXBvcnQgaXNOdW1iZXIgZnJvbSAnbG9kYXNoL2lzTnVtYmVyJztcbmltcG9ydCBpc09iamVjdCBmcm9tICdsb2Rhc2gvaXNPYmplY3QnO1xuaW1wb3J0IGZpbmQgZnJvbSAnbG9kYXNoL2ZpbmQnO1xuaW1wb3J0IGZpbmRMYXN0IGZyb20gJ2xvZGFzaC9maW5kTGFzdCc7XG5cbmltcG9ydCBFdmVudFRhcmdldCAgZnJvbSAnLi4vY29yZS9FdmVudFRhcmdldCc7XG5cbi8vIENyb3NzIHBsYXRmb3JtIGZ1bmN0aW9uIHRvIGdldCBzY3JvbGwgcG9zaXRpb25cbmNvbnN0IGdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgMDtcbn07XG5cbmNvbnN0IGdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgMDtcbn07XG5cbmxldCBXaW5kb3dNYW5hZ2VyO1xuXG5jbGFzcyBXaW5kb3dNYW5hZ2VyQ2xhc3MgZXh0ZW5kcyBFdmVudFRhcmdldHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBTaW5nbGV0b24gY2hlY2tcbiAgICAgICAgaWYgKCBXaW5kb3dNYW5hZ2VyICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93TWFuYWdlciBpcyBhIFNpbmdsZXRvbiwgYW4gaW5zdGFuY2UgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgSW5pdGlhbGl6YXRpb24gZnVuY3Rpb25cblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIGluaXRpYWxpemUgKGNvbmZpZykge1xuXG4gICAgICAgIGlmICggIXRoaXMuaW5pdGlhbGl6ZWQgKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IGRlZmF1bHRzKGNvbmZpZyB8fCB7fSwgV2luZG93TWFuYWdlckNsYXNzLmRlZmF1bHRDb25maWcpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFycmF5IG9mIGJyZWFrcG9pbnRzLiBZb3UgY2FuIG5vdCBjaGFuZ2UgYnJlYWtwb2ludHMgb25jZSB0aGV5IGFyZSBzZXRcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5icmVha3BvaW50cyA9IHRoaXMuY29uZmlnLmJyZWFrcG9pbnRzO1xuXG4gICAgICAgICAgICAvLyBGcmVlemUgYnJlYWtwb2ludHNcbiAgICAgICAgICAgIHRoaXMuYnJlYWtwb2ludHMuZm9yRWFjaCggYnAgPT4gT2JqZWN0LmZyZWV6ZShicCkgKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBzYXZlIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLl9kb21FdmVudHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2RvbUV2ZW50cy5yZXNpemUgID0gdGhyb3R0bGUodGhpcy5fcmVzaXplSGFuZGxlci5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy5yZXNpemVUaHJvdHRsZSk7XG4gICAgICAgICAgICB0aGlzLl9kb21FdmVudHMubG9hZCAgICA9IHRoaXMuX2xvYWRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9kb21FdmVudHMudW5sb2FkICA9IHRoaXMuX3VubG9hZEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2RvbUV2ZW50cy5zY3JvbGwgID0gdGhyb3R0bGUoIHRoaXMuX3Njcm9sbEhhbmRsZXIuYmluZCh0aGlzKSwgdGhpcy5jb25maWcuc2Nyb2xsVGhyb3R0bGUpO1xuXG4gICAgICAgICAgICAvLyBsaXN0ZW4gZm9yIGV2ZW50c1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2RvbUV2ZW50cy5yZXNpemUpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAgIHRoaXMuX2RvbUV2ZW50cy5sb2FkKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmxvYWQnLCB0aGlzLl9kb21FdmVudHMudW5sb2FkKTtcblxuICAgICAgICAgICAgdGhpcy5iaW5kU2Nyb2xsRXZlbnQoKTtcblxuICAgICAgICAgICAgLy8gc2V0IHVwIHZhcmlhYmxlIHRyYWNraW5nXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0gdGhpcy5zY3JvbGxQb3NpdGlvbiB8fCB7dG9wOiBnZXRTY3JvbGxUb3AoKX07XG5cbiAgICAgICAgICAgIC8vIGNhY2hlIHdpbmRvdyBtZXRyaWNzIG5vd1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWV0cmljcygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsTWV0cmljcygpO1xuXG4gICAgICAgICAgICB0aGlzLl9kZXRlY3RCcmVha3BvaW50KHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgIFB1YmxpYyBNZW1iZXJzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIC8vIEFsbG93IHNjcm9sbCBldmVudCB0byBiZSBkZXRhY2hlZCBmcm9tIHdpbmRvdy4gVXNlZnVsIGZvciB2aXJ0dWFsIHNjcm9sbGluZy4gKHNob3V0IG91dCB0byBNRywgaGUnbGwgbG92ZSBpdClcbiAgICAvKipcbiAgICAgKiBTdGFydCBsaXN0ZW5pbmcgZm9yIG5hdGl2ZSB3aW5kb3cgc2Nyb2xsIGV2ZW50c1xuICAgICAqL1xuICAgIGJpbmRTY3JvbGxFdmVudCgpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2RvbUV2ZW50cy5zY3JvbGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgbGlzdGVuaW5nIGZvciBuYXRpdmUgd2luZG93IHNjcm9sbCBldmVudHNcbiAgICAgKi9cbiAgICB1bmJpbmRTY3JvbGxFdmVudCgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2RvbUV2ZW50cy5zY3JvbGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0byB0aGlzIHBvc2l0aW9uIGluIHRoZSB3aW5kb3cuIFVwZGF0ZXMgdGhlIGludGVybmFsIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIE1vdmUgc2Nyb2xsIHRvIHRvIGhlcmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIE1vdmUgc2Nyb2xsIGxlZnQgdG8gaGVyZS5cbiAgICAgKi9cbiAgICBzY3JvbGxUbyh5ID0gMCwgeCA9IDApIHtcblxuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uLnRvcCA9IHk7XG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24ubGVmdCA9IHg7XG5cbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHgsIHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgdmlld3BvcnQgaXMgb2YgYSBhIG1pbmltdW0gd2lkdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xOdW1iZXJ9IGJyZWFrcG9pbnQgLSBJZiBvZiB0eXBlIG9iamVjdCwgYXNzdW1lcyB0byBiZSBhIG5hbWVkIGJyZWFrcG9pbnQgb2JqZWN0IHdpdGggYSB2YWx1ZSBwcm9wZXJ0eS5cbiAgICAgKiAgSWYgYSBzdHJpbmcsIGEgbmFtZWQgYnJlYWtwb2ludCdzIG5hbWUuIElmIGEgbnVtYmVyIHRoZSBicmVha3BvaW50J3MgdmFsdWUuIEEgbnVtYmVyIG1heWJlIHVzZWQgdG8gYXJiaXRyYXJpbHkgY2hlY2sgd2luZG93IHdpZHRoXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoZSB2aWV3cG9ydCBpcyBhdCBsZWFzdCBvZiBicmVha3BvaW50IHNpemUuXG4gICAgICovXG4gICAgbWluV2lkdGgoYnJlYWtwb2ludCkge1xuXG4gICAgICAgIC8vIEdldCBudW1lcmljYWwgdmFsdWUgZm9yIGJyZWFrcG9pbnRcbiAgICAgICAgbGV0IGJyZWFrcG9pbnRWYWx1ZTtcbiAgICAgICAgaWYgKCBpc051bWJlcihicmVha3BvaW50KSApIHtcbiAgICAgICAgICAgIGJyZWFrcG9pbnRWYWx1ZSA9IGJyZWFrcG9pbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIGlzU3RyaW5nKGJyZWFrcG9pbnQpICkge1xuICAgICAgICAgICAgYnJlYWtwb2ludFZhbHVlID0gZmluZCggdGhpcy5icmVha3BvaW50cywge25hbWU6IGJyZWFrcG9pbnR9KS52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICggaXNPYmplY3QoYnJlYWtwb2ludCkgKSB7XG4gICAgICAgICAgICBicmVha3BvaW50VmFsdWUgPSBicmVha3BvaW50LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPj0gYnJlYWtwb2ludFZhbHVlO1xuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgUHJpdmF0ZSBNZW1iZXJzXG5cbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSB3aW5kb3cgbWV0cmljcyB0byB0aGlzIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZU1ldHJpY3MoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGludGVybmFsIHZhciB0aGF0IHRyYWNrcyB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlU2Nyb2xsTWV0cmljcygpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbi50b3AgPSBnZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbi5sZWZ0ID0gZ2V0U2Nyb2xsTGVmdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiB3aW5kb3cgcmVzaXplIGV2ZW50cyB0byBkZXRlY3Qgd2hpY2ggYnJlYWtwb2ludCB3ZSdyZSBvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc3VwcHJlc3NFdmVudHM9ZmFsc2VdIC0gRG8gbm90IHRyaWdnZXIgYSBicmVha3BvaW50IGV2ZW50IHdoZW4gYSBjaGFuZ2UgaXMgZGV0ZWN0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZXRlY3RCcmVha3BvaW50KHN1cHByZXNzRXZlbnRzID0gZmFsc2UpIHtcblxuICAgICAgICAvLyBmaW5kIGJpZ2dlc3QgbWF0Y2hpbmcgQlBcbiAgICAgICAgbGV0IGJyZWFrcG9pbnQgPSBmaW5kTGFzdCh0aGlzLmJyZWFrcG9pbnRzLCAoYnApID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoID49IGJwLnZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvbnkgaWYgdGhlIGJyZWFrcG9pbnQgaGFzIGNoYW5nZWRcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJyZWFrcG9pbnQgIT09IGJyZWFrcG9pbnQpIHtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c0JyZWFrcG9pbnQgPSB0aGlzLmN1cnJlbnRCcmVha3BvaW50O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QnJlYWtwb2ludCA9IGJyZWFrcG9pbnQ7XG5cbiAgICAgICAgICAgIC8vIGRpc3BhdGNoIGV2ZW50IGZvciBicmVha3BvaW50LCBzaW1wbHkgY2xvbmluZyB0aGUgQlAgb2JqZWN0IGZvciB0aGUgZXZlbnQgZGF0YVxuICAgICAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYnJlYWtwb2ludCcsIHticmVha3BvaW50OiBicmVha3BvaW50LCBwcmV2aW91cyA6IHByZXZpb3VzQnJlYWtwb2ludH0pOyAvLyBUT0RPIG1ha2UgYnJlYWtwb2ludHMgaW1tdXRhYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgRXZlbnQgSGFuZGxlcnNcblxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIHdpbmRvdyBzY3JvbGwgaGFuZGxlci4gVGhpcyBjYWxsIGlzIHRocm90dGxlZFxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Njcm9sbEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzVG9wID0gdGhpcy5zY3JvbGxQb3NpdGlvbi50b3A7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbE1ldHJpY3MoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRUb3AgPSB0aGlzLnNjcm9sbFBvc2l0aW9uLnRvcDtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgZGlyZWN0aW9uIGJ5IGNvbXBhcmluZyBwcmV2aW91cyBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IChwcmV2aW91c1RvcCA8IGN1cnJlbnRUb3ApID8gMSA6IC0xO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgY3VzdG9tIGV2ZW50XG4gICAgICAgIHRoaXMudHJpZ2dlcignc2Nyb2xsJywge3Njcm9sbFBvc2l0aW9uOiB0aGlzLnNjcm9sbFBvc2l0aW9uLCBkaXJlY3Rpb24gOiBkaXJlY3Rpb24sIG9yaWdpbmFsRXZlbnQ6IGV2ZW50fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgd2luZG93IHJlc2l6ZSBoYW5kbGVyLiBUaGlzIGNhbGwgaXMgdGhyb3R0bGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzaXplSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlTWV0cmljcygpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Jlc2l6ZScsIHt3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodH0pO1xuICAgICAgICB0aGlzLl9kZXRlY3RCcmVha3BvaW50KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHdpbmRvdyB1bmxvYWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5sb2FkSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd1bmxvYWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3J3YXJkIHRoZSB3aW5kb3cgbG9hZCBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2xvYWRIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2xvYWQnKTtcbiAgICB9XG5cbn1cblxuV2luZG93TWFuYWdlckNsYXNzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgc2Nyb2xsVGhyb3R0bGU6IDE1LCAvLyBudW1iZXIgb2YgbXMgYmV0d2VlbiBzY3JvbGwgZXZlbnRzXG4gICAgcmVzaXplVGhyb3R0bGU6IDUwLCAvLyBudW1iZXIgb2YgbXMgYmV0d2VlbiByZXNpemUgZXZlbnRzXG4gICAgZGlzYWJsZVNjcm9sbENsYXNzOiBudWxsLCAvLyBjbGFzcyBuYW1lIHRvIHVzZSBmb3IgdGhlIGRpc2FibGUgc2Nyb2xsIGNsYXNzLiBkZWZhdWx0IGlzIHRvIGFwcGx5IHN0eWxlcyBkaXJlY3RseVxuICAgIGRpc2FibGVVc2VySW5wdXRDbGFzczogbnVsbCwgLy8gY2xhc3MgbmFtZSB0byB1c2UgZm9yIHRoZSBkaXNhYmxlIHVzZXIgaW5wdXQgY2xhc3MuIGRlZmF1bHQgaXMgdG8gYXBwbHkgc3R5bGVzIGRpcmVjdGx5XG59O1xuXG4vLyBDcmVhdGUgb3VyIFNpbmdsZXRvblxuV2luZG93TWFuYWdlciA9IG5ldyBXaW5kb3dNYW5hZ2VyQ2xhc3MoKTtcblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBieSBkZWZhdWx0IGFuZCBDbGFzcyBpZiBpbnRyb3NwZWN0aW9uIG5lZWRlZFxuZXhwb3J0IHtXaW5kb3dNYW5hZ2VyIGFzIGRlZmF1bHQsIFdpbmRvd01hbmFnZXJDbGFzc307XG4iXX0=
